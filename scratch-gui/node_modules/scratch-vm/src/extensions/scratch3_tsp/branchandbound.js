// function TinyQueue(data, compare) {
//     if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

//     this.data = data || [];
//     this.length = this.data.length;
//     this.compare = compare || defaultCompare;

//     if (this.length > 0) {
//         for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
//     }
// }
// TinyQueue.prototype = {

//     push: function (item) {
//         this.data.push(item);
//         this.length++;
//         this._up(this.length - 1);
//     },

//     pop: function () {
//         if (this.length === 0) return undefined;

//         var top = this.data[0];
//         this.length--;

//         if (this.length > 0) {
//             this.data[0] = this.data[this.length];
//             this._down(0);
//         }
//         this.data.pop();

//         return top;
//     },

//     peek: function () {
//         return this.data[0];
//     },

//     _up: function (pos) {
//         var data = this.data;
//         var compare = this.compare;
//         var item = data[pos];

//         while (pos > 0) {
//             var parent = (pos - 1) >> 1;
//             var current = data[parent];
//             if (compare(item, current) >= 0) break;
//             data[pos] = current;
//             pos = parent;
//         }

//         data[pos] = item;
//     },

//     _down: function (pos) {
//         var data = this.data;
//         var compare = this.compare;
//         var halfLength = this.length >> 1;
//         var item = data[pos];

//         while (pos < halfLength) {
//             var left = (pos << 1) + 1;
//             var right = left + 1;
//             var best = data[left];

//             if (right < this.length && compare(data[right], best) < 0) {
//                 left = right;
//                 best = data[right];
//             }
//             if (compare(best, item) >= 0) break;

//             data[pos] = best;
//             pos = left;
//         }

//         data[pos] = item;
//     }
// };

// function nextState(state, next, n, d) {
//     var nextState = {
//         path: state.path.slice(),
//         length: state.length
//     };
//     if (state.path.length > 0) {
//         nextState.length += d[state.path[state.path.length - 1]][next];
//     }
//     nextState.path.push(next);
//     if (nextState.path.length === n) {
//         nextState.length += d[next][state.path[0]];
//     }
//     nextState.approximation = nextState.length + approximate(nextState.path, n, d);
//     return nextState;
// }



// // Function to calculate the distance between two points
// function calculateDistance(x1, y1, x2, y2) {
//     var dx = x2 - x1;
//     var dy = y2 - y1;
//     return Math.sqrt(dx * dx + dy * dy);
//     }

//     // Function to calculate the approximation for the current path
//     function approximate(path, n, d) {
//     if (path.length === n) {
//         return 0;
//     }
//     var from = [];
//     var to = [];
//     var approximation = 0;
//     for (var i = 0; i < n; i++) {
//         if (path.indexOf(i) === -1) {
//         from.push(i);
//         }
//     }
//     for (var j = 0; j < n; j++) {
//         if (path.indexOf(j) === -1) {
//         to.push(j);
//         }
//     }
//     if (path.length > 0) {
//         from.push(path[path.length - 1]);
//     }
//     if (path.length > 0) {
//         to.push(path[0]);
//     }
//     var nearest = new Array(n);
//     for (var a = 0; a < from.length; a++) {
//         var minimal = Infinity;
//         for (var b = 0; b < to.length; b++) {
//         if (from[a] !== to[b]) {
//             minimal = Math.min(minimal, d[from[a]][to[b]]);
//         }
//         }
//         nearest[from[a]] = minimal;
//         approximation += minimal;
//     }
//     for (var c = 0; c < to.length; c++) {
//         var delta = Infinity;
//         for (var e = 0; e < from.length; e++) {
//         if (from[e] !== to[c]) {
//             delta = Math.min(delta, d[from[e]][to[c]] - nearest[from[e]]);
//         }
//         }
//         approximation += delta;
//     }
//     return approximation;
// }

// // Function to solve the TSP using Branch and Bound
// export function solveBranchAndBound(coordinates) {
//     var n = coordinates.length / 2;
//     var d = new Array(n);
//     for (var i = 0; i < n; i++) {
//         d[i] = new Array(n);
//         for (var j = 0; j < n; j++) {
//         var x1 = coordinates[i * 2];
//         var y1 = coordinates[i * 2 + 1];
//         var x2 = coordinates[j * 2];
//         var y2 = coordinates[j * 2 + 1];
//         d[i][j] = calculateDistance(x1, y1, x2, y2);
//         }
//     }

//     var queue = new TinyQueue([{ path: [], length: 0, approximation: 0 }], function (a, b) {
//         return a.approximation - b.approximation;
//     });
    
    
//     var bestPath = [];
//     var bestDistance = Infinity;

//     while (queue.length > 0) {
//         var current = queue.pop();
//         if (current.approximation >= bestDistance) {
//             break;
//         }
//         if (current.path.length === n) {
//             if (current.length < bestDistance) {
//                 bestPath = current.path; // Store the best path without reversing it
//                 bestDistance = current.length;
//             }
//             continue;
//         }
//         var unused = [];
//         for (var k = 0; k < n; k++) {
//             if (current.path.indexOf(k) === -1) {
//                 unused.push(k);
//             }
//         }
//         for (var l = 0; l < unused.length; l++) {
//             var next = unused[l];
//             var next_state = nextState(current, next, n, d);
//             queue.push(next_state);
//         }
//     }

//     return {
//         bestPath: bestPath, // Return the best path without reversing it
//         totalDistance: bestDistance
//     };

// }

function calculateDistance(node1, node2) {
    const dx = node1.x - node2.x;
    const dy = node1.y - node2.y;
    return Math.sqrt(dx * dx + dy * dy);
}

// Function to perform the Branch and Bound algorithm to find the best path and distance
export function branchAndBound(coordinates) {
    const n = coordinates.length / 2;
    const nodes = [];

    // Create nodes with (x, y) coordinates from the input array
    for (let i = 0; i < n; i++) {
    nodes.push({ x: coordinates[2 * i], y: coordinates[2 * i + 1] });
    }

    const d = new Array(n);

    // Create the distance matrix 'd' based on the nodes' (x, y) coordinates
    for (let i = 0; i < n; i++) {
    d[i] = new Array(n);
    for (let j = 0; j < n; j++) {
        d[i][j] = calculateDistance(nodes[i], nodes[j]);
    }
    }

    // Branch and Bound algorithm to find the best path
    const queue = [{ path: [0], length: 0, approximation: 0 }];
    let bestDistance = Infinity;
    let bestPath = [];

    while (queue.length > 0) {
    const current = queue.shift();

    if (current.length >= bestDistance) {
        continue; // Prune the branch if the current length exceeds the best distance found so far
    }

    if (current.path.length === n) {
        // If all nodes are visited, update the best distance and path
        const totalDistance = current.length + d[current.path[n - 1]][current.path[0]];
        if (totalDistance < bestDistance) {
        bestDistance = totalDistance;
        bestPath = current.path;
        }
        continue;
    }

    const unused = new Set(Array.from(Array(n).keys()).filter((i) => !current.path.includes(i)));

    for (const next of unused) {
        const newPath = [...current.path, next];
        const newLength = current.length + d[current.path[current.path.length - 1]][next];
        const newApproximation = newLength + approximate(newPath, n, d);
        queue.push({ path: newPath, length: newLength, approximation: newApproximation });
    }

    queue.sort((a, b) => a.approximation - b.approximation); // Sort the queue based on the approximation
    }

    return { path: bestPath, distance: bestDistance };
}

// Approximate function (same as in the original file)
function approximate(path, n, d) {
    if (path.length === n) {
        return 0;
    }
    var from = [];
    var to = [];
    var approximation = 0;
    for (var i = 0; i < n; i++) if (path.indexOf(i) === -1) from.push(i);
    for (var j = 0; j < n; j++) if (path.indexOf(j) === -1) to.push(j);
    if (path.length > 0) from.push(path[path.length - 1]);
    if (path.length > 0) to.push(path[0]);
    var nearest = new Array(n);
    for (var a = 0; a < from.length; a++) {
        var minimal = Infinity;
        for (var b = 0; b < to.length; b++) {
            if (from[a] !== to[b]) {
                minimal = Math.min(minimal, d[from[a]][to[b]]);
            }
        }
        nearest[from[a]] = minimal;
        approximation += minimal;
    }
    for (var c = 0; c < to.length; c++) {
        var delta = Infinity;
        for (var e = 0; e < from.length; e++) {
            if (from[e] !== to[c]) {
                delta = Math.min(delta, d[from[e]][to[c]] - nearest[from[e]]);
            }
        }
        approximation += delta;
    }
    return approximation;
}