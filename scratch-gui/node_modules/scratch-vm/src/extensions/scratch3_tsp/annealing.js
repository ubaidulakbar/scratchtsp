// export function simulatedAnnealing(nodes) {
//     function convertToCoordinates(nodes) {
//         const coordinates = [];
//         for (let i = 0; i < nodes.length; i += 2) {
//         const x = nodes[i];
//         const y = nodes[i + 1];
//         coordinates.push([x, y]);
//         }
//         return coordinates;
//     }
//     nodes = convertToCoordinates(nodes);
//     function distance(node1, node2) {
//         const dx = node1[0] - node2[0];
//         const dy = node1[1] - node2[1];
//         return Math.sqrt(dx * dx + dy * dy);
//     }

//     function getPathLength(path) {
//         let length = 0;
//         for (let i = 0; i < path.length - 1; i++) {
//             length += distance(nodes[path[i]], nodes[path[i + 1]]);
//         }
//         length += distance(nodes[path[path.length - 1]], nodes[path[0]]);
//         return length;
//     }

//     function getRandomNeighbor(path) {
//         const neighbor = path.slice();
//         const i = Math.floor(Math.random() * path.length);
//         const j = (i + 1) % path.length;
//         neighbor[i] = path[j];
//         neighbor[j] = path[i];
//         return neighbor;
//     }

//     const initialPath = Array.from(Array(nodes.length).keys());
//     let currentPath = initialPath.slice();
//     let bestPath = initialPath.slice();
//     let temperature = nodes.length / 1.5;
//     const coolingRate = 0.999;
//     const iterations = 5000;

//     for (let iteration = 0; iteration < iterations; iteration++) {
//         const newPath = getRandomNeighbor(currentPath);
//         const currentLength = getPathLength(currentPath);
//         const newLength = getPathLength(newPath);
//         const delta = newLength - currentLength;
//         if (delta < 0 || Math.exp(-delta / temperature) > Math.random()) {
//             currentPath = newPath.slice();
//             if (newLength < getPathLength(bestPath)) {
//             bestPath = newPath.slice();
//             }
//         }
//         temperature *= coolingRate;
//     }
//     return {
//         bestPath: bestPath,
//         totalDistance: getPathLength(bestPath),
//     };
// }


// export function simulatedAnnealing(xValues, yValues, initialTemperature = 10000, coolingRate = 0.999, numIterations = 5000) {
//     const numCities = xValues.length;

//     // Function to calculate the Euclidean distance between two cities
//     function distance(city1, city2) {
//         return Math.sqrt((xValues[city1] - xValues[city2]) ** 2 + (yValues[city1] - yValues[city2]) ** 2);
//     }

//     // Function to calculate the total distance for a given tour
//     function totalDistance(tour) {
//         return tour.reduce((acc, city, i) => acc + distance(city, tour[i + 1] || tour[0]), 0);
//     }

//     // Generate an initial random tour
//     let currentTour = Array.from({ length: numCities }, (_, i) => i);
//     for (let i = numCities - 1; i > 0; i--) {
//         const j = Math.floor(Math.random() * (i + 1));
//         [currentTour[i], currentTour[j]] = [currentTour[j], currentTour[i]];
//     }

//     // Calculate the initial total distance
//     let currentDistance = totalDistance(currentTour);

//     // Store the best tour and distance found so far
//     let bestTour = currentTour.slice();
//     let bestDistance = currentDistance;

//     // Simulated Annealing
//     let temperature = initialTemperature;
//     for (let iteration = 0; iteration < numIterations; iteration++) {
//         // Generate a neighboring tour by swapping two random cities
//         const neighborTour = currentTour.slice();
//         const [i, j] = [Math.floor(Math.random() * numCities), Math.floor(Math.random() * numCities)];
//         [neighborTour[i], neighborTour[j]] = [neighborTour[j], neighborTour[i]];

//         // Calculate the distance of the neighboring tour
//         const neighborDistance = totalDistance(neighborTour);

//         // Decide whether to accept the neighboring tour
//         if (neighborDistance < currentDistance || Math.random() < Math.exp((currentDistance - neighborDistance) / temperature)) {
//             currentTour = neighborTour;
//             currentDistance = neighborDistance;

//             // Update the best tour and distance if needed
//             if (currentDistance < bestDistance) {
//                 bestTour = currentTour.slice();
//                 bestDistance = currentDistance;
//             }
//         }

//         // Cool down the temperature
//         temperature *= coolingRate;
//     }

//     return { bestTour, bestDistance };
// }

export function simulatedAnnealing(xValues, yValues, initialTemperature = 10000, coolingRate = 0.999, numIterations = 5000) {
    const numCities = xValues.length;

    // Function to calculate the Euclidean distance between two cities
    function distance(city1, city2) {
        return Math.sqrt((xValues[city1] - xValues[city2]) ** 2 + (yValues[city1] - yValues[city2]) ** 2);
    }

    // Function to calculate the total distance for a given tour
    function totalDistance(tour) {
        return tour.reduce((acc, city, i) => acc + distance(city, tour[i + 1] || tour[0]), 0);
    }

    let currentTour = [0, ...Array.from({ length: numCities - 1 }, (_, i) => i + 1)];
    for (let i = numCities - 1; i > 1; i--) {
        const j = Math.floor(Math.random() * (i - 1)) + 1; // Ensuring that j is between 1 and i (inclusive)
        [currentTour[i], currentTour[j]] = [currentTour[j], currentTour[i]];
    }


    // Calculate the initial total distance
    let currentDistance = totalDistance(currentTour);

    // Store the best tour and distance found so far
    let bestTour = currentTour.slice();
    let bestDistance = currentDistance;

    // Simulated Annealing
    let temperature = initialTemperature;
for (let iteration = 0; iteration < numIterations; iteration++) {
    // Generate a neighboring tour by copying the current tour
    const neighborTour = currentTour.slice();

    // Randomly select two distinct indices for swapping (excluding the first node)
    const [i, j] = [Math.floor(Math.random() * (numCities - 1)) + 1, Math.floor(Math.random() * (numCities - 1)) + 1];
    [neighborTour[i], neighborTour[j]] = [neighborTour[j], neighborTour[i]];

    // Calculate the distance of the neighboring tour
    const neighborDistance = totalDistance(neighborTour);

    // Decide whether to accept the neighboring tour
    if (neighborDistance < currentDistance || Math.random() < Math.exp((currentDistance - neighborDistance) / temperature)) {
        currentTour = neighborTour;
        currentDistance = neighborDistance;

        // Update the best tour and distance if needed
        if (currentDistance < bestDistance) {
            bestTour = currentTour.slice();
            bestDistance = currentDistance;
        }
    }

    // Cool down the temperature
    temperature *= coolingRate;
}


    return { bestTour, bestDistance };
}
