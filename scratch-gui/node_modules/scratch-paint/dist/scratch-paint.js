module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 92);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("prop-types");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Paper.js v0.12.7 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jürg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Tue Jul 28 15:52:11 2020 -0400
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jürg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = function(self, undefined) {

self = self || __webpack_require__(94);
var window = self.window ? self.window : self,
	document = self.document;

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,
		array = [],
		slice = array.slice,
		create = Object.create,
		describe = Object.getOwnPropertyDescriptor,
		define = Object.defineProperty,

		forEach = array.forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++) {
				iter.call(bind, this[i], i, this);
			}
		},

		forIn = function(iter, bind) {
			for (var i in this) {
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
			}
		},

		set = Object.assign || function(dst) {
			for (var i = 1, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				for (var key in src) {
					if (src.hasOwnProperty(key))
						dst[key] = src[key];
				}
			}
			return dst;
		},

		each = function(obj, iter, bind) {
			if (obj) {
				var desc = describe(obj, 'length');
				(desc && typeof desc.value === 'number' ? forEach : forIn)
					.call(obj, iter, bind = bind || obj);
			}
			return bind;
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc && !val.base
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res)) {
					res = { value: res, writable: true };
				}
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable != null ? enumerable : !bean;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function Base() {
		for (var i = 0, l = arguments.length; i < l; i++) {
			var src = arguments[i];
			if (src)
				set(this, src);
		}
		return this;
	}

	return inject(Base, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, null, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor,
				proto;
			for (var i = 0, obj, l = arguments.length;
					i < l && !(ctor && proto); i++) {
				obj = arguments[i];
				ctor = ctor || obj.initialize;
				proto = proto || obj.prototype;
			}
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			proto = ctor.prototype = proto || create(this.prototype);
			define(proto, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this);
			if (arguments.length)
				this.inject.apply(ctor, arguments);
			ctor.base = base;
			return ctor;
		}
	}).inject({
		enumerable: false,

		initialize: Base,

		set: Base,

		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src) {
					inject(this, src, src.enumerable, src.beans, src.preserve);
				}
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			set: set,
			each: each,
			create: create,
			define: define,
			describe: describe,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function(a, b) {
				return a !== undefined ? a : b;
			},

			slice: function(list, begin, end) {
				return slice.call(list, begin, end);
			}
		}
	});
};

if (true)
	module.exports = Base;

Base.inject({
	enumerable: false,

	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	getClassName: function() {
		return this._class || '';
	},

	importJSON: function(json) {
		return Base.importJSON(json, this);
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	set: function(props, exclude) {
		if (props)
			Base.filter(this, props, exclude, this._prioritize);
		return this;
	}
}, {

beans: false,
statics: {
	exports: {},

	extend: function extend() {
		var res = extend.base.apply(this, arguments),
			name = res.prototype._class;
		if (name && !Base.exports[name])
			Base.exports[name] = res;
		return res;
	},

	equals: function(obj1, obj2) {
		if (obj1 === obj2)
			return true;
		if (obj1 && obj1.equals)
			return obj1.equals(obj2);
		if (obj2 && obj2.equals)
			return obj2.equals(obj1);
		if (obj1 && obj2
				&& typeof obj1 === 'object' && typeof obj2 === 'object') {
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				var length = obj1.length;
				if (length !== obj2.length)
					return false;
				while (length--) {
					if (!Base.equals(obj1[length], obj2[length]))
						return false;
				}
			} else {
				var keys = Object.keys(obj1),
					length = keys.length;
				if (length !== Object.keys(obj2).length)
					return false;
				while (length--) {
					var key = keys[length];
					if (!(obj2.hasOwnProperty(key)
							&& Base.equals(obj1[key], obj2[key])))
						return false;
				}
			}
			return true;
		}
		return false;
	},

	read: function(list, start, options, amount) {
		if (this === Base) {
			var value = this.peek(list, start);
			list.__index++;
			return value;
		}
		var proto = this.prototype,
			readIndex = proto._readIndex,
			begin = start || readIndex && list.__index || 0,
			length = list.length,
			obj = list[begin];
		amount = amount || length - begin;
		if (obj instanceof this
			|| options && options.readNull && obj == null && amount <= 1) {
			if (readIndex)
				list.__index = begin + 1;
			return obj && options && options.clone ? obj.clone() : obj;
		}
		obj = Base.create(proto);
		if (readIndex)
			obj.__read = true;
		obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length
				? Base.slice(list, begin, begin + amount)
				: list) || obj;
		if (readIndex) {
			list.__index = begin + obj.__read;
			var filtered = obj.__filtered;
			if (filtered) {
				list.__filtered = filtered;
				obj.__filtered = undefined;
			}
			obj.__read = undefined;
		}
		return obj;
	},

	peek: function(list, start) {
		return list[list.__index = start || list.__index || 0];
	},

	remain: function(list) {
		return list.length - (list.__index || 0);
	},

	readList: function(list, start, options, amount) {
		var res = [],
			entry,
			begin = start || 0,
			end = amount ? begin + amount : list.length;
		for (var i = begin; i < end; i++) {
			res.push(Array.isArray(entry = list[i])
					? this.read(entry, 0, options)
					: this.read(list, i, options, 1));
		}
		return res;
	},

	readNamed: function(list, name, start, options, amount) {
		var value = this.getNamed(list, name),
			hasValue = value !== undefined;
		if (hasValue) {
			var filtered = list.__filtered;
			if (!filtered) {
				var source = this.getSource(list);
				filtered = list.__filtered = Base.create(source);
				filtered.__unfiltered = source;
			}
			filtered[name] = undefined;
		}
		return this.read(hasValue ? [value] : list, start, options, amount);
	},

	readSupported: function(list, dest) {
		var source = this.getSource(list),
			that = this,
			read = false;
		if (source) {
			Object.keys(source).forEach(function(key) {
				if (key in dest) {
					var value = that.readNamed(list, key);
					if (value !== undefined) {
						dest[key] = value;
					}
					read = true;
				}
			});
		}
		return read;
	},

	getSource: function(list) {
		var source = list.__source;
		if (source === undefined) {
			var arg = list.length === 1 && list[0];
			source = list.__source = arg && Base.isPlainObject(arg)
				? arg : null;
		}
		return source;
	},

	getNamed: function(list, name) {
		var source = this.getSource(list);
		if (source) {
			return name ? source[name] : list.__filtered || source;
		}
	},

	hasNamed: function(list, name) {
		return !!this.getNamed(list, name);
	},

	filter: function(dest, source, exclude, prioritize) {
		var processed;

		function handleKey(key) {
			if (!(exclude && key in exclude) &&
				!(processed && key in processed)) {
				var value = source[key];
				if (value !== undefined)
					dest[key] = value;
			}
		}

		if (prioritize) {
			var keys = {};
			for (var i = 0, key, l = prioritize.length; i < l; i++) {
				if ((key = prioritize[i]) in source) {
					handleKey(key);
					keys[key] = true;
				}
			}
			processed = keys;
		}

		Object.keys(source.__unfiltered || source).forEach(handleKey);
		return dest;
	},

	isPlainValue: function(obj, asString) {
		return Base.isPlainObject(obj) || Array.isArray(obj)
				|| asString && typeof obj === 'string';
	},

	serialize: function(obj, options, compact, dictionary) {
		options = options || {};

		var isRoot = !dictionary,
			res;
		if (isRoot) {
			options.formatter = new Formatter(options.precision);
			dictionary = {
				length: 0,
				definitions: {},
				references: {},
				add: function(item, create) {
					var id = '#' + item._id,
						ref = this.references[id];
					if (!ref) {
						this.length++;
						var res = create.call(item),
							name = item._class;
						if (name && res[0] !== name)
							res.unshift(name);
						this.definitions[id] = res;
						ref = this.references[id] = [id];
					}
					return ref;
				}
			};
		}
		if (obj && obj._serialize) {
			res = obj._serialize(options, dictionary);
			var name = obj._class;
			if (name && !obj._compactSerialize && (isRoot || !compact)
					&& res[0] !== name) {
				res.unshift(name);
			}
		} else if (Array.isArray(obj)) {
			res = [];
			for (var i = 0, l = obj.length; i < l; i++)
				res[i] = Base.serialize(obj[i], options, compact, dictionary);
		} else if (Base.isPlainObject(obj)) {
			res = {};
			var keys = Object.keys(obj);
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				res[key] = Base.serialize(obj[key], options, compact,
						dictionary);
			}
		} else if (typeof obj === 'number') {
			res = options.formatter.number(obj, options.precision);
		} else {
			res = obj;
		}
		return isRoot && dictionary.length > 0
				? [['dictionary', dictionary.definitions], res]
				: res;
	},

	deserialize: function(json, create, _data, _setDictionary, _isRoot) {
		var res = json,
			isFirst = !_data,
			hasDictionary = isFirst && json && json.length
				&& json[0][0] === 'dictionary';
		_data = _data || {};
		if (Array.isArray(json)) {
			var type = json[0],
				isDictionary = type === 'dictionary';
			if (json.length == 1 && /^#/.test(type)) {
				return _data.dictionary[type];
			}
			type = Base.exports[type];
			res = [];
			for (var i = type ? 1 : 0, l = json.length; i < l; i++) {
				res.push(Base.deserialize(json[i], create, _data,
						isDictionary, hasDictionary));
			}
			if (type) {
				var args = res;
				if (create) {
					res = create(type, args, isFirst || _isRoot);
				} else {
					res = new type(args);
				}
			}
		} else if (Base.isPlainObject(json)) {
			res = {};
			if (_setDictionary)
				_data.dictionary = res;
			for (var key in json)
				res[key] = Base.deserialize(json[key], create, _data);
		}
		return hasDictionary ? res[1] : res;
	},

	exportJSON: function(obj, options) {
		var json = Base.serialize(obj, options);
		return options && options.asString == false
				? json
				: JSON.stringify(json);
	},

	importJSON: function(json, target) {
		return Base.deserialize(
				typeof json === 'string' ? JSON.parse(json) : json,
				function(ctor, args, isRoot) {
					var useTarget = isRoot && target
							&& target.constructor === ctor,
						obj = useTarget ? target
							: Base.create(ctor.prototype);
					if (args.length === 1 && obj instanceof Item
							&& (useTarget || !(obj instanceof Layer))) {
						var arg = args[0];
						if (Base.isPlainObject(arg)) {
							arg.insert = false;
							if (useTarget) {
								args = args.concat([{ insert: true }]);
							}
						}
					}
					(useTarget ? obj.set : ctor).apply(obj, args);
					if (useTarget)
						target = null;
					return obj;
				});
	},

	push: function(list, items) {
		var itemsLength = items.length;
		if (itemsLength < 4096) {
			list.push.apply(list, items);
		} else {
			var startLength = list.length;
			list.length += itemsLength;
			for (var i = 0; i < itemsLength; i++) {
				list[startLength + i] = items[i];
			}
		}
		return list;
	},

	splice: function(list, items, index, remove) {
		var amount = items && items.length,
			append = index === undefined;
		index = append ? list.length : index;
		if (index > list.length)
			index = list.length;
		for (var i = 0; i < amount; i++)
			items[i]._index = index + i;
		if (append) {
			Base.push(list, items);
			return [];
		} else {
			var args = [index, remove];
			if (items)
				Base.push(args, items);
			var removed = list.splice.apply(list, args);
			for (var i = 0, l = removed.length; i < l; i++)
				removed[i]._index = undefined;
			for (var i = index + amount, l = list.length; i < l; i++)
				list[i]._index = i;
			return removed;
		}
	},

	capitalize: function(str) {
		return str.replace(/\b[a-z]/g, function(match) {
			return match.toUpperCase();
		});
	},

	camelize: function(str) {
		return str.replace(/-(.)/g, function(match, chr) {
			return chr.toUpperCase();
		});
	},

	hyphenate: function(str) {
		return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	}
}});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var types = this._eventTypes,
				entry = types && types[type],
				handlers = this._callbacks = this._callbacks || {};
			handlers = handlers[type] = handlers[type] || [];
			if (handlers.indexOf(func) === -1) {
				handlers.push(func);
				if (entry && entry.install && handlers.length === 1)
					entry.install.call(this, type);
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var types = this._eventTypes,
			entry = types && types[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry && entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function handler() {
			func.apply(this, arguments);
			this.off(type, handler);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = Base.slice(arguments, 1),
			setTarget = event && event.target && !event.currentTarget;
		handlers = handlers.slice();
		if (setTarget)
			event.currentTarget = this;
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) == false) {
				if (event && event.stop)
					event.stop();
				break;
		   }
		}
		if (setTarget)
			delete event.currentTarget;
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var types = this._eventTypes,
			handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		if (types) {
			for (var type in handlers) {
				if (handlers[type].length > 0) {
					var entry = types[type],
						func = entry && entry[key];
					if (func)
						func.call(this, type);
				}
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			insertItems: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1) || {};
			proto.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}
		if (!this.agent) {
			var user = self.navigator.userAgent.toLowerCase(),
				os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],
				platform = os === 'darwin' ? 'mac' : os,
				agent = proto.agent = proto.browser = { platform: platform };
			if (platform)
				agent[platform] = true;
			user.replace(
				/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g,
				function(match, n, v1, v2, rv) {
					if (!agent.chrome) {
						var v = n === 'opera' ? v2 :
								/^(node|trident)$/.test(n) ? rv : v1;
						agent.version = v;
						agent.versionNumber = parseFloat(v);
						n = { trident: 'msie', jsdom: 'node' }[n] || n;
						agent.name = n;
						agent[n] = true;
					}
				}
			);
			if (agent.chrome)
				delete agent.webkit;
			if (agent.atom)
				delete agent.chrome;
		}
	},

	version: "0.12.7",

	getView: function() {
		var project = this.project;
		return project && project._view;
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, options) {
			var exports = paper.PaperScript.execute(code, this, options);
			View.updateFocus();
			return exports;
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	createCanvas: function(width, height) {
		return CanvasProvider.getCanvas(width, height);
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		var projects = this.projects,
			tools = this.tools;
		for (var i = projects.length - 1; i >= 0; i--)
			projects[i].remove();
		for (var i = tools.length - 1; i >= 0; i--)
			tools[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	},

	getView: function() {
		return this._scope.getView();
	}
});

var CollisionDetection = {
	findItemBoundsCollisions: function(items1, items2, tolerance) {
		function getBounds(items) {
			var bounds = new Array(items.length);
			for (var i = 0; i < items.length; i++) {
				var rect = items[i].getBounds();
				bounds[i] = [rect.left, rect.top, rect.right, rect.bottom];
			}
			return bounds;
		}

		var bounds1 = getBounds(items1),
			bounds2 = !items2 || items2 === items1
				? bounds1
				: getBounds(items2);
		return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
	},

	findCurveBoundsCollisions: function(curves1, curves2, tolerance, bothAxis) {
		function getBounds(curves) {
			var min = Math.min,
				max = Math.max,
				bounds = new Array(curves.length);
			for (var i = 0; i < curves.length; i++) {
				var v = curves[i];
				bounds[i] = [
					min(v[0], v[2], v[4], v[6]),
					min(v[1], v[3], v[5], v[7]),
					max(v[0], v[2], v[4], v[6]),
					max(v[1], v[3], v[5], v[7])
				];
			}
			return bounds;
		}

		var bounds1 = getBounds(curves1),
			bounds2 = !curves2 || curves2 === curves1
				? bounds1
				: getBounds(curves2);
		if (bothAxis) {
			var hor = this.findBoundsCollisions(
					bounds1, bounds2, tolerance || 0, false, true),
				ver = this.findBoundsCollisions(
					bounds1, bounds2, tolerance || 0, true, true),
				list = [];
			for (var i = 0, l = hor.length; i < l; i++) {
				list[i] = { hor: hor[i], ver: ver[i] };
			}
			return list;
		}
		return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
	},

	findBoundsCollisions: function(boundsA, boundsB, tolerance,
		sweepVertical, onlySweepAxisCollisions) {
		var self = !boundsB || boundsA === boundsB,
			allBounds = self ? boundsA : boundsA.concat(boundsB),
			lengthA = boundsA.length,
			lengthAll = allBounds.length;

		function binarySearch(indices, coord, value) {
			var lo = 0,
				hi = indices.length;
			while (lo < hi) {
				var mid = (hi + lo) >>> 1;
				if (allBounds[indices[mid]][coord] < value) {
					lo = mid + 1;
				} else {
					hi = mid;
				}
			}
			return lo - 1;
		}

		var pri0 = sweepVertical ? 1 : 0,
			pri1 = pri0 + 2,
			sec0 = sweepVertical ? 0 : 1,
			sec1 = sec0 + 2;
		var allIndicesByPri0 = new Array(lengthAll);
		for (var i = 0; i < lengthAll; i++) {
			allIndicesByPri0[i] = i;
		}
		allIndicesByPri0.sort(function(i1, i2) {
			return allBounds[i1][pri0] - allBounds[i2][pri0];
		});
		var activeIndicesByPri1 = [],
			allCollisions = new Array(lengthA);
		for (var i = 0; i < lengthAll; i++) {
			var curIndex = allIndicesByPri0[i],
				curBounds = allBounds[curIndex],
				origIndex = self ? curIndex : curIndex - lengthA,
				isCurrentA = curIndex < lengthA,
				isCurrentB = self || !isCurrentA,
				curCollisions = isCurrentA ? [] : null;
			if (activeIndicesByPri1.length) {
				var pruneCount = binarySearch(activeIndicesByPri1, pri1,
						curBounds[pri0] - tolerance) + 1;
				activeIndicesByPri1.splice(0, pruneCount);
				if (self && onlySweepAxisCollisions) {
					curCollisions = curCollisions.concat(activeIndicesByPri1);
					for (var j = 0; j < activeIndicesByPri1.length; j++) {
						var activeIndex = activeIndicesByPri1[j];
						allCollisions[activeIndex].push(origIndex);
					}
				} else {
					var curSec1 = curBounds[sec1],
						curSec0 = curBounds[sec0];
					for (var j = 0; j < activeIndicesByPri1.length; j++) {
						var activeIndex = activeIndicesByPri1[j],
							activeBounds = allBounds[activeIndex],
							isActiveA = activeIndex < lengthA,
							isActiveB = self || activeIndex >= lengthA;

						if (
							onlySweepAxisCollisions ||
							(
								isCurrentA && isActiveB ||
								isCurrentB && isActiveA
							) && (
								curSec1 >= activeBounds[sec0] - tolerance &&
								curSec0 <= activeBounds[sec1] + tolerance
							)
						) {
							if (isCurrentA && isActiveB) {
								curCollisions.push(
									self ? activeIndex : activeIndex - lengthA);
							}
							if (isCurrentB && isActiveA) {
								allCollisions[activeIndex].push(origIndex);
							}
						}
					}
				}
			}
			if (isCurrentA) {
				if (boundsA === boundsB) {
					curCollisions.push(curIndex);
				}
				allCollisions[curIndex] = curCollisions;
			}
			if (activeIndicesByPri1.length) {
				var curPri1 = curBounds[pri1],
					index = binarySearch(activeIndicesByPri1, pri1, curPri1);
				activeIndicesByPri1.splice(index + 1, 0, curIndex);
			} else {
				activeIndicesByPri1.push(curIndex);
			}
		}
		for (var i = 0; i < allCollisions.length; i++) {
			var collisions = allCollisions[i];
			if (collisions) {
				collisions.sort(function(i1, i2) { return i1 - i2; });
			}
		}
		return allCollisions;
	}
};

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = Base.pick(precision, 5);
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return this.precision < 16
				? Math.round(val * this.multiplier) / this.multiplier : val;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		log2 = Math.log2 || function(x) {
			return Math.log(x) * Math.LOG2E;
		},
		EPSILON = 1e-12,
		MACHINE_EPSILON = 1.12e-16;

	function clamp(value, min, max) {
		return value < min ? min : value > max ? max : value;
	}

	function getDiscriminant(a, b, c) {
		function split(v) {
			var x = v * 134217729,
				y = v - x,
				hi = y + x,
				lo = v - hi;
			return [hi, lo];
		}

		var D = b * b - a * c,
			E = b * b + a * c;
		if (abs(D) * 3 < E) {
			var ad = split(a),
				bd = split(b),
				cd = split(c),
				p = b * b,
				dp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],
				q = a * c,
				dq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])
						+ ad[1] * cd[1];
			D = (p - q) + (dp - dq);
		}
		return D;
	}

	function getNormalizationFactor() {
		var norm = Math.max.apply(Math, arguments);
		return norm && (norm < 1e-8 || norm > 1e8)
				? pow(2, -Math.round(log2(norm)))
				: 0;
	}

	return {
		EPSILON: EPSILON,
		MACHINE_EPSILON: MACHINE_EPSILON,
		CURVETIME_EPSILON: 1e-8,
		GEOMETRIC_EPSILON: 1e-7,
		TRIGONOMETRIC_EPSILON: 1e-8,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return val >= -EPSILON && val <= EPSILON;
		},

		isMachineZero: function(val) {
			return val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;
		},

		clamp: clamp,

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance) {
					x = nx;
					break;
				}
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return clamp(x, a, b);
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var x1, x2 = Infinity;
			if (abs(a) < EPSILON) {
				if (abs(b) < EPSILON)
					return abs(c) < EPSILON ? -1 : 0;
				x1 = -c / b;
			} else {
				b *= -0.5;
				var D = getDiscriminant(a, b, c);
				if (D && abs(D) < MACHINE_EPSILON) {
					var f = getNormalizationFactor(abs(a), abs(b), abs(c));
					if (f) {
						a *= f;
						b *= f;
						c *= f;
						D = getDiscriminant(a, b, c);
					}
				}
				if (D >= -MACHINE_EPSILON) {
					var Q = D < 0 ? 0 : sqrt(D),
						R = b + (b < 0 ? -Q : Q);
					if (R === 0) {
						x1 = c / a;
						x2 = -x1;
					} else {
						x1 = R / a;
						x2 = c / R;
					}
				}
			}
			var count = 0,
				boundless = min == null,
				minB = min - EPSILON,
				maxB = max + EPSILON;
			if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))
				roots[count++] = boundless ? x1 : clamp(x1, min, max);
			if (x2 !== x1
					&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))
				roots[count++] = boundless ? x2 : clamp(x2, min, max);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),
				x, b1, c2, qd, q;
			if (f) {
				a *= f;
				b *= f;
				c *= f;
				d *= f;
			}

			function evaluate(x0) {
				x = x0;
				var tmp = a * x;
				b1 = tmp + b;
				c2 = b1 * x + c;
				qd = (tmp + b1) * x + c2;
				q = c2 * x + d;
			}

			if (abs(a) < EPSILON) {
				a = b;
				b1 = c;
				c2 = d;
				x = Infinity;
			} else if (abs(d) < EPSILON) {
				b1 = b;
				c2 = c;
				x = 0;
			} else {
				evaluate(-(b / a) / 3);
				var t = q / a,
					r = pow(abs(t), 1/3),
					s = t < 0 ? -1 : 1,
					td = -qd / a,
					rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,
					x0 = x - s * rd;
				if (x0 !== x) {
					do {
						evaluate(x0);
						x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);
					} while (s * x0 > s * x);
					if (abs(a) * x * x > abs(d / x)) {
						c2 = -d / x;
						b1 = (c2 - c) / x;
					}
				}
			}
			var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),
				boundless = min == null;
			if (isFinite(x) && (count === 0
					|| count > 0 && x !== roots[0] && x !== roots[1])
					&& (boundless || x > min - EPSILON && x < max + EPSILON))
				roots[count++] = boundless ? x : clamp(x, min, max);
			return count;
		}
	};
};

var UID = {
	_id: 1,
	_pools: {},

	get: function(name) {
		if (name) {
			var pool = this._pools[name];
			if (!pool)
				pool = this._pools[name] = { _id: 1 };
			return pool._id++;
		} else {
			return this._id++;
		}
	}
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0,
			reading = this.__read,
			read = 0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this._set(arg0, hasY ? arg1 : arg0);
			if (reading)
				read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0);
			if (reading)
				read = arg0 === null ? 1 : 0;
		} else {
			var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
			read = 1;
			if (Array.isArray(obj)) {
				this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
			} else if ('x' in obj) {
				this._set(obj.x || 0, obj.y || 0);
			} else if ('width' in obj) {
				this._set(obj.width || 0, obj.height || 0);
			} else if ('angle' in obj) {
				this._set(obj.length || 0, 0);
				this.setAngle(obj.angle || 0);
			} else {
				this._set(0, 0);
				read = 0;
			}
		}
		if (reading)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this._set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this._set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this._set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var args = arguments,
			point = Point.read(args),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(args);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			sin = Math.sin(angle),
			cos = Math.cos(angle);
		point = new Point(
			point.x * cos - point.y * sin,
			point.x * sin + point.y * cos
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function() {
		var args = arguments,
			point = Point.read(args),
			tolerance = Base.read(args);
		return this.getDistance(point) <= tolerance;
	},

	isCollinear: function() {
		var point = Point.read(arguments);
		return Point.isCollinear(this.x, this.y, point.x, point.y);
	},

	isColinear: '#isCollinear',

	isOrthogonal: function() {
		var point = Point.read(arguments);
		return Point.isOrthogonal(this.x, this.y, point.x, point.y);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this.x) && isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	isInQuadrant: function(q) {
		return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0
			&& this.y * (q > 2 ? -1 : 1) >= 0;
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments),
			scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
		return new Point(
			point.x * scale,
			point.y * scale
		);
	},

	statics: {
		min: function() {
			var args = arguments,
				point1 = Point.read(args),
				point2 = Point.read(args);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var args = arguments,
				point1 = Point.read(args),
				point2 = Point.read(args);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		},

		isCollinear: function(x1, y1, x2, y2) {
			return Math.abs(x1 * y2 - y1 * x2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-8;
		},

		isOrthogonal: function(x1, y1, x2, y2) {
			return Math.abs(x1 * x2 + y1 * y2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-8;
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
	var op = Math[key];
	this[key] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	},

	isSelected: function() {
		return !!(this._owner._selection & this._getSelection());
	},

	setSelected: function(selected) {
		this._owner._changeSelection(this._getSelection(), selected);
	},

	_getSelection: function() {
		return this._setter === 'setPosition' ? 4 : 0;
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0,
			reading = this.__read,
			read = 0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this._set(arg0, hasHeight ? arg1 : arg0);
			if (reading)
				read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0);
			if (reading)
				read = arg0 === null ? 1 : 0;
		} else {
			var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
			read = 1;
			if (Array.isArray(obj)) {
				this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
			} else if ('width' in obj) {
				this._set(obj.width || 0, obj.height || 0);
			} else if ('x' in obj) {
				this._set(obj.x || 0, obj.y || 0);
			} else {
				this._set(0, 0);
				read = 0;
			}
		}
		if (reading)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this.width) && isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
	var op = Math[key];
	this[key] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var args = arguments,
			type = typeof arg0,
			read;
		if (type === 'number') {
			this._set(arg0, arg1, arg2, arg3);
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0, 0, 0);
			read = arg0 === null ? 1 : 0;
		} else if (args.length === 1) {
			if (Array.isArray(arg0)) {
				this._set.apply(this, arg0);
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this._set(arg0.x || 0, arg0.y || 0,
						arg0.width || 0, arg0.height || 0);
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this._set(0, 0, 0, 0);
				if (Base.readSupported(args, this)) {
					read = 1;
				}
			}
		}
		if (read === undefined) {
			var frm = Point.readNamed(args, 'from'),
				next = Base.peek(args),
				x = frm.x,
				y = frm.y,
				width,
				height;
			if (next && next.x !== undefined || Base.hasNamed(args, 'to')) {
				var to = Point.readNamed(args, 'to');
				width = to.x - x;
				height = to.y - y;
				if (width < 0) {
					x = to.x;
					width = -width;
				}
				if (height < 0) {
					y = to.y;
					height = -height;
				}
			} else {
				var size = Size.read(args);
				width = size.width;
				height = size.height;
			}
			this._set(x, y, width, height);
			read = args.__index;
		}
		var filtered = args.__filtered;
		if (filtered)
			this.__filtered = filtered;
		if (this.__read)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	_fw: 1,
	_fh: 1,

	setSize: function() {
		var size = Size.read(arguments),
			sx = this._sx,
			sy = this._sy,
			w = size.width,
			h = size.height;
		if (sx) {
			this.x += (this.width - w) * sx;
		}
		if (sy) {
			this.y += (this.height - h) * sy;
		}
		this.width = w;
		this.height = h;
		this._fw = this._fh = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fw) {
			var amount = left - this.x;
			this.width -= this._sx === 0.5 ? amount * 2 : amount;
		}
		this.x = left;
		this._sx = this._fw = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fh) {
			var amount = top - this.y;
			this.height -= this._sy === 0.5 ? amount * 2 : amount;
		}
		this.y = top;
		this._sy = this._fh = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (!this._fw) {
			var amount = right - this.x;
			this.width = this._sx === 0.5 ? amount * 2 : amount;
		}
		this.x = right - this.width;
		this._sx = 1;
		this._fw = 0;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (!this._fh) {
			var amount = bottom - this.y;
			this.height = this._sy === 0.5 ? amount * 2 : amount;
		}
		this.y = bottom - this.height;
		this._sy = 1;
		this._fh = 0;
	},

	getCenterX: function() {
		return this.x + this.width / 2;
	},

	setCenterX: function(x) {
		if (this._fw || this._sx === 0.5) {
			this.x = x - this.width / 2;
		} else {
			if (this._sx) {
				this.x += (x - this.x) * 2 * this._sx;
			}
			this.width = (x - this.x) * 2;
		}
		this._sx = 0.5;
		this._fw = 0;
	},

	getCenterY: function() {
		return this.y + this.height / 2;
	},

	setCenterY: function(y) {
		if (this._fh || this._sy === 0.5) {
			this.y = y - this.height / 2;
		} else {
			if (this._sy) {
				this.y += (y - this.y) * 2 * this._sy;
			}
			this.height = (y - this.y) * 2;
		}
		this._sy = 0.5;
		this._fh = 0;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length === 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments),
			epsilon = Base.read(arguments) || 0;
		return rect.x + rect.width > this.x - epsilon
				&& rect.y + rect.height > this.y - epsilon
				&& rect.x < this.x + this.width + epsilon
				&& rect.y < this.y + this.height + epsilon;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join(''),
			xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this._set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
},
new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key),
			internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return !!(this._owner._selection & 2);
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner._changeSelection) {
					owner._changeSelection(2, selected);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg, _dontNotify) {
		var args = arguments,
			count = args.length,
			ok = true;
		if (count >= 6) {
			this._set.apply(this, args);
		} else if (count === 1 || count === 2) {
			if (arg instanceof Matrix) {
				this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,
						_dontNotify);
			} else if (Array.isArray(arg)) {
				this._set.apply(this,
						_dontNotify ? arg.concat([_dontNotify]) : arg);
			} else {
				ok = false;
			}
		} else if (!count) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok) {
			throw new Error('Unsupported matrix parameters');
		}
		return this;
	},

	set: '#initialize',

	_set: function(a, b, c, d, tx, ty, _dontNotify) {
		this._a = a;
		this._b = b;
		this._c = c;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.getValues(), options, true, dictionary);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(25);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._b, this._c, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._c),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._b), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._b = this._c = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function(recursively, _setApplyMatrix) {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, Base.pick(recursively, true), _setApplyMatrix);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._c;
		this._ty += x * this._b + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var args = arguments,
			scale = Point.read(args),
			center = Point.read(args, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._b *= scale.x;
		this._c *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * c;
		this._b = cos * b + sin * d;
		this._c = -sin * a + cos * c;
		this._d = -sin * b + cos * d;
		this._tx += tx * a + ty * c;
		this._ty += tx * b + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var args = arguments,
			shear = Point.read(args),
			center = Point.read(args, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			b = this._b;
		this._a += shear.y * this._c;
		this._b += shear.y * this._d;
		this._c += shear.x * a;
		this._d += shear.x * b;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var args = arguments,
			skew = Point.read(args),
			center = Point.read(args, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	append: function(mx, _dontNotify) {
		if (mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				a2 = mx._a,
				b2 = mx._c,
				c2 = mx._b,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + c2 * c1;
			this._c = b2 * a1 + d2 * c1;
			this._b = a2 * b1 + c2 * d1;
			this._d = b2 * b1 + d2 * d1;
			this._tx += tx2 * a1 + ty2 * c1;
			this._ty += tx2 * b1 + ty2 * d1;
			if (!_dontNotify)
				this._changed();
		}
		return this;
	},

	prepend: function(mx, _dontNotify) {
		if (mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				tx1 = this._tx,
				ty1 = this._ty,
				a2 = mx._a,
				b2 = mx._c,
				c2 = mx._b,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + b2 * b1;
			this._c = a2 * c1 + b2 * d1;
			this._b = c2 * a1 + d2 * b1;
			this._d = c2 * c1 + d2 * d1;
			this._tx = a2 * tx1 + b2 * ty1 + tx2;
			this._ty = c2 * tx1 + d2 * ty1 + ty2;
			if (!_dontNotify)
				this._changed();
		}
		return this;
	},

	appended: function(mx) {
		return this.clone().append(mx);
	},

	prepended: function(mx) {
		return this.clone().prepend(mx);
	},

	invert: function() {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty,
			det = a * d - b * c,
			res = null;
		if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
			this._a = d / det;
			this._b = -b / det;
			this._c = -c / det;
			this._d = a / det;
			this._tx = (c * ty - d * tx) / det;
			this._ty = (b * tx - a * ty) / det;
			res = this;
		}
		return res;
	},

	inverted: function() {
		return this.clone().invert();
	},

	concatenate: '#append',
	preConcatenate: '#prepend',
	chain: '#appended',

	_shiftless: function() {
		return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
	},

	_orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isIdentity: function() {
		return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	isInvertible: function() {
		var det = this._a * this._d - this._c * this._b;
		return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
	},

	isSingular: function() {
		return !this.isInvertible();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest._set(
				x * this._a + y * this._c + this._tx,
				x * this._b + y * this._d + this._ty,
				_dontNotify);
	},

	_transformCoordinates: function(src, dst, count) {
		for (var i = 0, max = 2 * count; i < max; i += 2) {
			var x = src[i],
				y = src[i + 1];
			dst[i] = x * this._a + y * this._c + this._tx;
			dst[i + 1] = x * this._b + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = min.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j]) {
				min[j] = val;
			} else if (val > max[j]) {
				max[j] = val;
			}
		}
		if (!dest)
			dest = new Rectangle();
		return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty,
			det = a * d - b * c,
			res = null;
		if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
			var x = point.x - this._tx,
				y = point.y - this._ty;
			if (!dest)
				dest = new Point();
			res = dest._set(
					(x * d - y * c) / det,
					(y * a - x * b) / det,
					_dontNotify);
		}
		return res;
	},

	decompose: function() {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			det = a * d - b * c,
			sqrt = Math.sqrt,
			atan2 = Math.atan2,
			degrees = 180 / Math.PI,
			rotate,
			scale,
			skew;
		if (a !== 0 || b !== 0) {
			var r = sqrt(a * a + b * b);
			rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);
			scale = [r, det / r];
			skew = [atan2(a * c + b * d, r * r), 0];
		} else if (c !== 0 || d !== 0) {
			var s = sqrt(c * c + d * d);
			rotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);
			scale = [det / s, s];
			skew = [0, atan2(a * c + b * d, s * s)];
		} else {
			rotate = 0;
			skew = scale = [0, 0];
		}
		return {
			translation: this.getTranslation(),
			rotation: rotate * degrees,
			scaling: new Point(scale),
			skewing: new Point(skew[0] * degrees, skew[1] * degrees)
		};
	},

	getValues: function() {
		return [ this._a, this._b, this._c, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return this.decompose().scaling;
	},

	getRotation: function() {
		return this.decompose().rotation;
	},

	applyToContext: function(ctx) {
		if (!this.isIdentity()) {
			ctx.transform(this._a, this._b, this._c, this._d,
					this._tx, this._ty);
		}
	}
}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {
	var part = Base.capitalize(key),
		prop = '_' + key;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point, isInfinite) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true, isInfinite);
	},

	getDistance: function(point) {
		return Math.abs(this.getSignedDistance(point));
	},

	getSignedDistance: function(point) {
		return Line.getSignedDistance(this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	isCollinear: function(line) {
		return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
	},

	isOrthogonal: function(line) {
		return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
	},

	statics: {
		intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,
				isInfinite) {
			if (!asVector) {
				v1x -= p1x;
				v1y -= p1y;
				v2x -= p2x;
				v2y -= p2y;
			}
			var cross = v1x * v2y - v1y * v2x;
			if (!Numerical.isMachineZero(cross)) {
				var dx = p1x - p2x,
					dy = p1y - p2y,
					u1 = (v2x * dy - v2y * dx) / cross,
					u2 = (v1x * dy - v1y * dx) / cross,
					epsilon = 1e-12,
					uMin = -epsilon,
					uMax = 1 + epsilon;
				if (isInfinite
						|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
					if (!isInfinite) {
						u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
					}
					return new Point(
							p1x + u1 * v1x,
							p1y + u1 * v1y);
				}
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (!isInfinite && Numerical.isMachineZero(ccw)) {
				ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
				if (ccw >= 0 && ccw <= 1)
					ccw = 0;
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			  return  vx === 0 ? (vy > 0 ? x - px : px - x)
					: vy === 0 ? (vx < 0 ? y - py : py - y)
					: ((x - px) * vy - (y - py) * vx) / (
						vy > vx
							? vy * Math.sqrt(1 + (vx * vx) / (vy * vy))
							: vx * Math.sqrt(1 + (vy * vy) / (vx * vx))
					);
		},

		getDistance: function(px, py, vx, vy, x, y, asVector) {
			return Math.abs(
					Line.getSignedDistance(px, py, vx, vy, x, y, asVector));
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',
	_compactSerialize: true,

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this._children = [];
		this._namedChildren = {};
		this._activeLayer = null;
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectionItems = {};
		this._selectionCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this._children, options, true, dictionary);
	},

	_changed: function(flags, item) {
		if (flags & 1) {
			var view = this._view;
			if (view) {
				view._needsUpdate = true;
				if (!view._requested && view._autoUpdate)
					view.requestUpdate();
			}
		}
		var changes = this._changes;
		if (changes && item) {
			var changesById = this._changesById,
				id = item._id,
				entry = changesById[id];
			if (entry) {
				entry.flags |= flags;
			} else {
				changes.push(changesById[id] = { item: item, flags: flags });
			}
		}
	},

	clear: function() {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--)
			children[i].remove();
	},

	isEmpty: function() {
		return !this._children.length;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.set(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getLayers: function() {
		return this._children;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this, insert: true });
	},

	getSymbolDefinitions: function() {
		var definitions = [],
			ids = {};
		this.getItems({
			class: SymbolItem,
			match: function(item) {
				var definition = item._definition,
					id = definition._id;
				if (!ids[id]) {
					ids[id] = true;
					definitions.push(definition);
				}
				return false;
			}
		});
		return definitions;
	},

	getSymbols: 'getSymbolDefinitions',

	getSelectedItems: function() {
		var selectionItems = this._selectionItems,
			items = [];
		for (var id in selectionItems) {
			var item = selectionItems[id],
				selection = item._selection;
			if ((selection & 1) && item.isInserted()) {
				items.push(item);
			} else if (!selection) {
				this._updateSelection(item);
			}
		}
		return items;
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectionItems = this._selectionItems;
		if (item._selection) {
			if (selectionItems[id] !== item) {
				this._selectionCount++;
				selectionItems[id] = item;
			}
		} else if (selectionItems[id] === item) {
			this._selectionCount--;
			delete selectionItems[id];
		}
	},

	selectAll: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectionItems = this._selectionItems;
		for (var i in selectionItems)
			selectionItems[i].setFullySelected(false);
	},

	addLayer: function(layer) {
		return this.insertLayer(undefined, layer);
	},

	insertLayer: function(index, layer) {
		if (layer instanceof Layer) {
			layer._remove(false, true);
			Base.splice(this._children, [layer], index, 0);
			layer._setProject(this, true);
			var name = layer._name;
			if (name)
				layer.setName(name);
			if (this._changes)
				layer._changed(5);
			if (!this._activeLayer)
				this._activeLayer = layer;
		} else {
			layer = null;
		}
		return layer;
	},

	_insertItem: function(index, item, _created) {
		item = this.insertLayer(index, item)
				|| (this._activeLayer || this._insertItem(undefined,
						new Layer(Item.NO_INSERT), true))
						.insertChild(index, item);
		if (_created && item.activate)
			item.activate();
		return item;
	},

	getItems: function(options) {
		return Item._getItems(this, options);
	},

	getItem: function(options) {
		return Item._getItems(this, options, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	removeOn: function(type) {
		var sets = this._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var children = this._children,
			param = new Base({
				offset: new Point(0, 0),
				pixelRatio: pixelRatio,
				viewMatrix: matrix.isIdentity() ? null : matrix,
				matrices: [new Matrix()],
				updateMatrix: true
			});
		for (var i = 0, l = children.length; i < l; i++) {
			children[i].draw(ctx, param);
		}
		ctx.restore();

		if (this._selectionCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectionItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items) {
				items[id]._drawSelection(ctx, matrix, size, items, version);
			}
			ctx.restore();
		}
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = Base.set({},
					this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_name: null,
	_applyMatrix: true,
	_canApplyMatrix: true,
	_canScaleStroke: false,
	_pivot: null,
	_visible: true,
	_blendMode: 'normal',
	_opacity: 1,
	_locked: false,
	_guide: false,
	_clipMask: false,
	_selection: 0,
	_selectBounds: true,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		locked: false,
		guide: false,
		clipMask: false,
		selected: false,
		data: {}
	},
	_prioritize: ['applyMatrix']
},
new function() {
	var handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];
	return Base.each(handlers,
		function(name) {
			this._events[name] = {
				install: function(type) {
					this.getView()._countItemEvent(type, 1);
				},

				uninstall: function(type) {
					this.getView()._countItemEvent(type, -1);
				}
			};
		}, {
			_events: {
				onFrame: {
					install: function() {
						this.getView()._animateItem(this, true);
					},

					uninstall: function() {
						this.getView()._animateItem(this, false);
					}
				},

				onLoad: {},
				onError: {}
			},
			statics: {
				_itemHandlers: handlers
			}
		}
	);
}, {
	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project,
			settings = paper.settings;
		this._id = internal ? null : UID.get();
		this._parent = this._index = null;
		this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (internal || hasProps && props.insert == false
			|| !settings.insertItems && !(hasProps && props.insert === true)) {
			this._setProject(project);
		} else {
			(hasProps && props.parent || project)
					._insertItem(undefined, this, true);
		}
		if (hasProps && props !== Item.NO_INSERT) {
			this.set(props, {
				internal: true, insert: true, project: true, parent: true
			});
		}
		return hasProps;
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._symbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed = undefined;
		}
		if (flags & 16) {
			this._globalMatrix = undefined;
		}
		if (cacheParent
				&& (flags & 72)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project)
			project._changed(flags, this);
		if (symbol)
			symbol._changed(flags);
	},

	getId: function() {
		return this._id;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var owner = this._getOwner();
		if (name && owner) {
			var children = owner._children,
				namedChildren = owner._namedChildren;
			(namedChildren[name] = namedChildren[name] || []).push(this);
			if (!(name in children))
				children[name] = this;
		}
		this._name = name || undefined;
		this._changed(256);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			key = '_' + name,
			flags = {
				locked: 256,
				visible: 265
			};
		this['get' + part] = function() {
			return this[key];
		};
		this['set' + part] = function(value) {
			if (value != this[key]) {
				this[key] = value;
				this._changed(flags[name] || 257);
			}
		};
	},
{}), {
	beans: true,

	getSelection: function() {
		return this._selection;
	},

	setSelection: function(selection) {
		if (selection !== this._selection) {
			this._selection = selection;
			var project = this._project;
			if (project) {
				project._updateSelection(this);
				this._changed(257);
			}
		}
	},

	_changeSelection: function(flag, selected) {
		var selection = this._selection;
		this.setSelection(selected ? selection | flag : selection & ~flag);
	},

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return !!(this._selection & 1);
	},

	setSelected: function(selected) {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		this._changeSelection(1, selected);
	},

	isFullySelected: function() {
		var children = this._children,
			selected = !!(this._selection & 1);
		if (children && selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this._changeSelection(1, selected);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(257);
			if (this._parent)
				this._parent._changed(2048);
		}
	},

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		var position = this._position ||
			(this._position = this._getPositionFromBounds());
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	_getPositionFromBounds: function(bounds) {
		return this._pivot
				? this._matrix._transformPoint(this._pivot)
				: (bounds || this.getBounds()).getCenter(true);
	},

	getPivot: function() {
		var pivot = this._pivot;
		return pivot
				? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')
				: null;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
		this._position = undefined;
	}
}, Base.each({
		getStrokeBounds: { stroke: true },
		getHandleBounds: { handle: true },
		getInternalBounds: { internal: true },
		getDrawnBounds: { stroke: true, drawnTextBounds: true },
	},
	function(options, key) {
		this[key] = function(matrix) {
			return this.getBounds(matrix, options);
		};
	},
{
	beans: true,

	getBounds: function(matrix, options) {
		var hasMatrix = options || matrix instanceof Matrix,
			opts = Base.set({}, hasMatrix ? options : matrix,
					this._boundsOptions);
		if (!opts.stroke || this.getStrokeScaling())
			opts.cacheItem = this;
		var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;
		return !arguments.length
				? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,
					this, 'setBounds')
				: rect;
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			_matrix = this._matrix,
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			if (!_matrix.isInvertible()) {
				_matrix.set(_matrix._backup
						|| new Matrix().translate(_matrix.getTranslation()));
				bounds = this.getBounds();
			}
			matrix.scale(
					bounds.width !== 0 ? rect.width / bounds.width : 0,
					bounds.height !== 0 ? rect.height / bounds.height : 0);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getBounds: function(matrix, options) {
		var children = this._children;
		if (!children || !children.length)
			return new Rectangle();
		Item._updateBoundsCache(this, options.cacheItem);
		return Item._getBounds(children, matrix, options);
	},

	_getBoundsCacheKey: function(options, internal) {
		return [
			options.stroke ? 1 : 0,
			options.handle ? 1 : 0,
			options.drawnTextBounds? 1 : 0,
			internal ? 1 : 0
		].join('');
	},

	_getCachedBounds: function(matrix, options, noInternal) {
		matrix = matrix && matrix._orNullIfIdentity();
		var internal = options.internal && !noInternal,
			cacheItem = options.cacheItem,
			_matrix = internal ? null : this._matrix._orNullIfIdentity(),
			cacheKey = cacheItem && (!matrix || matrix.equals(_matrix))
				&& this._getBoundsCacheKey(options, internal),
			bounds = this._bounds;
		Item._updateBoundsCache(this._parent || this._symbol, cacheItem);
		if (cacheKey && bounds && cacheKey in bounds) {
			var cached = bounds[cacheKey];
			return {
				rect: cached.rect.clone(),
				nonscaling: cached.nonscaling
			};
		}
		var res = this._getBounds(matrix || _matrix, options),
			rect = res.rect || res,
			style = this._style,
			nonscaling = res.nonscaling || style.hasStroke()
				&& !style.getStrokeScaling();
		if (cacheKey) {
			if (!bounds) {
				this._bounds = bounds = {};
			}
			var cached = bounds[cacheKey] = {
				rect: rect.clone(),
				nonscaling: nonscaling,
				internal: internal
			};
		}
		return {
			rect: rect,
			nonscaling: nonscaling
		};
	},

	_getStrokeMatrix: function(matrix, options) {
		var parent = this.getStrokeScaling() ? null
				: options && options.internal ? this
					: this._parent || this._symbol && this._symbol._item,
			mx = parent ? parent.getViewMatrix().invert() : matrix;
		return mx && mx._shiftless();
	},

	statics: {
		_updateBoundsCache: function(parent, item) {
			if (parent && item) {
				var id = item._id,
					ref = parent._boundsCache = parent._boundsCache || {
						ids: {},
						list: []
					};
				if (!ref.ids[id]) {
					ref.list.push(item);
					ref.ids[id] = item;
				}
			}
		},

		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++){
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		},

		_getBounds: function(items, matrix, options) {
			var x1 = Infinity,
				x2 = -x1,
				y1 = x1,
				y2 = x2,
				nonscaling = false;
			options = options || {};
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				if (item._visible && !item.isEmpty(true)) {
					var bounds = item._getCachedBounds(
						matrix && matrix.appended(item._matrix), options, true),
						rect = bounds.rect;
					x1 = Math.min(rect.x, x1);
					y1 = Math.min(rect.y, y1);
					x2 = Math.max(rect.x + rect.width, x2);
					y2 = Math.max(rect.y + rect.height, y2);
					if (bounds.nonscaling)
						nonscaling = true;
				}
			}
			return {
				rect: isFinite(x1)
					? new Rectangle(x1, y1, x2 - x1, y2 - y1)
					: new Rectangle(),
				nonscaling: nonscaling
			};
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._applyMatrix
			? null
			: this._decomposed || (this._decomposed = this._matrix.decompose());
	},

	getRotation: function() {
		var decomposed = this._decompose();
		return decomposed ? decomposed.rotation : 0;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			if (decomposed) {
				decomposed.rotation = rotation;
				this._decomposed = decomposed;
			}
		}
	},

	getScaling: function() {
		var decomposed = this._decompose(),
			s = decomposed && decomposed.scaling;
		return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling(),
			scaling = Point.read(arguments, 0, { clone: true, readNull: true });
		if (current && scaling && !current.equals(scaling)) {
			var rotation = this.getRotation(),
				decomposed = this._decomposed,
				matrix = new Matrix(),
				center = this.getPosition(true);
			matrix.translate(center);
			if (rotation)
				matrix.rotate(rotation);
			matrix.scale(scaling.x / current.x, scaling.y / current.y);
			if (rotation)
				matrix.rotate(-rotation);
			matrix.translate(center.negate());
			this.transform(matrix);
			if (decomposed) {
				decomposed.scaling = scaling;
				this._decomposed = decomposed;
			}
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.initialize.apply(matrix, arguments);
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix;
		if (matrix) {
			var parent = this._parent;
			var parents = [];
			while (parent) {
				if (!parent._globalMatrix) {
					matrix = null;
					for (var i = 0, l = parents.length; i < l; i++) {
						parents[i]._globalMatrix = null;
					}
					break;
				}
				parents.push(parent);
				parent = parent._parent;
			}
		}
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.prepend(parent.getGlobalMatrix(true));
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getViewMatrix: function() {
		return this.getGlobalMatrix().prepend(this.getView()._matrix);
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(apply) {
		if (this._applyMatrix = this._canApplyMatrix && !!apply)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project._view;
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	_getOwner: '#getParent',

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		var owner = this._getOwner();
		return owner && owner._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		var owner = this._getOwner();
		return owner && owner._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(options) {
		var copy = new this.constructor(Item.NO_INSERT),
			children = this._children,
			insert = Base.pick(options ? options.insert : undefined,
					options === undefined || options === true),
			deep = Base.pick(options ? options.deep : undefined, true);
		if (children)
			copy.copyAttributes(this);
		if (!children || deep)
			copy.copyContent(this);
		if (!children)
			copy.copyAttributes(this);
		if (insert)
			copy.insertAbove(this);
		var name = this._name,
			parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				orig = name,
				i = 1;
			while (children[name])
				name = orig + ' ' + (i++);
			if (name !== orig)
				copy.setName(name);
		}
		return copy;
	},

	copyContent: function(source) {
		var children = source._children;
		for (var i = 0, l = children && children.length; i < l; i++) {
			this.addChild(children[i].clone(false), true);
		}
	},

	copyAttributes: function(source, excludeMatrix) {
		this.setStyle(source._style);
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide'];
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (source.hasOwnProperty(key))
				this[key] = source[key];
		}
		if (!excludeMatrix)
			this._matrix.set(source._matrix, true);
		this.setApplyMatrix(source._applyMatrix);
		this.setPivot(source._pivot);
		this.setSelection(source._selection);
		var data = source._data,
			name = source._name;
		this._data = data ? Base.clone(data) : null;
		if (name)
			this.setName(name);
	},

	rasterize: function(resolution, insert, boundRect) {
		var bounds = boundRect ? boundRect : this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			raster = new Raster(Item.NO_INSERT);
		if (!size.isZero()) {
			var canvas = CanvasProvider.getCanvas(size.multiply(scale)),
				ctx = canvas.getContext('2d'),
				matrix = new Matrix().scale(scale).translate(topLeft.negate());
			ctx.imageSmoothingEnabled = false;
			ctx.save();
			matrix.applyToContext(ctx);
			this.draw(ctx, new Base({ matrices: [matrix] }));
			ctx.restore();
			raster.setCanvas(canvas);
		}
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		if (insert === undefined || insert)
			raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		var matrix = this._matrix;
		return (
			matrix.isInvertible() &&
			!!this._contains(matrix._inverseTransform(Point.read(arguments)))
		);
	},

	_contains: function(point) {
		var children = this._children;
		if (children) {
			for (var i = children.length - 1; i >= 0; i--) {
				if (children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(), null,
				_matrix, true).length > 0;
	}
},
new function() {
	function hitTest() {
		var args = arguments;
		return this._hitTest(
				Point.read(args),
				HitResult.getOptions(args));
	}

	function hitTestAll() {
		var args = arguments,
			point = Point.read(args),
			options = HitResult.getOptions(args),
			all = [];
		this._hitTest(point, new Base({ all: all }, options));
		return all;
	}

	function hitTestChildren(point, options, viewMatrix, _exclude) {
		var children = this._children;
		if (children) {
			for (var i = children.length - 1; i >= 0; i--) {
				var child = children[i];
				var res = child !== _exclude && child._hitTest(point, options,
						viewMatrix);
				if (res && !options.all)
					return res;
			}
		}
		return null;
	}

	Project.inject({
		hitTest: hitTest,
		hitTestAll: hitTestAll,
		_hitTest: hitTestChildren
	});

	return {
		hitTest: hitTest,
		hitTestAll: hitTestAll,
		_hitTestChildren: hitTestChildren,
	};
}, {

	_hitTest: function(point, options, parentViewMatrix) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty()) {
			return null;
		}

		var matrix = this._matrix,
			viewMatrix = parentViewMatrix
					? parentViewMatrix.appended(matrix)
					: this.getGlobalMatrix().prepend(this.getView()._matrix),
			tolerance = Math.max(options.tolerance, 1e-12),
			tolerancePadding = options._tolerancePadding = new Size(
					Path._getStrokePadding(tolerance,
						matrix._shiftless().invert()));
		point = matrix._inverseTransform(point);
		if (!point || !this._children &&
			!this.getBounds({ internal: true, stroke: true, handle: true })
				.expand(tolerancePadding.multiply(2))._containsPoint(point)) {
			return null;
		}

		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this.isSelected()
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			match = options.match,
			that = this,
			bounds,
			res;

		function filter(hit) {
			if (hit && match && !match(hit))
				hit = null;
			if (hit && options.all)
				options.all.push(hit);
			return hit;
		}

		function checkPoint(type, part) {
			var pt = part ? bounds['get' + part]() : that.getPosition();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1) {
				return new HitResult(type, that, {
					name: part ? Base.hyphenate(part) : type,
					point: pt
				});
			}
		}

		var checkPosition = options.position,
			checkCenter = options.center,
			checkBounds = options.bounds;
		if (checkSelf && this._parent
				&& (checkPosition || checkCenter || checkBounds)) {
			if (checkCenter || checkBounds) {
				bounds = this.getInternalBounds();
			}
			res = checkPosition && checkPoint('position') ||
					checkCenter && checkPoint('center', 'Center');
			if (!res && checkBounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++) {
					res = checkPoint('bounds', points[i]);
				}
			}
			res = filter(res);
		}

		if (!res) {
			res = this._hitTestChildren(point, options, viewMatrix)
				|| checkSelf
					&& filter(this._hitTestSelf(point, options, viewMatrix,
						this.getStrokeScaling() ? null
							: viewMatrix._shiftless().invert()))
				|| null;
		}
		if (res && res.point) {
			res.point = matrix.transform(res.point);
		}
		return res;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		var type = typeof name;
		if (type === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
			return true;
		} else if (type === 'function') {
			return name(this);
		} else if (name === 'match') {
			return compare(this);
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (name === 'class') {
				if (typeof compare === 'function')
					return this instanceof compare;
				value = this._class;
			}
			if (typeof compare === 'function') {
				return !!compare(value);
			} else if (compare) {
				if (compare.test) {
					return compare.test(value);
				} else if (Base.isPlainObject(compare)) {
					return matchObject(compare, value);
				}
			}
			return Base.equals(value, compare);
		}
	},

	getItems: function(options) {
		return Item._getItems(this, options, this._matrix);
	},

	getItem: function(options) {
		return Item._getItems(this, options, this._matrix, null, true)[0]
				|| null;
	},

	statics: {
		_getItems: function _getItems(item, options, matrix, param, firstOnly) {
			if (!param) {
				var obj = typeof options === 'object' && options,
					overlapping = obj && obj.overlapping,
					inside = obj && obj.inside,
					bounds = overlapping || inside,
					rect = bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					recursive: obj && obj.recursive !== false,
					inside: !!inside,
					overlapping: !!overlapping,
					rect: rect,
					path: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (obj) {
					options = Base.filter({}, options, {
						recursive: true, inside: true, overlapping: true
					});
				}
			}
			var children = item._children,
				items = param.items,
				rect = param.rect;
			matrix = rect && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.appended(child._matrix),
					add = true;
				if (rect) {
					var bounds = child.getBounds(childMatrix);
					if (!rect.intersects(bounds))
						continue;
					if (!(rect.contains(bounds)
							|| param.overlapping && (bounds.contains(rect)
								|| param.path.intersects(child, childMatrix))))
						add = false;
				}
				if (add && child.matches(options)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				if (param.recursive !== false) {
					_getItems(child, options, childMatrix, param, firstOnly);
				}
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this ? this.addChild(res) : res;
	},

	addChild: function(item) {
		return this.insertChild(undefined, item);
	},

	insertChild: function(index, item) {
		var res = item ? this.insertChildren(index, [item]) : null;
		return res && res[0];
	},

	addChildren: function(items) {
		return this.insertChildren(this._children.length, items);
	},

	insertChildren: function(index, items) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Base.slice(items);
			var inserted = {};
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i],
					id = item && item._id;
				if (!item || inserted[id]) {
					items.splice(i, 1);
				} else {
					item._remove(false, true);
					inserted[id] = true;
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i],
					name = item._name;
				item._parent = this;
				item._setProject(project, true);
				if (name)
					item.setName(name);
				if (notifySelf)
					item._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insertItem: '#insertChild',

	_insertAt: function(item, offset) {
		var owner = item && item._getOwner(),
			res = item !== this && owner ? this : null;
		if (res) {
			res._remove(false, true);
			owner._insertItem(item._index + offset, res);
		}
		return res;
	},

	insertAbove: function(item) {
		return this._insertAt(item, 1);
	},

	insertBelow: function(item) {
		return this._insertAt(item, 0);
	},

	sendToBack: function() {
		var owner = this._getOwner();
		return owner ? owner._insertItem(0, this) : null;
	},

	bringToFront: function() {
		var owner = this._getOwner();
		return owner ? owner._insertItem(undefined, this) : null;
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	addTo: function(owner) {
		return owner._insertItem(undefined, this);
	},

	copyTo: function(owner) {
		return this.clone(false).addTo(owner);
	},

	reduce: function(options) {
		var children = this._children;
		if (children && children.length === 1) {
			var child = children[0].reduce(options);
			if (this._parent) {
				child.insertAbove(this);
				this.remove();
			} else {
				child.remove();
			}
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var owner = this._getOwner();
		if (owner) {
			var children = owner._children,
				namedChildren = owner._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[0];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var owner = this._getOwner(),
			project = this._project,
			index = this._index;
		if (this._style)
			this._style._dispose();
		if (owner) {
			if (this._name)
				this._removeNamed();
			if (index != null) {
				if (project._activeLayer === this)
					project._activeLayer = this.getNextSibling()
							|| this.getPreviousSibling();
				Base.splice(owner._children, null, index, 1);
			}
			this._installEvents(false);
			if (notifySelf && project._changes)
				this._changed(5);
			if (notifyParent)
				owner._changed(11, this);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(start, end) {
		if (!this._children)
			return null;
		start = start || 0;
		end = Base.pick(end, this._children.length);
		var removed = Base.splice(this._children, null, start, end - start);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function(recursively) {
		var children = this._children;
		var numChildren = children ? children.length : 0;
		if (recursively) {
			for (var i = 0; i < numChildren; i++) {
				if (!children[i].isEmpty(recursively)) {
					return false;
				}
			}
			return true;
		}
		return !numChildren;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent === item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isSibling: function(item) {
		return this._parent === item._parent;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
	var rotate = key === 'rotate';
	this[key] = function() {
		var args = arguments,
			value = (rotate ? Base : Point).read(args),
			center = Point.read(args, 0, { readNull: true });
		return this.transform(new Matrix()[key](value,
				center || this.getPosition(true)));
	};
}, {
	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	transform: function(matrix, _applyRecursively, _setApplyMatrix) {
		var _matrix = this._matrix,
			transformMatrix = matrix && !matrix.isIdentity(),
			applyMatrix = (
				_setApplyMatrix && this._canApplyMatrix ||
				this._applyMatrix && (
					transformMatrix || !_matrix.isIdentity() ||
					_applyRecursively && this._children
				)
			);
		if (!transformMatrix && !applyMatrix)
			return this;
		if (transformMatrix) {
			if (!matrix.isInvertible() && _matrix.isInvertible())
				_matrix._backup = _matrix.getValues();
			_matrix.prepend(matrix, true);
			var style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (fillColor)
				fillColor.transform(matrix);
			if (strokeColor)
				strokeColor.transform(matrix);
		}

		if (applyMatrix && (applyMatrix = this._transformContent(
				_matrix, _applyRecursively, _setApplyMatrix))) {
			var pivot = this._pivot;
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			_matrix.reset(true);
			if (_setApplyMatrix && this._canApplyMatrix)
				this._applyMatrix = true;
		}
		var bounds = this._bounds,
			position = this._position;
		if (transformMatrix || applyMatrix) {
			this._changed(25);
		}
		var decomp = transformMatrix && bounds && matrix.decompose();
		if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var cache = bounds[key];
				if (cache.nonscaling) {
					delete bounds[key];
				} else if (applyMatrix || !cache.internal) {
					var rect = cache.rect;
					matrix._transformBounds(rect, rect);
				}
			}
			this._bounds = bounds;
			var cached = bounds[this._getBoundsCacheKey(
				this._boundsOptions || {})];
			if (cached) {
				this._position = this._getPositionFromBounds(cached.rect);
			}
		} else if (transformMatrix && position && this._pivot) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++) {
				children[i].transform(matrix, applyRecursively, setApplyMatrix);
			}
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	}
}), {

	_setStyles: function(ctx, param, viewMatrix, strokeMatrix) {
		var style = this._style,
			matrix = this._matrix;
		if (style.hasFill()) {
			ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix, strokeMatrix);
		}
		if (style.hasStroke()) {
			ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix, strokeMatrix);
			ctx.lineWidth = style.getStrokeWidth();
			var strokeJoin = style.getStrokeJoin(),
				strokeCap = style.getStrokeCap(),
				miterLimit = style.getMiterLimit();
			if (strokeJoin)
				ctx.lineJoin = strokeJoin;
			if (strokeCap)
				ctx.lineCap = strokeCap;
			if (miterLimit)
				ctx.miterLimit = miterLimit;
			if (paper.support.nativeDash) {
				var dashArray = style.getDashArray(),
					dashOffset = style.getDashOffset();
				if (dashArray && dashArray.length) {
					if ('setLineDash' in ctx) {
						ctx.setLineDash(dashArray);
						ctx.lineDashOffset = dashOffset;
					} else {
						ctx.mozDash = dashArray;
						ctx.mozDashOffset = dashOffset;
					}
				}
			}
		}
		if (style.hasShadow()) {
			var pixelRatio = param.pixelRatio || 1,
				mx = viewMatrix._shiftless().prepend(
					new Matrix().scale(pixelRatio, pixelRatio)),
				blur = mx.transform(new Point(style.getShadowBlur(), 0)),
				offset = mx.transform(this.getShadowOffset());
			ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
			ctx.shadowBlur = blur.getLength();
			ctx.shadowOffsetX = offset.x;
			ctx.shadowOffsetY = offset.y;
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].appended(matrix);
		if (!globalMatrix.isInvertible())
			return;

		viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)
				: globalMatrix;

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = Numerical.clamp(this._opacity, 0, 1),
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio || 1,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(viewMatrix);
			if (!bounds.width || !bounds.height) {
				matrices.pop();
				return;
			}
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.appended(matrix)
				: this._canScaleStroke && !this.getStrokeScaling(true)
					&& viewMatrix,
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform) {
			(direct ? matrix : viewMatrix).applyToContext(ctx);
		}
		if (clip) {
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, viewMatrix, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish) {
			ctx.clip(this.getFillRule());
		}
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {
		var selection = this._selection,
			itemSelected = selection & 1,
			boundsSelected = selection & 2
					|| itemSelected && this._selectBounds,
			positionSelected = selection & 4;
		if (!this._drawSelected)
			itemSelected = false;
		if ((itemSelected || boundsSelected || positionSelected)
				&& this._isUpdated(updateVersion)) {
			var layer,
				color = this.getSelectedColor(true) || (layer = this.getLayer())
					&& layer.getSelectedColor(true),
				mx = matrix.appended(this.getGlobalMatrix(true)),
				half = size / 2;
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			ctx.lineWidth=2.5;
			if (itemSelected)
				this._drawSelected(ctx, mx, selectionItems);
			if (positionSelected) {
				var pos = this.getPosition(true),
					parent = this._parent,
					point = parent ? parent.localToGlobal(pos) : pos,
					x = point.x,
					y = point.y;
				ctx.beginPath();
				ctx.arc(x, y, half, 0, Math.PI * 2, true);
				ctx.stroke();
				var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],
					start = half,
					end = size + 1;
				for (var i = 0; i < 4; i++) {
					var delta = deltas[i],
						dx = delta[0],
						dy = delta[1];
					ctx.moveTo(x + dx * start, y + dy * start);
					ctx.lineTo(x + dx * end, y + dy * end);
					ctx.stroke();
				}
			}
			if (boundsSelected) {
				var coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++) {
					ctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				}
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++) {
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
				}
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(key) {
	this['removeOn' + Base.capitalize(key)] = function() {
		var hash = {};
		hash[key] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}), {
	tween: function(from, to, options) {
		if (!options) {
			options = to;
			to = from;
			from = null;
			if (!options) {
				options = to;
				to = null;
			}
		}
		var easing = options && options.easing,
			start = options && options.start,
			duration = options != null && (
				typeof options === 'number' ? options : options.duration
			),
			tween = new Tween(this, from, to, duration, easing, start);
		function onFrame(event) {
			tween._handleFrame(event.time * 1000);
			if (!tween.running) {
				this.off('frame', onFrame);
			}
		}
		if (duration) {
			this.on('frame', onFrame);
		}
		return tween;
	},

	tweenTo: function(to, options) {
		return this.tween(null, to, options);
	},

	tweenFrom: function(from, options) {
		return this.tween(from, null, options);
	}
});

var Group = Item.extend({
	_class: 'Group',
	_selectBounds: false,
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 2050) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++) {
				if (children[i]._clipMask) {
					clipItem = children[i];
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_getBounds: function _getBounds(matrix, options) {
		var clipItem = this._getClipItem();
		return clipItem
			? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix),
				Base.set({}, options, { stroke: false }))
			: _getBounds.base.call(this, matrix, options);
	},

	_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
		var clipItem = this._getClipItem();
		return (!clipItem || clipItem.contains(point))
				&& _hitTestChildren.base.call(this, point, options, viewMatrix,
					clipItem);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem();
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			ctx.beginPath();
			param.dontStart = param.dontFinish = true;
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var item = children[i];
			if (item !== clipItem)
				item.draw(ctx, param);
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer() {
		Group.apply(this, arguments);
	},

	_getOwner: function() {
		return this._parent || this._index != null && this._project;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_hitTestSelf: function() {
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_canScaleStroke: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props, point) {
		this._initialize(props, point);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	copyContent: function(source) {
		this.setType(source._type);
		this.setSize(source._size);
		this.setRadius(source._radius);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				this._radius.set(Size.min(this._radius, size.divide(2).abs()));
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius._set(width / 2, height / 2);
			}
			this._size._set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size._set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size);
				} else if (type === 'ellipse') {
					this._size._set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		});
		path.copyAttributes(this);
		if (paper.settings.applyMatrix)
			path.setApplyMatrix(true);
		if (insert === undefined || insert)
			path.insertAbove(this);
		return path;
	},

	toShape: '#clone',

	_asPathItem: function() {
		return this.toPath(false);
	},

	_draw: function(ctx, param, viewMatrix, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx, param, viewMatrix, strokeMatrix);
			if (hasFill) {
				ctx.fill(style.getFillRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(matrix, options) {
		var rect = new Rectangle(this._size).setCenter(0, 0),
			style = this._style,
			strokeWidth = options.stroke && style.hasStroke()
					&& style.getStrokeWidth();
		if (matrix)
			rect = matrix._transformBounds(rect);
		return strokeWidth
				? rect.expand(Path._getStrokePadding(strokeWidth,
					this._getStrokeMatrix(matrix, options)))
				: rect;
	}
},
new function() {
	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var q = 1; q <= 4; q++) {
				var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(
							expand ? corner.add(dir.multiply(expand)) : corner,
							center);
				if (rect.contains(point))
					return { point: center, quadrant: q };
			}
		}
	}

	function isOnEllipseStroke(point, radius, padding, quadrant) {
		var vector = point.divide(radius);
		return (!quadrant || vector.isInQuadrant(quadrant)) &&
				vector.subtract(vector.normalize()).multiply(radius)
					.divide(padding).length <= 1;
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center.point).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,
				strokeMatrix) {
			var hit = false,
				style = this._style,
				hitStroke = options.stroke && style.hasStroke(),
				hitFill = options.fill && style.hasFill();
			if (hitStroke || hitFill) {
				var type = this._type,
					radius = this._radius,
					strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,
					strokePadding = options._tolerancePadding.add(
						Path._getStrokePadding(strokeRadius,
							!style.getStrokeScaling() && strokeMatrix));
				if (type === 'rectangle') {
					var padding = strokePadding.multiply(2),
						center = getCornerCenter(this, point, padding);
					if (center) {
						hit = isOnEllipseStroke(point.subtract(center.point),
								radius, strokePadding, center.quadrant);
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(padding),
							inner = rect.expand(padding.negate());
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					hit = isOnEllipseStroke(point, radius, strokePadding);
				}
			}
			return hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = Base.create(Shape.prototype);
		item._type = type;
		item._size = size;
		item._radius = radius;
		item._initialize(Base.getNamed(args), point);
		return item;
	}

	return {
		Circle: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				radius = Base.readNamed(args, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					args);
		},

		Rectangle: function() {
			var args = arguments,
				rect = Rectangle.readNamed(args, 'rectangle'),
				radius = Size.min(Size.readNamed(args, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, args);
		},

		Ellipse: function() {
			var args = arguments,
				ellipse = Shape._readEllipse(args),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, args);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsOptions: { stroke: false, handle: false },
	_serializeFields: {
		crossOrigin: null,
		source: null
	},
	_prioritize: ['crossOrigin'],
	_smoothing: false,
	beans: true,

	initialize: function Raster(source, position) {
		if (!this._initialize(source,
				position !== undefined && Point.read(arguments))) {
			var image,
				type = typeof source,
				object = type === 'string'
					? document.getElementById(source)
					: type  === 'object'
						? source
						: null;
			if (object && object !== Item.NO_INSERT) {
				if (object.getContext || object.naturalHeight != null) {
					image = object;
				} else if (object) {
					var size = Size.read(arguments);
					if (!size.isZero()) {
						image = CanvasProvider.getCanvas(size);
					}
				}
			}
			if (image) {
				this.setImage(image);
			} else {
				this.setSource(source);
			}
		}
		if (!this._size) {
			this._size = new Size();
			this._loaded = false;
		}
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	copyContent: function(source) {
		var image = source._image,
			canvas = source._canvas;
		if (image) {
			this._setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(source._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			this._setImage(copyCanvas);
		}
		this._crossOrigin = source._crossOrigin;
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
				this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!size.equals(this._size)) {
			if (size.width > 0 && size.height > 0) {
				var element = this.getElement();
				this._setImage(CanvasProvider.getCanvas(size));
				if (element)
					this.getContext(true).drawImage(element, 0, 0,
							size.width, size.height);
			} else {
				if (this._canvas)
					CanvasProvider.release(this._canvas);
				this._size = size.clone();
			}
		}
	},

	getWidth: function() {
		return this._size ? this._size.width : 0;
	},

	setWidth: function(width) {
		this.setSize(width, this.getHeight());
	},

	getHeight: function() {
		return this._size ? this._size.height : 0;
	},

	setHeight: function(height) {
		this.setSize(this.getWidth(), height);
	},

	getLoaded: function() {
		return this._loaded;
	},

	isEmpty: function() {
		var size = this._size;
		return !size || size.width === 0 && size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		var that = this;

		function emit(event) {
			var view = that.getView(),
				type = event && event.type || 'load';
			if (view && that.responds(type)) {
				paper = view._scope;
				that.emit(type, new Event(event));
			}
		}

		this._setImage(image);
		if (this._loaded) {
			setTimeout(emit, 0);
		} else if (image) {
			DomEvent.add(image, {
				load: function(event) {
					that._setImage(image);
					emit(event);
				},
				error: emit
			});
		}
	},

	_setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
			this._loaded = true;
		} else {
			this._image = image;
			this._canvas = null;
			this._loaded = !!(image && image.src && image.complete);
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(1033);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(_change) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (_change) {
			this._image = null;
			this._changed(1025);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		var image = this._image;
		return image && image.src || this.toDataURL();
	},

	setSource: function(src) {
		var image = new self.Image(),
			crossOrigin = this._crossOrigin;
		if (crossOrigin)
			image.crossOrigin = crossOrigin;
		if (src)
			image.src = src;
		this.setImage(image);
	},

	getCrossOrigin: function() {
		var image = this._image;
		return image && image.crossOrigin || this._crossOrigin || '';
	},

	setCrossOrigin: function(crossOrigin) {
		this._crossOrigin = crossOrigin;
		var image = this._image;
		if (image)
			image.crossOrigin = crossOrigin;
	},

	getSmoothing: function() {
		return this._smoothing;
	},

	setSmoothing: function(smoothing) {
		this._smoothing = smoothing;
		this._changed(257);
	},

	getElement: function() {
		return this._canvas || this._loaded && this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		var clippedStartX = Math.max(0, rect.x);
		var clippedStartY = Math.max(0, rect.y);
		var clippedEndX = Math.min(this.getCanvas().width, rect.x + rect.width);
		var clippedEndY = Math.min(this.getCanvas().height, rect.y + rect.height);
		ctx.drawImage(this.getCanvas(),
			clippedStartX, clippedStartY,
			clippedEndX - clippedStartX, clippedEndY - clippedStartY,
			clippedStartX - rect.x, clippedStartY - rect.y,
			clippedEndX - clippedStartX, clippedEndY - clippedStartY
		);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster._setImage(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.prepend(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var image = this._image,
			src = image && image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (typeof object === 'object') {
			if ('width' in object) {
				bounds = new Rectangle(object);
			} else if ('x' in object) {
				bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
			}
		}
		if (!bounds)
			return null;
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		var element = this.getElement(),
			size = this._size;
		if (element)
			ctx.drawImage(element, -size.width / 2, -size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var args = arguments,
			point = Point.read(args),
			color = Color.read(args),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	clear: function() {
		var size = this._size;
		this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(matrix, options) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx, param, viewMatrix) {
		var element = this.getElement();
		if (element && element.width > 0 && element.height > 0) {
			ctx.globalAlpha = Numerical.clamp(this._opacity, 0, 1);

			this._setStyles(ctx, param, viewMatrix);

			DomElement.setPrefixed(
				ctx, 'imageSmoothingEnabled', this._smoothing
			);

			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var SymbolItem = Item.extend({
	_class: 'SymbolItem',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsOptions: { stroke: true },
	_serializeFields: {
		symbol: null
	},

	initialize: function SymbolItem(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setDefinition(arg0 instanceof SymbolDefinition ?
					arg0 : new SymbolDefinition(arg0));
	},

	_equals: function(item) {
		return this._definition === item._definition;
	},

	copyContent: function(source) {
		this.setDefinition(source._definition);
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(definition) {
		this._definition = definition;
		this._changed(9);
	},

	getSymbol: '#getDefinition',
	setSymbol: '#setDefinition',

	isEmpty: function() {
		return this._definition._item.isEmpty();
	},

	_getBounds: function(matrix, options) {
		var item = this._definition._item;
		return item._getCachedBounds(item._matrix.prepended(matrix), options);
	},

	_hitTestSelf: function(point, options, viewMatrix) {
		var opts = options.extend({ all: false });
		var res = this._definition._item._hitTest(point, opts, viewMatrix);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this._definition._item.draw(ctx, param);
	}

});

var SymbolDefinition = Base.extend({
	_class: 'SymbolDefinition',

	initialize: function SymbolDefinition(item, dontCenter) {
		this._id = UID.get();
		this.project = paper.project;
		if (item)
			this.setItem(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._item],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8)
			Item._clearBoundsCache(this);
		if (flags & 1)
			this.project._changed(flags);
	},

	getItem: function() {
		return this._item;
	},

	setItem: function(item, _dontCenter) {
		if (item._symbol)
			item = item.clone();
		if (this._item)
			this._item._symbol = null;
		this._item = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._symbol = this;
		this._changed(9);
	},

	getDefinition: '#getItem',
	setDefinition: '#setItem',

	place: function(position) {
		return new SymbolItem(this, position);
	},

	clone: function() {
		return new SymbolDefinition(this._item.clone(false));
	},

	equals: function(symbol) {
		return symbol === this
				|| symbol && this._item.equals(symbol._item)
				|| false;
	}
});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values)
			this.inject(values);
	},

	statics: {
		getOptions: function(args) {
			var options = args && Base.read(args);
			return new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				position: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,
	_selection: 0,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut, selection;
		if (count > 0) {
			if (arg0 == null || typeof arg0 === 'object') {
				if (count === 1 && arg0 && 'point' in arg0) {
					point = arg0.point;
					handleIn = arg0.handleIn;
					handleOut = arg0.handleOut;
					selection = arg0.selection;
				} else {
					point = arg0;
					handleIn = arg1;
					handleOut = arg2;
					selection = arg3;
				}
			} else {
				point = [ arg0, arg1 ];
				handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
				handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
			}
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
		if (selection)
			this.setSelection(selection);
	},

	_serialize: function(options, dictionary) {
		var point = this._point,
			selection = this._selection,
			obj = selection || this.hasHandles()
					? [point, this._handleIn, this._handleOut]
					: point;
		if (selection)
			obj.push(selection);
		return Base.serialize(obj, options, true, dictionary);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(41);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		this._point.set(Point.read(arguments));
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		this._handleIn.set(Point.read(arguments));
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		this._handleOut.set(Point.read(arguments));
	},

	hasHandles: function() {
		return !this._handleIn.isZero() || !this._handleOut.isZero();
	},

	isSmooth: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut;
		return !handleIn.isZero() && !handleOut.isZero()
				&& handleIn.isCollinear(handleOut);
	},

	clearHandles: function() {
		this._handleIn._set(0, 0);
		this._handleOut._set(0, 0);
	},

	getSelection: function() {
		return this._selection;
	},

	setSelection: function(selection) {
		var oldSelection = this._selection,
			path = this._path;
		this._selection = selection = selection || 0;
		if (path && selection !== oldSelection) {
			path._updateSelection(this, oldSelection, selection);
			path._changed(257);
		}
	},

	_changeSelection: function(flag, selected) {
		var selection = this._selection;
		this.setSelection(selected ? selection | flag : selection & ~flag);
	},

	isSelected: function() {
		return !!(this._selection & 7);
	},

	setSelected: function(selected) {
		this._changeSelection(7, selected);
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	smooth: function(options, _first, _last) {
		var opts = options || {},
			type = opts.type,
			factor = opts.factor,
			prev = this.getPrevious(),
			next = this.getNext(),
			p0 = (prev || this)._point,
			p1 = this._point,
			p2 = (next || this)._point,
			d1 = p0.getDistance(p1),
			d2 = p1.getDistance(p2);
		if (!type || type === 'catmull-rom') {
			var a = factor === undefined ? 0.5 : factor,
				d1_a = Math.pow(d1, a),
				d1_2a = d1_a * d1_a,
				d2_a = Math.pow(d2, a),
				d2_2a = d2_a * d2_a;
			if (!_first && prev) {
				var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,
					N = 3 * d2_a * (d2_a + d1_a);
				this.setHandleIn(N !== 0
					? new Point(
						(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,
						(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)
					: new Point());
			}
			if (!_last && next) {
				var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,
					N = 3 * d1_a * (d1_a + d2_a);
				this.setHandleOut(N !== 0
					? new Point(
						(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,
						(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)
					: new Point());
			}
		} else if (type === 'geometric') {
			if (prev && next) {
				var vector = p0.subtract(p2),
					t = factor === undefined ? 0.4 : factor,
					k = t * d1 / (d1 + d2);
				if (!_first)
					this.setHandleIn(vector.multiply(k));
				if (!_last)
					this.setHandleOut(vector.multiply(k - t));
			}
		} else {
			throw new Error('Smoothing method \'' + type + '\' not supported.');
		}
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	isFirst: function() {
		return !this._index;
	},

	isLast: function() {
		var path = this._path;
		return path && this._index === path._segments.length - 1 || false;
	},

	reverse: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut,
			tmp = handleIn.clone();
		handleIn.set(handleOut);
		handleOut.set(tmp);
	},

	reversed: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	interpolate: function(from, to, factor) {
		var u = 1 - factor,
			v = factor,
			point1 = from._point,
			point2 = to._point,
			handleIn1 = from._handleIn,
			handleIn2 = to._handleIn,
			handleOut2 = to._handleOut,
			handleOut1 = from._handleOut;
		this._point._set(
				u * point1._x + v * point2._x,
				u * point1._y + v * point2._y, true);
		this._handleIn._set(
				u * handleIn1._x + v * handleIn2._x,
				u * handleIn1._y + v * handleIn2._y, true);
		this._handleOut._set(
				u * handleOut1._x + v * handleOut2._x,
				u * handleOut1._y + v * handleOut2._y, true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y,
			selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	_set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this._x) && isZero(this._y);
	},

	isSelected: function() {
		return !!(this._owner._selection & this._getSelection());
	},

	setSelected: function(selected) {
		this._owner._changeSelection(this._getSelection(), selected);
	},

	_getSelection: function() {
		var owner = this._owner;
		return this === owner._point ? 1
			: this === owner._handleIn ? 2
			: this === owner._handleOut ? 4
			: 0;
	}
});

var Curve = Base.extend({
	_class: 'Curve',
	beans: true,

	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length,
			seg1, seg2,
			point1, point2,
			handle1, handle2;
		if (count === 3) {
			this._path = arg0;
			seg1 = arg1;
			seg2 = arg2;
		} else if (!count) {
			seg1 = new Segment();
			seg2 = new Segment();
		} else if (count === 1) {
			if ('segment1' in arg0) {
				seg1 = new Segment(arg0.segment1);
				seg2 = new Segment(arg0.segment2);
			} else if ('point1' in arg0) {
				point1 = arg0.point1;
				handle1 = arg0.handle1;
				handle2 = arg0.handle2;
				point2 = arg0.point2;
			} else if (Array.isArray(arg0)) {
				point1 = [arg0[0], arg0[1]];
				point2 = [arg0[6], arg0[7]];
				handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
				handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
			}
		} else if (count === 2) {
			seg1 = new Segment(arg0);
			seg2 = new Segment(arg1);
		} else if (count === 4) {
			point1 = arg0;
			handle1 = arg1;
			handle2 = arg2;
			point2 = arg3;
		} else if (count === 8) {
			point1 = [arg0, arg1];
			point2 = [arg6, arg7];
			handle1 = [arg2 - arg0, arg3 - arg1];
			handle2 = [arg4 - arg6, arg5 - arg7];
		}
		this._segment1 = seg1 || new Segment(point1, null, handle1);
		this._segment2 = seg2 || new Segment(point2, handle2, null);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.hasHandles()
				? [this.getPoint1(), this.getHandle1(), this.getHandle2(),
					this.getPoint2()]
				: [this.getPoint1(), this.getPoint2()],
				options, true, dictionary);
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

	classify: function() {
		return Curve.classify(this.getValues());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut);
		}
		return removed;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		this._segment1._point.set(Point.read(arguments));
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		this._segment2._point.set(Point.read(arguments));
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		this._segment1._handleOut.set(Point.read(arguments));
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		this._segment2._handleIn.set(Point.read(arguments));
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isFirst: function() {
		return !this._segment1._index;
	},

	isLast: function() {
		var path = this._path;
		return path && this._segment1._index === path._curves.length - 1
				|| false;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	}
}, {
	getLength: function() {
		if (this._length == null)
			this._length = Curve.getLength(this.getValues(), 0, 1);
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getLine: function() {
		return new Line(this._segment1._point, this._segment2._point);
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	divideAt: function(location) {
		return this.divideAtTime(location && location.curve === this
				? location.time : this.getTimeAt(location));
	},

	divideAtTime: function(time, _setHandles) {
		var tMin = 1e-8,
			tMax = 1 - tMin,
			res = null;
		if (time >= tMin && time <= tMax) {
			var parts = Curve.subdivide(this.getValues(), time),
				left = parts[0],
				right = parts[1],
				setHandles = _setHandles || this.hasHandles(),
				seg1 = this._segment1,
				seg2 = this._segment2,
				path = this._path;
			if (setHandles) {
				seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);
				seg2._handleIn._set(right[4] - right[6],right[5] - right[7]);
			}
			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						setHandles && new Point(left[4] - x, left[5] - y),
						setHandles && new Point(right[2] - x, right[3] - y));
			if (path) {
				path.insert(seg1._index + 1, segment);
				res = this.getNext();
			} else {
				this._segment2 = segment;
				this._changed();
				res = new Curve(segment, seg2);
			}
		}
		return res;
	},

	splitAt: function(location) {
		var path = this._path;
		return path ? path.splitAt(location) : null;
	},

	splitAtTime: function(time) {
		return this.splitAt(this.getLocationAtTime(time));
	},

	divide: function(offset, isTime) {
		return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset
				: this.getTimeAt(offset));
	},

	split: function(offset, isTime) {
		return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset
				: this.getTimeAt(offset));
	},

	reversed: function() {
		return new Curve(this._segment2.reversed(), this._segment1.reversed());
	},

	clearHandles: function() {
		this._segment1._handleOut._set(0, 0);
		this._segment2._handleIn._set(0, 0);
	},

statics: {
	getValues: function(segment1, segment2, matrix, straight) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			x1 = p1.x, y1 = p1.y,
			x2 = p2.x, y2 = p2.y,
			values = straight
				? [ x1, y1, x1, y1, x2, y2, x2, y2 ]
				: [
					x1, y1,
					x1 + h1._x, y1 + h1._y,
					x2 + h2._x, y2 + h2._y,
					x2, y2
				];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	subdivide: function(v, t) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			x4 = u * x0 + t * x1, y4 = u * y0 + t * y1,
			x5 = u * x1 + t * x2, y5 = u * y1 + t * y2,
			x6 = u * x2 + t * x3, y6 = u * y2 + t * y3,
			x7 = u * x4 + t * x5, y7 = u * y4 + t * y5,
			x8 = u * x5 + t * x6, y8 = u * y5 + t * y6,
			x9 = u * x7 + t * x8, y9 = u * y7 + t * y8;
		return [
			[x0, y0, x4, y4, x7, y7, x9, y9],
			[x9, y9, x8, y8, x6, y6, x3, y3]
		];
	},

	getMonoCurves: function(v, dir) {
		var curves = [],
			io = dir ? 0 : 1,
			o0 = v[io + 0],
			o1 = v[io + 2],
			o2 = v[io + 4],
			o3 = v[io + 6];
		if ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)
				|| Curve.isStraight(v)) {
			curves.push(v);
		} else {
			var a = 3 * (o1 - o2) - o0 + o3,
				b = 2 * (o0 + o2) - 4 * o1,
				c = o1 - o0,
				tMin = 1e-8,
				tMax = 1 - tMin,
				roots = [],
				n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);
			if (!n) {
				curves.push(v);
			} else {
				roots.sort();
				var t = roots[0],
					parts = Curve.subdivide(v, t);
				curves.push(parts[0]);
				if (n > 1) {
					t = (roots[1] - t) / (1 - t);
					parts = Curve.subdivide(parts[1], t);
					curves.push(parts[0]);
				}
				curves.push(parts[1]);
			}
		}
		return curves;
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var v0 = v[coord],
			v1 = v[coord + 2],
			v2 = v[coord + 4],
			v3 = v[coord + 6],
			res = 0;
		if (  !(v0 < val && v3 < val && v1 < val && v2 < val ||
				v0 > val && v3 > val && v1 > val && v2 > val)) {
			var c = 3 * (v1 - v0),
				b = 3 * (v2 - v1) - c,
				a = v3 - v0 - c - b;
			res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);
		}
		return res;
	},

	getTimeOf: function(v, point) {
		var p0 = new Point(v[0], v[1]),
			p3 = new Point(v[6], v[7]),
			epsilon = 1e-12,
			geomEpsilon = 1e-7,
			t = point.isClose(p0, epsilon) ? 0
			  : point.isClose(p3, epsilon) ? 1
			  : null;
		if (t === null) {
			var coords = [point.x, point.y],
				roots = [];
			for (var c = 0; c < 2; c++) {
				var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);
				for (var i = 0; i < count; i++) {
					var u = roots[i];
					if (point.isClose(Curve.getPoint(v, u), geomEpsilon))
						return u;
				}
			}
		}
		return point.isClose(p0, geomEpsilon) ? 0
			 : point.isClose(p3, geomEpsilon) ? 1
			 : null;
	},

	getNearestTime: function(v, point) {
		if (Curve.isStraight(v)) {
			var x0 = v[0], y0 = v[1],
				x3 = v[6], y3 = v[7],
				vx = x3 - x0, vy = y3 - y0,
				det = vx * vx + vy * vy;
			if (det === 0)
				return 0;
			var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
			return u < 1e-12 ? 0
				 : u > 0.999999999999 ? 1
				 : Curve.getTimeOf(v,
					new Point(x0 + u * vx, y0 + u * vy));
		}

		var count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(Curve.getPoint(v, t), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 1e-8) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		return minT;
	},

	getPart: function(v, from, to) {
		var flip = from > to;
		if (flip) {
			var tmp = from;
			from = to;
			to = tmp;
		}
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return flip
				? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]
				: v;
	},

	isFlatEnough: function(v, flatness) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			ux = 3 * x1 - 2 * x0 - x3,
			uy = 3 * y1 - 2 * y0 - y3,
			vx = 3 * x2 - 2 * x3 - x0,
			vy = 3 * y2 - 2 * y3 - y0;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				<= 16 * flatness * flatness;
	},

	getArea: function(v) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7];
		return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)
				+ y1 * (x0 - x2) - x1 * (y0 - y2)
				+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}

		padding /= 2;
		var minPad = min[coord] - padding,
			maxPad = max[coord] + padding;
		if (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||
				v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
			if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
				add(v0, padding);
				add(v3, padding);
			} else {
				var a = 3 * (v1 - v2) - v0 + v3,
					b = 2 * (v0 + v2) - 4 * v1,
					c = v1 - v0,
					count = Numerical.solveQuadratic(a, b, c, roots),
					tMin = 1e-8,
					tMax = 1 - tMin;
				add(v3, 0);
				for (var i = 0; i < count; i++) {
					var t = roots[i],
						u = 1 - t;
					if (tMin <= t && t <= tMax)
						add(u * u * u * v0
							+ 3 * u * u * t * v1
							+ 3 * u * t * t * v2
							+ t * t * t * v3,
							padding);
				}
			}
		}
	}
}}, Base.each(
	['getBounds', 'getStrokeBounds', 'getHandleBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name](
						[this._segment1, this._segment2], false, this._path);
			}
			return bounds.clone();
		};
	},
{

}), Base.each({
	isStraight: function(p1, h1, h2, p2) {
		if (h1.isZero() && h2.isZero()) {
			return true;
		} else {
			var v = p2.subtract(p1);
			if (v.isZero()) {
				return false;
			} else if (v.isCollinear(h1) && v.isCollinear(h2)) {
				var l = new Line(p1, p2),
					epsilon = 1e-7;
				if (l.getDistance(p1.add(h1)) < epsilon &&
					l.getDistance(p2.add(h2)) < epsilon) {
					var div = v.dot(v),
						s1 = v.dot(h1) / div,
						s2 = v.dot(h2) / div;
					return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
				}
			}
		}
		return false;
	},

	isLinear: function(p1, h1, h2, p2) {
		var third = p2.subtract(p1).divide(3);
		return h1.equals(third) && h2.negate().equals(third);
	}
}, function(test, name) {
	this[name] = function(epsilon) {
		var seg1 = this._segment1,
			seg2 = this._segment2;
		return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,
				epsilon);
	};

	this.statics[name] = function(v, epsilon) {
		var x0 = v[0], y0 = v[1],
			x3 = v[6], y3 = v[7];
		return test(
				new Point(x0, y0),
				new Point(v[2] - x0, v[3] - y0),
				new Point(v[4] - x3, v[5] - y3),
				new Point(x3, y3), epsilon);
	};
}, {
	statics: {},

	hasHandles: function() {
		return !this._segment1._handleOut.isZero()
				|| !this._segment2._handleIn.isZero();
	},

	hasLength: function(epsilon) {
		return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())
				&& this.getLength() > (epsilon || 0);
	},

	isCollinear: function(curve) {
		return curve && this.isStraight() && curve.isStraight()
				&& this.getLine().isCollinear(curve.getLine());
	},

	isHorizontal: function() {
		return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)
				< 1e-8;
	},

	isVertical: function() {
		return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)
				< 1e-8;
	}
}), {
	beans: false,

	getLocationAt: function(offset, _isTime) {
		return this.getLocationAtTime(
				_isTime ? offset : this.getTimeAt(offset));
	},

	getLocationAtTime: function(t) {
		return t != null && t >= 0 && t <= 1
				? new CurveLocation(this, t)
				: null;
	},

	getTimeAt: function(offset, start) {
		return Curve.getTimeAt(this.getValues(), offset, start);
	},

	getParameterAt: '#getTimeAt',

	getTimesWithTangent: function () {
		var tangent = Point.read(arguments);
		return tangent.isZero()
				? []
				: Curve.getTimesWithTangent(this.getValues(), tangent);
	},

	getOffsetAtTime: function(t) {
		return this.getPartLength(0, t);
	},

	getLocationOf: function() {
		return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getTimeOf: function() {
		return Curve.getTimeOf(this.getValues(), Point.read(arguments));
	},

	getParameterOf: '#getTimeOf',

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			t = Curve.getNearestTime(values, point),
			pt = Curve.getPoint(values, t);
		return new CurveLocation(this, t, pt, null, point.getDistance(pt));
	},

	getNearestPoint: function() {
		var loc = this.getNearestLocation.apply(this, arguments);
		return loc ? loc.getPoint() : loc;
	}

},
new function() {
	var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
		'getWeightedNormal', 'getCurvature'];
	return Base.each(methods,
		function(name) {
			this[name + 'At'] = function(location, _isTime) {
				var values = this.getValues();
				return Curve[name](values, _isTime ? location
						: Curve.getTimeAt(values, location));
			};

			this[name + 'AtTime'] = function(time) {
				return Curve[name](this.getValues(), time);
			};
		}, {
			statics: {
				_evaluateMethods: methods
			}
		}
	);
},
new function() {

	function getLengthIntegrand(v) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],

			ax = 9 * (x1 - x2) + 3 * (x3 - x0),
			bx = 6 * (x0 + x2) - 12 * x1,
			cx = 3 * (x1 - x0),

			ay = 9 * (y1 - y2) + 3 * (y3 - y0),
			by = 6 * (y0 + y2) - 12 * y1,
			cy = 3 * (y1 - y0);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	function evaluate(v, t, type, normalized) {
		if (t == null || t < 0 || t > 1)
			return null;
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			isZero = Numerical.isZero;
		if (isZero(x1 - x0) && isZero(y1 - y0)) {
			x1 = x0;
			y1 = y0;
		}
		if (isZero(x2 - x3) && isZero(y2 - y3)) {
			x2 = x3;
			y2 = y3;
		}
		var cx = 3 * (x1 - x0),
			bx = 3 * (x2 - x1) - cx,
			ax = x3 - x0 - cx - bx,
			cy = 3 * (y1 - y0),
			by = 3 * (y2 - y1) - cy,
			ay = y3 - y0 - cy - by,
			x, y;
		if (type === 0) {
			x = t === 0 ? x0 : t === 1 ? x3
					: ((ax * t + bx) * t + cx) * t + x0;
			y = t === 0 ? y0 : t === 1 ? y3
					: ((ay * t + by) * t + cy) * t + y0;
		} else {
			var tMin = 1e-8,
				tMax = 1 - tMin;
			if (t < tMin) {
				x = cx;
				y = cy;
			} else if (t > tMax) {
				x = 3 * (x3 - x2);
				y = 3 * (y3 - y2);
			} else {
				x = (3 * ax * t + 2 * bx) * t + cx;
				y = (3 * ay * t + 2 * by) * t + cy;
			}
			if (normalized) {
				if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
					x = x2 - x1;
					y = y2 - y1;
				}
				var len = Math.sqrt(x * x + y * y);
				if (len) {
					x /= len;
					y /= len;
				}
			}
			if (type === 3) {
				var x2 = 6 * ax * t + 2 * bx,
					y2 = 6 * ay * t + 2 * by,
					d = Math.pow(x * x + y * y, 3 / 2);
				x = d !== 0 ? (x * y2 - y * x2) / d : 0;
				y = 0;
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	}

	return { statics: {

		classify: function(v) {

			var x0 = v[0], y0 = v[1],
				x1 = v[2], y1 = v[3],
				x2 = v[4], y2 = v[5],
				x3 = v[6], y3 = v[7],
				a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,
				a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,
				a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,
				d3 = 3 * a3,
				d2 = d3 - a2,
				d1 = d2 - a2 + a1,
				l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),
				s = l !== 0 ? 1 / l : 0,
				isZero = Numerical.isZero,
				serpentine = 'serpentine';
			d1 *= s;
			d2 *= s;
			d3 *= s;

			function type(type, t1, t2) {
				var hasRoots = t1 !== undefined,
					t1Ok = hasRoots && t1 > 0 && t1 < 1,
					t2Ok = hasRoots && t2 > 0 && t2 < 1;
				if (hasRoots && (!(t1Ok || t2Ok)
						|| type === 'loop' && !(t1Ok && t2Ok))) {
					type = 'arch';
					t1Ok = t2Ok = false;
				}
				return {
					type: type,
					roots: t1Ok || t2Ok
							? t1Ok && t2Ok
								? t1 < t2 ? [t1, t2] : [t2, t1]
								: [t1Ok ? t1 : t2]
							: null
				};
			}

			if (isZero(d1)) {
				return isZero(d2)
						? type(isZero(d3) ? 'line' : 'quadratic')
						: type(serpentine, d3 / (3 * d2));
			}
			var d = 3 * d2 * d2 - 4 * d1 * d3;
			if (isZero(d)) {
				return type('cusp', d2 / (2 * d1));
			}
			var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),
				f2 = 2 * d1;
			return type(d > 0 ? serpentine : 'loop',
					(d2 + f1) / f2,
					(d2 - f1) / f2);
		},

		getLength: function(v, a, b, ds) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			if (Curve.isStraight(v)) {
				var c = v;
				if (b < 1) {
					c = Curve.subdivide(c, b)[0];
					a /= b;
				}
				if (a > 0) {
					c = Curve.subdivide(c, a)[1];
				}
				var dx = c[6] - c[0],
					dy = c[7] - c[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			return Numerical.integrate(ds || getLengthIntegrand(v), a, b,
					getIterations(a, b));
		},

		getTimeAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0;
			if (offset === 0)
				return start;
			var abs = Math.abs,
				epsilon = 1e-12,
				forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Curve.getLength(v, a, b, ds),
				diff = abs(offset) - rangeLength;
			if (abs(diff) < epsilon) {
				return forward ? b : a;
			} else if (diff > epsilon) {
				return null;
			}
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 32,
					1e-12);
		},

		getPoint: function(v, t) {
			return evaluate(v, t, 0, false);
		},

		getTangent: function(v, t) {
			return evaluate(v, t, 1, true);
		},

		getWeightedTangent: function(v, t) {
			return evaluate(v, t, 1, false);
		},

		getNormal: function(v, t) {
			return evaluate(v, t, 2, true);
		},

		getWeightedNormal: function(v, t) {
			return evaluate(v, t, 2, false);
		},

		getCurvature: function(v, t) {
			return evaluate(v, t, 3, false).x;
		},

		getPeaks: function(v) {
			var x0 = v[0], y0 = v[1],
				x1 = v[2], y1 = v[3],
				x2 = v[4], y2 = v[5],
				x3 = v[6], y3 = v[7],
				ax =     -x0 + 3 * x1 - 3 * x2 + x3,
				bx =  3 * x0 - 6 * x1 + 3 * x2,
				cx = -3 * x0 + 3 * x1,
				ay =     -y0 + 3 * y1 - 3 * y2 + y3,
				by =  3 * y0 - 6 * y1 + 3 * y2,
				cy = -3 * y0 + 3 * y1,
				tMin = 1e-8,
				tMax = 1 - tMin,
				roots = [];
			Numerical.solveCubic(
					9 * (ax * ax + ay * ay),
					9 * (ax * bx + by * ay),
					2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),
					(cx * bx + by * cy),
					roots, tMin, tMax);
			return roots.sort();
		}
	}};
},
new function() {

	function addLocation(locations, include, c1, t1, c2, t2, overlap) {
		var excludeStart = !overlap && c1.getPrevious() === c2,
			excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,
			tMin = 1e-8,
			tMax = 1 - tMin;
		if (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&
			t1 <= (excludeEnd ? tMax : 1)) {
			if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&
				t2 <= (excludeStart ? tMax : 1)) {
				var loc1 = new CurveLocation(c1, t1, null, overlap),
					loc2 = new CurveLocation(c2, t2, null, overlap);
				loc1._intersection = loc2;
				loc2._intersection = loc1;
				if (!include || include(loc1)) {
					CurveLocation.insert(locations, loc1, true);
				}
			}
		}
	}

	function addCurveIntersections(v1, v2, c1, c2, locations, include, flip,
			recursion, calls, tMin, tMax, uMin, uMax) {
		if (++calls >= 4096 || ++recursion >= 40)
			return calls;
		var fatLineEpsilon = 1e-9,
			q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			hull = getConvexHull(dp0, dp1, dp2, dp3),
			top = hull[0],
			bottom = hull[1],
			tMinClip,
			tMaxClip;
		if (d1 === 0 && d2 === 0
				&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0
			|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null
			|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),
				dMin, dMax)) == null)
			return calls;
		var tMinNew = tMin + (tMax - tMin) * tMinClip,
			tMaxNew = tMin + (tMax - tMin) * tMaxClip;
		if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
			var t = (tMinNew + tMaxNew) / 2,
				u = (uMin + uMax) / 2;
			addLocation(locations, include,
					flip ? c2 : c1, flip ? u : t,
					flip ? c1 : c2, flip ? t : u);
		} else {
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			var uDiff = uMax - uMin;
			if (tMaxClip - tMinClip > 0.8) {
				if (tMaxNew - tMinNew > uDiff) {
					var parts = Curve.subdivide(v1, 0.5),
						t = (tMinNew + tMaxNew) / 2;
					calls = addCurveIntersections(
							v2, parts[0], c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, tMinNew, t);
					calls = addCurveIntersections(
							v2, parts[1], c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, t, tMaxNew);
				} else {
					var parts = Curve.subdivide(v2, 0.5),
						u = (uMin + uMax) / 2;
					calls = addCurveIntersections(
							parts[0], v1, c2, c1, locations, include, !flip,
							recursion, calls, uMin, u, tMinNew, tMaxNew);
					calls = addCurveIntersections(
							parts[1], v1, c2, c1, locations, include, !flip,
							recursion, calls, u, uMax, tMinNew, tMaxNew);
				}
			} else {
				if (uDiff === 0 || uDiff >= fatLineEpsilon) {
					calls = addCurveIntersections(
							v2, v1, c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, tMinNew, tMaxNew);
				} else {
					calls = addCurveIntersections(
							v1, v2, c1, c2, locations, include, flip,
							recursion, calls, tMinNew, tMaxNew, uMin, uMax);
				}
			}
		}
		return calls;
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			dist1 = dq1 - (2 * dq0 + dq3) / 3,
			dist2 = dq2 - (dq0 + 2 * dq3) / 3,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
		} else {
			var distRatio = dist1 / dist2;
			hull = [
				distRatio >= 2 ? [p0, p1, p3]
				: distRatio <= 0.5 ? [p0, p2, p3]
				: [p0, p1, p2, p3],
				[p0, p3]
			];
		}
		return (dist1 || dist2) < 0 ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		if (hullTop[0][1] < dMin) {
			return clipConvexHullPart(hullTop, true, dMin);
		} else if (hullBottom[0][1] > dMax) {
			return clipConvexHullPart(hullBottom, false, dMax);
		} else {
			return hullTop[0][0];
		}
	}

	function clipConvexHullPart(part, top, threshold) {
		var px = part[0][0],
			py = part[0][1];
		for (var i = 1, l = part.length; i < l; i++) {
			var qx = part[i][0],
				qy = part[i][1];
			if (top ? qy >= threshold : qy <= threshold) {
				return qy === threshold ? qx
						: px + (threshold - py) * (qx - px) / (qy - py);
			}
			px = qx;
			py = qy;
		}
		return null;
	}

	function getCurveLineIntersections(v, px, py, vx, vy) {
		var isZero = Numerical.isZero;
		if (isZero(vx) && isZero(vy)) {
			var t = Curve.getTimeOf(v, new Point(px, py));
			return t === null ? [] : [t];
		}
		var angle = Math.atan2(-vy, vx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rv = [],
			roots = [];
		for (var i = 0; i < 8; i += 2) {
			var x = v[i] - px,
				y = v[i + 1] - py;
			rv.push(
				x * cos - y * sin,
				x * sin + y * cos);
		}
		Curve.solveCubic(rv, 1, 0, roots, 0, 1);
		return roots;
	}

	function addCurveLineIntersections(v1, v2, c1, c2, locations, include,
			flip) {
		var x1 = v2[0], y1 = v2[1],
			x2 = v2[6], y2 = v2[7],
			roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);
		for (var i = 0, l = roots.length; i < l; i++) {
			var t1 = roots[i],
				p1 = Curve.getPoint(v1, t1),
				t2 = Curve.getTimeOf(v2, p1);
			if (t2 !== null) {
				addLocation(locations, include,
						flip ? c2 : c1, flip ? t2 : t1,
						flip ? c1 : c2, flip ? t1 : t2);
			}
		}
	}

	function addLineIntersection(v1, v2, c1, c2, locations, include) {
		var pt = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (pt) {
			addLocation(locations, include,
					c1, Curve.getTimeOf(v1, pt),
					c2, Curve.getTimeOf(v2, pt));
		}
	}

	function getCurveIntersections(v1, v2, c1, c2, locations, include) {
		var epsilon = 1e-12,
			min = Math.min,
			max = Math.max;

		if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >
			min(v2[0], v2[2], v2[4], v2[6]) &&
			min(v1[0], v1[2], v1[4], v1[6]) - epsilon <
			max(v2[0], v2[2], v2[4], v2[6]) &&
			max(v1[1], v1[3], v1[5], v1[7]) + epsilon >
			min(v2[1], v2[3], v2[5], v2[7]) &&
			min(v1[1], v1[3], v1[5], v1[7]) - epsilon <
			max(v2[1], v2[3], v2[5], v2[7])) {
			var overlaps = getOverlaps(v1, v2);
			if (overlaps) {
				for (var i = 0; i < 2; i++) {
					var overlap = overlaps[i];
					addLocation(locations, include,
							c1, overlap[0],
							c2, overlap[1], true);
				}
			} else {
				var straight1 = Curve.isStraight(v1),
					straight2 = Curve.isStraight(v2),
					straight = straight1 && straight2,
					flip = straight1 && !straight2,
					before = locations.length;
				(straight
					? addLineIntersection
					: straight1 || straight2
						? addCurveLineIntersections
						: addCurveIntersections)(
							flip ? v2 : v1, flip ? v1 : v2,
							flip ? c2 : c1, flip ? c1 : c2,
							locations, include, flip,
							0, 0, 0, 1, 0, 1);
				if (!straight || locations.length === before) {
					for (var i = 0; i < 4; i++) {
						var t1 = i >> 1,
							t2 = i & 1,
							i1 = t1 * 6,
							i2 = t2 * 6,
							p1 = new Point(v1[i1], v1[i1 + 1]),
							p2 = new Point(v2[i2], v2[i2 + 1]);
						if (p1.isClose(p2, epsilon)) {
							addLocation(locations, include,
									c1, t1,
									c2, t2);
						}
					}
				}
			}
		}
		return locations;
	}

	function getSelfIntersection(v1, c1, locations, include) {
		var info = Curve.classify(v1);
		if (info.type === 'loop') {
			var roots = info.roots;
			addLocation(locations, include,
					c1, roots[0],
					c1, roots[1]);
		}
	  return locations;
	}

	function getIntersections(curves1, curves2, include, matrix1, matrix2,
			_returnFirst) {
		var epsilon = 1e-7,
			self = !curves2;
		if (self)
			curves2 = curves1;
		var length1 = curves1.length,
			length2 = curves2.length,
			values1 = new Array(length1),
			values2 = self ? values1 : new Array(length2),
			locations = [];

		for (var i = 0; i < length1; i++) {
			values1[i] = curves1[i].getValues(matrix1);
		}
		if (!self) {
			for (var i = 0; i < length2; i++) {
				values2[i] = curves2[i].getValues(matrix2);
			}
		}
		var boundsCollisions = CollisionDetection.findCurveBoundsCollisions(
				values1, values2, epsilon);
		for (var index1 = 0; index1 < length1; index1++) {
			var curve1 = curves1[index1],
				v1 = values1[index1];
			if (self) {
				getSelfIntersection(v1, curve1, locations, include);
			}
			var collisions1 = boundsCollisions[index1];
			if (collisions1) {
				for (var j = 0; j < collisions1.length; j++) {
					if (_returnFirst && locations.length)
						return locations;
					var index2 = collisions1[j];
					if (!self || index2 > index1) {
						var curve2 = curves2[index2],
							v2 = values2[index2];
						getCurveIntersections(
								v1, v2, curve1, curve2, locations, include);
					}
				}
			}
		}
		return locations;
	}

	function getOverlaps(v1, v2) {

		function getSquaredLineLength(v) {
			var x = v[6] - v[0],
				y = v[7] - v[1];
			return x * x + y * y;
		}

		var abs = Math.abs,
			getDistance = Line.getDistance,
			timeEpsilon = 1e-8,
			geomEpsilon = 1e-7,
			straight1 = Curve.isStraight(v1),
			straight2 = Curve.isStraight(v2),
			straightBoth = straight1 && straight2,
			flip = getSquaredLineLength(v1) < getSquaredLineLength(v2),
			l1 = flip ? v2 : v1,
			l2 = flip ? v1 : v2,
			px = l1[0], py = l1[1],
			vx = l1[6] - px, vy = l1[7] - py;
		if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&
			getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
			if (!straightBoth &&
				getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
				straight1 = straight2 = straightBoth = true;
			}
		} else if (straightBoth) {
			return null;
		}
		if (straight1 ^ straight2) {
			return null;
		}

		var v = [v1, v2],
			pairs = [];
		for (var i = 0; i < 4 && pairs.length < 2; i++) {
			var i1 = i & 1,
				i2 = i1 ^ 1,
				t1 = i >> 1,
				t2 = Curve.getTimeOf(v[i1], new Point(
					v[i2][t1 ? 6 : 0],
					v[i2][t1 ? 7 : 1]));
			if (t2 != null) {
				var pair = i1 ? [t1, t2] : [t2, t1];
				if (!pairs.length ||
					abs(pair[0] - pairs[0][0]) > timeEpsilon &&
					abs(pair[1] - pairs[0][1]) > timeEpsilon) {
					pairs.push(pair);
				}
			}
			if (i > 2 && !pairs.length)
				break;
		}
		if (pairs.length !== 2) {
			pairs = null;
		} else if (!straightBoth) {
			var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
				o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
			if (abs(o2[2] - o1[2]) > geomEpsilon ||
				abs(o2[3] - o1[3]) > geomEpsilon ||
				abs(o2[4] - o1[4]) > geomEpsilon ||
				abs(o2[5] - o1[5]) > geomEpsilon)
				pairs = null;
		}
		return pairs;
	}

	function getTimesWithTangent(v, tangent) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			normalized = tangent.normalize(),
			tx = normalized.x,
			ty = normalized.y,
			ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,
			ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,
			bx = 6 * x2 - 12 * x1 + 6 * x0,
			by = 6 * y2 - 12 * y1 + 6 * y0,
			cx = 3 * x1 - 3 * x0,
			cy = 3 * y1 - 3 * y0,
			den = 2 * ax * ty - 2 * ay * tx,
			times = [];
		if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {
			var num = ax * cy - ay * cx,
				den = ax * by - ay * bx;
			if (den != 0) {
				var t = -num / den;
				if (t >= 0 && t <= 1) times.push(t);
			}
		} else {
			var delta = (bx * bx - 4 * ax * cx) * ty * ty +
				(-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty +
				(by * by - 4 * ay * cy) * tx * tx,
				k = bx * ty - by * tx;
			if (delta >= 0 && den != 0) {
				var d = Math.sqrt(delta),
					t0 = -(k + d) / den,
					t1 = (-k + d) / den;
				if (t0 >= 0 && t0 <= 1) times.push(t0);
				if (t1 >= 0 && t1 <= 1) times.push(t1);
			}
		}
		return times;
	}

	return {
		getIntersections: function(curve) {
			var v1 = this.getValues(),
				v2 = curve && curve !== this && curve.getValues();
			return v2 ? getCurveIntersections(v1, v2, this, curve, [])
					  : getSelfIntersection(v1, this, []);
		},

		statics: {
			getOverlaps: getOverlaps,
			getIntersections: getIntersections,
			getCurveLineIntersections: getCurveLineIntersections,
			getTimesWithTangent: getTimesWithTangent
		}
	};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',

	initialize: function CurveLocation(curve, time, point, _overlap, _distance) {
		if (time >= 0.99999999) {
			var next = curve.getNext();
			if (next) {
				time = 0;
				curve = next;
			}
		}
		this._setCurve(curve);
		this._time = time;
		this._point = point || curve.getPointAtTime(time);
		this._overlap = _overlap;
		this._distance = _distance;
		this._intersection = this._next = this._previous = null;
	},

	_setPath: function(path) {
		this._path = path;
		this._version = path ? path._version : 0;
	},

	_setCurve: function(curve) {
		this._setPath(curve._path);
		this._curve = curve;
		this._segment = null;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
	},

	_setSegment: function(segment) {
		var curve = segment.getCurve();
		if (curve) {
			this._setCurve(curve);
		} else {
			this._setPath(segment._path);
			this._segment1 = segment;
			this._segment2 = null;
		}
		this._segment = segment;
		this._time = segment === this._segment1 ? 0 : 1;
		this._point = segment._point.clone();
	},

	getSegment: function() {
		var segment = this._segment;
		if (!segment) {
			var curve = this.getCurve(),
				time = this.getTime();
			if (time === 0) {
				segment = curve._segment1;
			} else if (time === 1) {
				segment = curve._segment2;
			} else if (time != null) {
				segment = curve.getPartLength(0, time)
					< curve.getPartLength(time, 1)
						? curve._segment1
						: curve._segment2;
			}
			this._segment = segment;
		}
		return segment;
	},

	getCurve: function() {
		var path = this._path,
			that = this;
		if (path && path._version !== this._version) {
			this._time = this._offset = this._curveOffset = this._curve = null;
		}

		function trySegment(segment) {
			var curve = segment && segment.getCurve();
			if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
				that._setCurve(curve);
				return curve;
			}
		}

		return this._curve
			|| trySegment(this._segment)
			|| trySegment(this._segment1)
			|| trySegment(this._segment2.getPrevious());
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getTime: function() {
		var curve = this.getCurve(),
			time = this._time;
		return curve && time == null
			? this._time = curve.getTimeOf(this._point)
			: time;
	},

	getParameter: '#getTime',

	getPoint: function() {
		return this._point;
	},

	getOffset: function() {
		var offset = this._offset;
		if (offset == null) {
			offset = 0;
			var path = this.getPath(),
				index = this.getIndex();
			if (path && index != null) {
				var curves = path.getCurves();
				for (var i = 0; i < index; i++)
					offset += curves[i].getLength();
			}
			this._offset = offset += this.getCurveOffset();
		}
		return offset;
	},

	getCurveOffset: function() {
		var offset = this._curveOffset;
		if (offset == null) {
			var curve = this.getCurve(),
				time = this.getTime();
			this._curveOffset = offset = time != null && curve
					&& curve.getPartLength(0, time);
		}
		return offset;
	},

	getIntersection: function() {
		return this._intersection;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(),
			res = curve && curve.divideAtTime(this.getTime());
		if (res) {
			this._setSegment(res._segment1);
		}
		return res;
	},

	split: function() {
		var curve = this.getCurve(),
			path = curve._path,
			res = curve && curve.splitAtTime(this.getTime());
		if (res) {
			this._setSegment(path.getLastSegment());
		}
		return  res;
	},

	equals: function(loc, _ignoreOther) {
		var res = this === loc;
		if (!res && loc instanceof CurveLocation) {
			var c1 = this.getCurve(),
				c2 = loc.getCurve(),
				p1 = c1._path,
				p2 = c2._path;
			if (p1 === p2) {
				var abs = Math.abs,
					epsilon = 1e-7,
					diff = abs(this.getOffset() - loc.getOffset()),
					i1 = !_ignoreOther && this._intersection,
					i2 = !_ignoreOther && loc._intersection;
				res = (diff < epsilon
						|| p1 && abs(p1.getLength() - diff) < epsilon)
					&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
			}
		}
		return res;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var time = this.getTime();
		if (time != null)
			parts.push('time: ' + f.number(time));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	},

	isTouching: function() {
		var inter = this._intersection;
		if (inter && this.getTangent().isCollinear(inter.getTangent())) {
			var curve1 = this.getCurve(),
				curve2 = inter.getCurve();
			return !(curve1.isStraight() && curve2.isStraight()
					&& curve1.getLine().intersect(curve2.getLine()));
		}
		return false;
	},

	isCrossing: function() {
		var inter = this._intersection;
		if (!inter)
			return false;
		var t1 = this.getTime(),
			t2 = inter.getTime(),
			tMin = 1e-8,
			tMax = 1 - tMin,
			t1Inside = t1 >= tMin && t1 <= tMax,
			t2Inside = t2 >= tMin && t2 <= tMax;
		if (t1Inside && t2Inside)
			return !this.isTouching();
		var c2 = this.getCurve(),
			c1 = c2 && t1 < tMin ? c2.getPrevious() : c2,
			c4 = inter.getCurve(),
			c3 = c4 && t2 < tMin ? c4.getPrevious() : c4;
		if (t1 > tMax)
			c2 = c2.getNext();
		if (t2 > tMax)
			c4 = c4.getNext();
		if (!c1 || !c2 || !c3 || !c4)
			return false;

		var offsets = [];

		function addOffsets(curve, end) {
			var v = curve.getValues(),
				roots = Curve.classify(v).roots || Curve.getPeaks(v),
				count = roots.length,
				offset = Curve.getLength(v,
					end && count ? roots[count - 1] : 0,
					!end && count ? roots[0] : 1);
			offsets.push(count ? offset : offset / 32);
		}

		function isInRange(angle, min, max) {
			return min < max
					? angle > min && angle < max
					: angle > min || angle < max;
		}

		if (!t1Inside) {
			addOffsets(c1, true);
			addOffsets(c2, false);
		}
		if (!t2Inside) {
			addOffsets(c3, true);
			addOffsets(c4, false);
		}
		var pt = this.getPoint(),
			offset = Math.min.apply(Math, offsets),
			v2 = t1Inside ? c2.getTangentAtTime(t1)
					: c2.getPointAt(offset).subtract(pt),
			v1 = t1Inside ? v2.negate()
					: c1.getPointAt(-offset).subtract(pt),
			v4 = t2Inside ? c4.getTangentAtTime(t2)
					: c4.getPointAt(offset).subtract(pt),
			v3 = t2Inside ? v4.negate()
					: c3.getPointAt(-offset).subtract(pt),
			a1 = v1.getAngle(),
			a2 = v2.getAngle(),
			a3 = v3.getAngle(),
			a4 = v4.getAngle();
		return !!(t1Inside
				? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&
				  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))
				: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&
				  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));
	},

	hasOverlap: function() {
		return !!this._overlap;
	}
}, Base.each(Curve._evaluateMethods, function(name) {
	var get = name + 'At';
	this[name] = function() {
		var curve = this.getCurve(),
			time = this.getTime();
		return time != null && curve && curve[get](time, true);
	};
}, {
	preserve: true
}),
new function() {

	function insert(locations, loc, merge) {
		var length = locations.length,
			l = 0,
			r = length - 1;

		function search(index, dir) {
			for (var i = index + dir; i >= -1 && i <= length; i += dir) {
				var loc2 = locations[((i % length) + length) % length];
				if (!loc.getPoint().isClose(loc2.getPoint(),
						1e-7))
					break;
				if (loc.equals(loc2))
					return loc2;
			}
			return null;
		}

		while (l <= r) {
			var m = (l + r) >>> 1,
				loc2 = locations[m],
				found;
			if (merge && (found = loc.equals(loc2) ? loc2
					: (search(m, -1) || search(m, 1)))) {
				if (loc._overlap) {
					found._overlap = found._intersection._overlap = true;
				}
				return found;
			}
		var path1 = loc.getPath(),
			path2 = loc2.getPath(),
			diff = path1 !== path2
				? path1._id - path2._id
				: (loc.getIndex() + loc.getTime())
				- (loc2.getIndex() + loc2.getTime());
			if (diff < 0) {
				r = m - 1;
			} else {
				l = m + 1;
			}
		}
		locations.splice(l, 0, loc);
		return loc;
	}

	return { statics: {
		insert: insert,

		expand: function(locations) {
			var expanded = locations.slice();
			for (var i = locations.length - 1; i >= 0; i--) {
				insert(expanded, locations[i]._intersection, false);
			}
			return expanded;
		}
	}};
});

var PathItem = Item.extend({
	_class: 'PathItem',
	_selectBounds: false,
	_canScaleStroke: true,
	beans: true,

	initialize: function PathItem() {
	},

	statics: {
		create: function(arg) {
			var data,
				segments,
				compound;
			if (Base.isPlainObject(arg)) {
				segments = arg.segments;
				data = arg.pathData;
			} else if (Array.isArray(arg)) {
				segments = arg;
			} else if (typeof arg === 'string') {
				data = arg;
			}
			if (segments) {
				var first = segments[0];
				compound = first && Array.isArray(first[0]);
			} else if (data) {
				compound = (data.match(/m/gi) || []).length > 1
						|| /z\s*\S+/i.test(data);
			}
			var ctor = compound ? CompoundPath : Path;
			return new ctor(arg);
		}
	},

	_asPathItem: function() {
		return this;
	},

	isClockwise: function() {
		return this.getArea() >= 0;
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
	},

	setPathData: function(data) {

		var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts && parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				for (var j = 0; j < length; j += 2) {
					this[move ? 'moveTo' : 'lineTo'](current = getPoint(j));
					if (move) {
						start = current;
						move = false;
					}
				}
				control = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				current = current.clone();
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[j], +coords[j + 1]),
							+coords[j + 2], +coords[j + 4], +coords[j + 3]);
				}
				break;
			case 'z':
				this.closePath(1e-12);
				current = start;
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = point.isInside(
				this.getBounds({ internal: true, handle: true }))
					? this._getWinding(point)
					: {};
		return winding.onPath || !!(this.getFillRule() === 'evenodd'
				? winding.windingL & 1 || winding.windingR & 1
				: winding.winding);
	},

	getIntersections: function(path, include, _matrix, _returnFirst) {
		var self = this === path || !path,
			matrix1 = this._matrix._orNullIfIdentity(),
			matrix2 = self ? matrix1
				: (_matrix || path._matrix)._orNullIfIdentity();
		return self || this.getBounds(matrix1).intersects(
				path.getBounds(matrix2), 1e-12)
				? Curve.getIntersections(
						this.getCurves(), !self && path.getCurves(), include,
						matrix1, matrix2, _returnFirst)
				: [];
	},

	getCrossings: function(path) {
		return this.getIntersections(path, function(inter) {
			return inter.isCrossing();
		});
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		var loc = this.getNearestLocation.apply(this, arguments);
		return loc ? loc.getPoint() : loc;
	},

	interpolate: function(from, to, factor) {
		var isPath = !this._children,
			name = isPath ? '_segments' : '_children',
			itemsFrom = from[name],
			itemsTo = to[name],
			items = this[name];
		if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
			throw new Error('Invalid operands in interpolate() call: ' +
					from + ', ' + to);
		}
		var current = items.length,
			length = itemsTo.length;
		if (current < length) {
			var ctor = isPath ? Segment : Path;
			for (var i = current; i < length; i++) {
				this.add(new ctor());
			}
		} else if (current > length) {
			this[isPath ? 'removeSegments' : 'removeChildren'](length, current);
		}
		for (var i = 0; i < length; i++) {
			items[i].interpolate(itemsFrom[i], itemsTo[i], factor);
		}
		if (isPath) {
			this.setClosed(from._closed);
			this._changed(9);
		}
	},

	compare: function(path) {
		var ok = false;
		if (path) {
			var paths1 = this._children || [this],
				paths2 = path._children ? path._children.slice() : [path],
				length1 = paths1.length,
				length2 = paths2.length,
				matched = [],
				count = 0;
			ok = true;
			var boundsOverlaps = CollisionDetection.findItemBoundsCollisions(paths1, paths2, Numerical.GEOMETRIC_EPSILON);
			for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
				var path1 = paths1[i1];
				ok = false;
				var pathBoundsOverlaps = boundsOverlaps[i1];
				if (pathBoundsOverlaps) {
					for (var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--) {
						if (path1.compare(paths2[pathBoundsOverlaps[i2]])) {
							if (!matched[pathBoundsOverlaps[i2]]) {
								matched[pathBoundsOverlaps[i2]] = true;
								count++;
							}
							ok = true;
						}
					}
				}
			}
			ok = ok && count === length2;
		}
		return ok;
	},

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		this._version = 0;
		var args = arguments,
			segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: args
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? args
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._segmentSelection = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return this._closed === item._closed
				&& Base.equals(this._segments, item._segments);
	},

	copyContent: function(source) {
		this.setSegments(source._segments);
		this._closed = source._closed;
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			this._length = this._area = undefined;
			if (flags & 32) {
				this._version++;
			} else if (this._curves) {
			   for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
		} else if (flags & 64) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected(),
			length = segments && segments.length;
		this._segments.length = 0;
		this._segmentSelection = 0;
		this._curves = undefined;
		if (length) {
			var last = segments[length - 1];
			if (typeof last === 'boolean') {
				this.setClosed(last);
				length--;
			}
			this._add(Segment.readList(segments, 0, {}, length));
		}
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(41);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine) {
						var dx = curX - prevX,
							dy = curY - prevY;
						parts.push(
							  dx === 0 ? 'v' + f.number(dy)
							: dy === 0 ? 'h' + f.number(dx)
							: 'l' + f.pair(dx, dy));
					}
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							 + ' ' + f.pair( inX - prevX,  inY - prevY)
							 + ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (!length)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	},

	isEmpty: function() {
		return !this._segments.length;
	},

	_transformContent: function(matrix) {
		var segments = this._segments,
			coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selection)
				this._updateSelection(segment, 0, segment._selection);
		}
		if (append) {
			Base.push(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves) {
			var total = this._countCurves(),
				start = index > 0 && index + amount - 1 === total ? index - 1
					: index,
				insert = start,
				end = Math.min(start + amount, total);
			if (segs._curves) {
				curves.splice.apply(curves, [start, 0].concat(segs._curves));
				insert += segs._curves.length;
			}
			for (var i = insert; i < end; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(start, end);
		}
		this._changed(41);
		return segs;
	},

	_adjustCurves: function(start, end) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = start; i < end; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && !start ? segments.length - 1
				: start - 1]) {
			curve._segment2 = segments[start] || segments[0];
			curve._changed();
		}
		if (curve = curves[end]) {
			curve._segment1 = segments[end];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		var args = arguments;
		return args.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readList(args))
			: this._add([ Segment.read(args) ])[0];
	},

	insert: function(index, segment1 ) {
		var args = arguments;
		return args.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readList(args, 1), index)
			: this._add([ Segment.read(args, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readList(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readList(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(start, end, _includeCurves) {
		start = start || 0;
		end = Base.pick(end, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(start, end - start),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selection)
				this._updateSelection(segment, segment._selection, 0);
			segment._index = segment._path = null;
		}
		for (var i = start, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = start > 0 && end === count + (this._closed ? 1 : 0)
					? start - 1
					: start,
				curves = curves.splice(index, amount);
			for (var i = curves.length - 1; i >= 0; i--)
				curves[i]._path = null;
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(41);
		return removed;
	},

	clear: '#removeSegments',

	hasHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++) {
			if (segments[i].hasHandles())
				return true;
		}
		return false;
	},

	clearHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i].clearHandles();
	},

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				length += curves[i].getLength();
			this._length = length;
		}
		return this._length;
	},

	getArea: function() {
		var area = this._area;
		if (area == null) {
			var segments = this._segments,
				closed = this._closed;
			area = 0;
			for (var i = 0, l = segments.length; i < l; i++) {
				var last = i + 1 === l;
				area += Curve.getArea(Curve.getValues(
						segments[i], segments[last ? 0 : i + 1],
						null, last && !closed));
			}
			this._area = area;
		}
		return area;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this.isSelected() && length > 0 && this._segmentSelection
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelection: function setSelection(selection) {
		if (!(selection & 1))
			this._selectSegments(false);
		setSelection.base.call(this, selection);
	},

	_selectSegments: function(selected) {
		var segments = this._segments,
			length = segments.length,
			selection = selected ? 7 : 0;
		this._segmentSelection = selection * length;
		for (var i = 0; i < length; i++)
			segments[i]._selection = selection;
	},

	_updateSelection: function(segment, oldSelection, newSelection) {
		segment._selection = newSelection;
		var selection = this._segmentSelection += newSelection - oldSelection;
		if (selection > 0)
			this.setSelected(true);
	},

	divideAt: function(location) {
		var loc = this.getLocationAt(location),
			curve;
		return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))
				? curve._segment1
				: null;
	},

	splitAt: function(location) {
		var loc = this.getLocationAt(location),
			index = loc && loc.index,
			time = loc && loc.time,
			tMin = 1e-8,
			tMax = 1 - tMin;
		if (time > tMax) {
			index++;
			time = 0;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (time >= tMin) {
				curves[index++].divideAtTime(time);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else {
				path = new Path(Item.NO_INSERT);
				path.insertAbove(this);
				path.copyAttributes(this);
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	split: function(index, time) {
		var curve,
			location = time === undefined ? index
				: (curve = this.getCurves()[index])
					&& curve.getLocationAtTime(time);
		return location != null ? this.splitAt(location) : null;
	},

	join: function(path, tolerance) {
		var epsilon = tolerance || 0;
		if (path && path !== this) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (!last2)
				return this;
			if (last1 && last1._point.isClose(last2._point, epsilon))
				path.reverse();
			var first2 = path.getFirstSegment();
			if (last1 && last1._point.isClose(first2._point, epsilon)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				var first1 = this.getFirstSegment();
				if (first1 && first1._point.isClose(first2._point, epsilon))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1 && first1._point.isClose(last2._point, epsilon)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path._closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.isClose(last._point, epsilon)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
		return this;
	},

	reduce: function(options) {
		var curves = this.getCurves(),
			simplify = options && options.simplify,
			tolerance = simplify ? 1e-7 : 0;
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (!curve.hasHandles() && (!curve.hasLength(tolerance)
					|| simplify && curve.isCollinear(curve.getNext())))
				curve.remove();
		}
		return this;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		this._changed(9);
	},

	flatten: function(flatness) {
		var flattener = new PathFlattener(this, flatness || 0.25, 256, true),
			parts = flattener.parts,
			length = parts.length,
			segments = [];
		for (var i = 0; i < length; i++) {
			segments.push(new Segment(parts[i].curve.slice(0, 2)));
		}
		if (!this._closed && length > 0) {
			segments.push(new Segment(parts[length - 1].curve.slice(6)));
		}
		this.setSegments(segments);
	},

	simplify: function(tolerance) {
		var segments = new PathFitter(this).fit(tolerance || 2.5);
		if (segments)
			this.setSegments(segments);
		return !!segments;
	},

	smooth: function(options) {
		var that = this,
			opts = options || {},
			type = opts.type || 'asymmetric',
			segments = this._segments,
			length = segments.length,
			closed = this._closed;

		function getIndex(value, _default) {
			var index = value && value.index;
			if (index != null) {
				var path = value.path;
				if (path && path !== that)
					throw new Error(value._class + ' ' + index + ' of ' + path
							+ ' is not part of ' + that);
				if (_default && value instanceof Curve)
					index++;
			} else {
				index = typeof value === 'number' ? value : _default;
			}
			return Math.min(index < 0 && closed
					? index % length
					: index < 0 ? index + length : index, length - 1);
		}

		var loop = closed && opts.from === undefined && opts.to === undefined,
			from = getIndex(opts.from, 0),
			to = getIndex(opts.to, length - 1);

		if (from > to) {
			if (closed) {
				from -= length;
			} else {
				var tmp = from;
				from = to;
				to = tmp;
			}
		}
		if (/^(?:asymmetric|continuous)$/.test(type)) {
			var asymmetric = type === 'asymmetric',
				min = Math.min,
				amount = to - from + 1,
				n = amount - 1,
				padding = loop ? min(amount, 4) : 1,
				paddingLeft = padding,
				paddingRight = padding,
				knots = [];
			if (!closed) {
				paddingLeft = min(1, from);
				paddingRight = min(1, length - to - 1);
			}
			n += paddingLeft + paddingRight;
			if (n <= 1)
				return;
			for (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {
				knots[i] = segments[(j < 0 ? j + length : j) % length]._point;
			}

			var x = knots[0]._x + 2 * knots[1]._x,
				y = knots[0]._y + 2 * knots[1]._y,
				f = 2,
				n_1 = n - 1,
				rx = [x],
				ry = [y],
				rf = [f],
				px = [],
				py = [];
			for (var i = 1; i < n; i++) {
				var internal = i < n_1,
					a = internal ? 1 : asymmetric ? 1 : 2,
					b = internal ? 4 : asymmetric ? 2 : 7,
					u = internal ? 4 : asymmetric ? 3 : 8,
					v = internal ? 2 : asymmetric ? 0 : 1,
					m = a / f;
				f = rf[i] = b - m;
				x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;
				y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;
			}

			px[n_1] = rx[n_1] / rf[n_1];
			py[n_1] = ry[n_1] / rf[n_1];
			for (var i = n - 2; i >= 0; i--) {
				px[i] = (rx[i] - px[i + 1]) / rf[i];
				py[i] = (ry[i] - py[i + 1]) / rf[i];
			}
			px[n] = (3 * knots[n]._x - px[n_1]) / 2;
			py[n] = (3 * knots[n]._y - py[n_1]) / 2;

			for (var i = paddingLeft, max = n - paddingRight, j = from;
					i <= max; i++, j++) {
				var segment = segments[j < 0 ? j + length : j],
					pt = segment._point,
					hx = px[i] - pt._x,
					hy = py[i] - pt._y;
				if (loop || i < max)
					segment.setHandleOut(hx, hy);
				if (loop || i > paddingLeft)
					segment.setHandleIn(-hx, -hy);
			}
		} else {
			for (var i = from; i <= to; i++) {
				segments[i < 0 ? i + length : i].smooth(opts,
						!loop && i === from, !loop && i === to);
			}
		}
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isCollinear(i, j) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				seg3 = segments[j],
				seg4 = seg3.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg3._handleOut.isZero() && seg4._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isCollinear(
						seg4._point.subtract(seg3._point));
		}

		function isOrthogonal(i) {
			var seg2 = segments[i],
				seg1 = seg2.getPrevious(),
				seg3 = seg2.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg2._handleOut.isZero() && seg3._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isOrthogonal(
						seg3._point.subtract(seg2._point));
		}

		function isArc(i) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				handle1 = seg1._handleOut,
				handle2 = seg2._handleIn,
				kappa = 0.5522847498307936;
			if (handle1.isOrthogonal(handle2)) {
				var pt1 = seg1._point,
					pt2 = seg2._point,
					corner = new Line(pt1, handle1, true).intersect(
							new Line(pt2, handle2, true), true);
				return corner && Numerical.isZero(handle1.getLength() /
						corner.subtract(pt1).getLength() - kappa)
					&& Numerical.isZero(handle2.getLength() /
						corner.subtract(pt2).getLength() - kappa);
			}
			return false;
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (!this.hasHandles() && segments.length === 4
				&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				});
			shape.copyAttributes(this, true);
			shape._matrix.prepend(this._matrix);
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			if (insert === undefined || insert)
				shape.insertAbove(this);
			return shape;
		}
		return null;
	},

	toPath: '#clone',

	compare: function compare(path) {
		if (!path || path instanceof CompoundPath)
			return compare.base.call(this, path);
		var curves1 = this.getCurves(),
			curves2 = path.getCurves(),
			length1 = curves1.length,
			length2 = curves2.length;
		if (!length1 || !length2) {
			return length1 == length2;
		}
		var v1 = curves1[0].getValues(),
			values2 = [],
			pos1 = 0, pos2,
			end1 = 0, end2;
		for (var i = 0; i < length2; i++) {
			var v2 = curves2[i].getValues();
			values2.push(v2);
			var overlaps = Curve.getOverlaps(v1, v2);
			if (overlaps) {
				pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;
				end2 = overlaps[0][1];
				break;
			}
		}
		var abs = Math.abs,
			epsilon = 1e-8,
			v2 = values2[pos2],
			start2;
		while (v1 && v2) {
			var overlaps = Curve.getOverlaps(v1, v2);
			if (overlaps) {
				var t1 = overlaps[0][0];
				if (abs(t1 - end1) < epsilon) {
					end1 = overlaps[1][0];
					if (end1 === 1) {
						v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
						end1 = 0;
					}
					var t2 = overlaps[0][1];
					if (abs(t2 - end2) < epsilon) {
						if (!start2)
							start2 = [pos2, t2];
						end2 = overlaps[1][1];
						if (end2 === 1) {
							if (++pos2 >= length2)
								pos2 = 0;
							v2 = values2[pos2] || curves2[pos2].getValues();
							end2 = 0;
						}
						if (!v1) {
							return start2[0] === pos2 && start2[1] === end2;
						}
						continue;
					}
				}
			}
			break;
		}
		return false;
	},

	_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && (style.hasStroke() || options.hitUnstrokedPaths),
			hitFill = options.fill && (style.hasFill() || options.hitUnfilledPaths),
			hitCurves = options.curves,
			strokeRadius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (strokeRadius !== null) {
			if (strokeRadius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = style.getMiterLimit();
				strokePadding = strokePadding.add(
					Path._getStrokePadding(strokeRadius, strokeMatrix));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			var isJoin = closed || segment._index > 0
					&& segment._index < numSegments - 1;
			if ((isJoin ? join : cap) === 'round') {
				return isCloseEnough(segment._point, strokePadding);
			} else {
				area = new Path({ internal: true, closed: true });
				if (isJoin) {
					if (!segment.isSmooth()) {
						Path._addBevelJoin(segment, join, strokeRadius,
							   miterLimit, null, strokeMatrix, addToArea, true);
					}
				} else if (cap === 'square') {
					Path._addSquareCap(segment, cap, strokeRadius, null,
							strokeMatrix, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (strokeRadius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var time = loc.getTime();
				if (time === 0 || time === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point)
							<= miterLimit * strokeRadius
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(Curve._evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset) {
			var loc = this.getLocationAt(offset);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset) {
		if (typeof offset === 'number') {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++) {
				var start = length,
					curve = curves[i];
				length += curve.getLength();
				if (length > offset) {
					return curve.getLocationAt(offset - start);
				}
			}
			if (curves.length > 0 && offset <= this.getLength()) {
				return new CurveLocation(curves[curves.length - 1], 1);
			}
		} else if (offset && offset.getPath && offset.getPath() === this) {
			return offset;
		}
		return null;
	},

	getOffsetsWithTangent: function() {
		var tangent = Point.read(arguments);
		if (tangent.isZero()) {
			return [];
		}

		var offsets = [];
		var curveStart = 0;
		var curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var curve = curves[i];
			var curveTimes = curve.getTimesWithTangent(tangent);
			for (var j = 0, m = curveTimes.length; j < m; j++) {
				var offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);
				if (offsets.indexOf(offset) < 0) {
					offsets.push(offset);
				}
			}
			curveStart += curve.length;
		}
		return offsets;
	}
}),
new function() {

	function drawHandles(ctx, segments, matrix, size, isFullySelected) {
		if (size <= 0) return;

		var half = size / 2,
			coords = new Array(6),
			pX, pY;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.moveTo(hX - half, hY);
				ctx.lineTo(hX, hY + half);
				ctx.lineTo(hX + half, hY);
				ctx.lineTo(hX, hY - half);
				ctx.closePath();
				ctx.stroke();
			}
		}

		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i],
				selection = segment._selection;
			segment._transformCoordinates(matrix, coords);
			pX = coords[0];
			pY = coords[1];
			if (selection & 2 && !isFullySelected)
				drawHandle(2);
			if (selection & 4 && !isFullySelected)
				drawHandle(4);
			ctx.beginPath();
			ctx.arc(pX, pY, half, 0, Math.PI * 2, true);
			ctx.stroke();
			var fillStyle = ctx.fillStyle;
			if (!(selection & 1)) {
				ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
			}
			ctx.fill();
			ctx.fillStyle = fillStyle;
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, viewMatrix, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx, param, viewMatrix, strokeMatrix);
				if (hasFill) {
					ctx.fill(style.getFillRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var flattener = new PathFlattener(this, 0.25, 32, false,
								strokeMatrix),
							length = flattener.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								flattener.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize,
				this.isFullySelected());
		}
	};
},
new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (!segments.length)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var args = arguments,
				handle1 = Point.read(args),
				handle2 = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var args = arguments,
				handle = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var args = arguments,
				through = Point.read(args),
				to = Point.read(args),
				t = Base.pick(Base.read(args), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var args = arguments,
				abs = Math.abs,
				sqrt = Math.sqrt,
				current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(args),
				through,
				peek = Base.peek(args),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(args) <= 2) {
				through = to;
				to = Point.read(args);
			} else if (!from.equals(to)) {
				var radius = Size.read(args),
					isZero = Numerical.isZero;
				if (isZero(radius.width) || isZero(radius.height))
					return this.lineTo(to);
				var rotation = Base.read(args),
					clockwise = !!Base.read(args),
					large = !!Base.read(args),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq = x * x,
					ySq = y * y;
				var factor = sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < 1e-12)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1) * sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center, true);
				if (centerSide === 0) {
					extent = throughSide * abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			if (extent) {
				var epsilon = 1e-7,
					ext = abs(extent),
					count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),
					inc = extent / count,
					half = inc * Math.PI / 360,
					z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
					segments = [];
				for (var i = 0; i <= count; i++) {
					var pt = to,
						out = null;
					if (i < count) {
						out = vector.rotate(90).multiply(z);
						if (matrix) {
							pt = matrix._transformPoint(vector);
							out = matrix._transformPoint(vector.add(out))
									.subtract(pt);
						} else {
							pt = center.add(vector);
						}
					}
					if (!i) {
						current.setHandleOut(out);
					} else {
						var _in = vector.rotate(-90).multiply(z);
						if (matrix) {
							_in = matrix._transformPoint(vector.add(_in))
									.subtract(pt);
						}
						segments.push(new Segment(pt, _in, out));
					}
					vector = vector.rotate(inc);
				}
				this._add(segments);
			}
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var args = arguments,
				through = Point.read(args),
				to = Point.read(args),
				parameter = Base.read(args),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var args = arguments,
				handle1 = Point.read(args),
				handle2 = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var args = arguments,
				handle = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var args = arguments,
				current = getCurrentSegment(this)._point,
				point = current.add(Point.read(args)),
				clockwise = Base.pick(Base.peek(args), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(args)));
			}
		},

		closePath: function(tolerance) {
			this.setClosed(true);
			this.join(this, tolerance);
		}
	};
}, {

	_getBounds: function(matrix, options) {
		var method = options.handle
				? 'getHandleBounds'
				: options.stroke
				? 'getStrokeBounds'
				: 'getBounds';
		return Path[method](this._segments, this._closed, this, matrix, options);
	},

statics: {
	getBounds: function(segments, closed, path, matrix, options, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6)),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, path, matrix, options) {
		var style = path.getStyle(),
			stroke = style.hasStroke(),
			strokeWidth = style.getStrokeWidth(),
			strokeMatrix = stroke && path._getStrokeMatrix(matrix, options),
			strokePadding = stroke && Path._getStrokePadding(strokeWidth,
				strokeMatrix),
			bounds = Path.getBounds(segments, closed, path, matrix, options,
				strokePadding);
		if (!stroke)
			return bounds;
		var strokeRadius = strokeWidth / 2,
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = style.getMiterLimit(),
			joinBounds = new Rectangle(new Size(strokePadding));

		function addPoint(point) {
			bounds = bounds.include(point);
		}

		function addRound(segment) {
			bounds = bounds.unite(
					joinBounds.setCenter(segment._point.transform(matrix)));
		}

		function addJoin(segment, join) {
			if (join === 'round' || segment.isSmooth()) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, strokeRadius, miterLimit,
						matrix, strokeMatrix, addPoint);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, strokeRadius, matrix,
						strokeMatrix, addPoint);
			}
		}

		var length = segments.length - (closed ? 0 : 1);
		if (length > 0) {
			for (var i = 1; i < length; i++) {
				addJoin(segments[i], join);
			}
			if (closed) {
				addJoin(segments[0], join);
			} else {
				addCap(segments[0], cap);
				addCap(segments[segments.length - 1], cap);
			}
		}
		return bounds;
	},

	_getStrokePadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var hor = new Point(radius, 0).transform(matrix),
			ver = new Point(0, radius).transform(matrix),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = Math.atan2(b * tan, a),
			ty = Math.atan2(b, tan * a);
		return [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, matrix,
			strokeMatrix, addPoint, isArea) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPoint1().transform(matrix),
			normal1 = curve1.getNormalAtTime(1).multiply(radius)
				.transform(strokeMatrix),
			normal2 = curve2.getNormalAtTime(0).multiply(radius)
				.transform(strokeMatrix),
				angle = normal1.getDirectedAngle(normal2);
		if (angle < 0 || angle >= 180) {
			normal1 = normal1.negate();
			normal2 = normal2.negate();
		}
		if (isArea)
			addPoint(point);
		addPoint(point.add(normal1));
		if (join === 'miter') {
			var corner = new Line(point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit * radius) {
				addPoint(corner);
			}
		}
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,
			addPoint, isArea) {
		var point = segment._point.transform(matrix),
			loc = segment.getLocation(),
			normal = loc.getNormal()
					.multiply(loc.getTime() === 0 ? radius : -radius)
					.transform(strokeMatrix);
		if (cap === 'square') {
			if (isArea) {
				addPoint(point.subtract(normal));
				addPoint(point.add(normal));
			}
			point = point.add(normal.rotate(-90));
		}
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, path, matrix, options) {
		var style = path.getStyle(),
			stroke = options.stroke && style.hasStroke(),
			strokePadding,
			joinPadding;
		if (stroke) {
			var strokeMatrix = path._getStrokeMatrix(matrix, options),
				strokeRadius = style.getStrokeWidth() / 2,
				joinRadius = strokeRadius;
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
			strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
			joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
		}
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords);
			for (var j = 0; j < 6; j += 2) {
				var padding = !j ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert == false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props, { insert: true });
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			var args = arguments;
			return createPath([
				new Segment(Point.readNamed(args, 'from')),
				new Segment(Point.readNamed(args, 'to'))
			], false, args);
		},

		Circle: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				radius = Base.readNamed(args, 'radius');
			return createEllipse(center, new Size(radius), args);
		},

		Rectangle: function() {
			var args = arguments,
				rect = Rectangle.readNamed(args, 'rectangle'),
				radius = Size.readNamed(args, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, args);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var args = arguments,
				ellipse = Shape._readEllipse(args);
			return createEllipse(ellipse.center, ellipse.radius, args);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var args = arguments,
				from = Point.readNamed(args, 'from'),
				through = Point.readNamed(args, 'through'),
				to = Point.readNamed(args, 'to'),
				props = Base.getNamed(args),
				path = new Path(props && props.insert == false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				sides = Base.readNamed(args, 'sides'),
				radius = Base.readNamed(args, 'radius'),
				step = 360 / sides,
				three = sides % 3 === 0,
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, args);
		},

		Star: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				points = Base.readNamed(args, 'points') * 2,
				radius1 = Base.readNamed(args, 'radius1'),
				radius2 = Base.readNamed(args, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, args);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},
	beans: true,

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items) {
		var list = items,
			first = list[0];
		if (first && typeof first[0] === 'number')
			list = [list];
		for (var i = items.length - 1; i >= 0; i--) {
			var item = list[i];
			if (list === items && !(item instanceof Path))
				list = Base.slice(list);
			if (Array.isArray(item)) {
				list[i] = new Path({ segments: item, insert: false });
			} else if (item instanceof CompoundPath) {
				list.splice.apply(list, [i, 1].concat(item.removeChildren()));
				item.remove();
			}
		}
		return insertChildren.base.call(this, index, list);
	},

	reduce: function reduce(options) {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--) {
			var path = children[i].reduce(options);
			if (path.isEmpty())
				path.remove();
		}
		if (!children.length) {
			var path = new Path(Item.NO_INSERT);
			path.copyAttributes(this);
			path.insertAbove(this);
			this.remove();
			return path;
		}
		return reduce.base.call(this);
	},

	isClosed: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			if (!children[i]._closed)
				return false;
		}
		return true;
	},

	setClosed: function(closed) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			children[i].setClosed(closed);
		}
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++) {
			Base.push(curves, children[i].getCurves());
		}
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getLastCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	},

	getLength: function() {
		var children = this._children,
			length = 0;
		for (var i = 0, l = children.length; i < l; i++)
			length += children[i].getLength();
		return length;
	},

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.appended(mx) : _matrix, _precision));
		}
		return paths.join('');
	},

	_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
		return _hitTestChildren.base.call(this, point,
				options.class === Path || options.type === 'path' || options.hitUnfilledPaths ? options
					: Base.set({}, options, { fill: false }),
				viewMatrix);
	},

	_draw: function(ctx, param, viewMatrix, strokeMatrix) {
		var children = this._children;
		if (!children.length)
			return;

		param = param.extend({ dontStart: true, dontFinish: true });
		ctx.beginPath();
		for (var i = 0, l = children.length; i < l; i++)
			children[i].draw(ctx, param, strokeMatrix);

		if (!param.clip) {
			this._setStyles(ctx, param, viewMatrix, strokeMatrix);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getFillRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectionItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectionItems[child._id]) {
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.appended(mx));
			}
		}
	}
},
new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && !children.length)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	return Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',
			'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',
			'arcBy'],
		function(key) {
			this[key] = function() {
				var path = getCurrentPath(this, true);
				path[key].apply(path, arguments);
			};
		}, {
			moveTo: function() {
				var current = getCurrentPath(this),
					path = current && current.isEmpty() ? current
							: new Path(Item.NO_INSERT);
				if (path !== current)
					this.addChild(path);
				path.moveTo.apply(path, arguments);
			},

			moveBy: function() {
				var current = getCurrentPath(this, true),
					last = current && current.getLastSegment(),
					point = Point.read(arguments);
				this.moveTo(last ? point.add(last._point) : point);
			},

			closePath: function(tolerance) {
				getCurrentPath(this, true).closePath(tolerance);
			}
		}
	);
}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {
	this[key] = function(param) {
		var children = this._children,
			res;
		for (var i = 0, l = children.length; i < l; i++) {
			res = children[i][key](param) || res;
		}
		return res;
	};
}, {}));

PathItem.inject(new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		operators = {
			unite:     { '1': true, '2': true },
			intersect: { '2': true },
			subtract:  { '1': true },
			exclude:   { '1': true, '-1': true }
		};

	function getPaths(path) {
		return path._children || [path];
	}

	function preparePath(path, resolve) {
		var res = path
			.clone(false)
			.reduce({ simplify: true })
			.transform(null, true, true);
		if (resolve) {
			var paths = getPaths(res);
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				if (!path._closed && !path.isEmpty()) {
					path.closePath(1e-12);
					path.getFirstSegment().setHandleIn(0, 0);
					path.getLastSegment().setHandleOut(0, 0);
				}
			}
			res = res
				.resolveCrossings()
				.reorient(res.getFillRule() === 'nonzero', true);
		}
		return res;
	}

	function createResult(paths, simplify, path1, path2, options) {
		var result = new CompoundPath(Item.NO_INSERT);
		result.addChildren(paths, true);
		result = result.reduce({ simplify: simplify });
		if (!(options && options.insert == false)) {
			result.insertAbove(path2 && path1.isSibling(path2)
					&& path1.getIndex() < path2.getIndex() ? path2 : path1);
		}
		result.copyAttributes(path1, true);
		return result;
	}

	function filterIntersection(inter) {
		return inter.hasOverlap() || inter.isCrossing();
	}

	function traceBoolean(path1, path2, operation, options) {
		if (options && (options.trace == false || options.stroke) &&
				/^(subtract|intersect)$/.test(operation))
			return splitBoolean(path1, path2, operation);
		var _path1 = preparePath(path1, true),
			_path2 = path2 && path1 !== path2 && preparePath(path2, true),
			operator = operators[operation];
		operator[operation] = true;
		if (_path2 && (operator.subtract || operator.exclude)
				^ (_path2.isClockwise() ^ _path1.isClockwise()))
			_path2.reverse();
		var crossings = divideLocations(CurveLocation.expand(
				_path1.getIntersections(_path2, filterIntersection))),
			paths1 = getPaths(_path1),
			paths2 = _path2 && getPaths(_path2),
			segments = [],
			curves = [],
			paths;

		function collectPaths(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				Base.push(segments, path._segments);
				Base.push(curves, path.getCurves());
				path._overlapsOnly = true;
			}
		}

		function getCurves(indices) {
			var list = [];
			for (var i = 0, l = indices && indices.length; i < l; i++) {
				list.push(curves[indices[i]]);
			}
			return list;
		}

		if (crossings.length) {
			collectPaths(paths1);
			if (paths2)
				collectPaths(paths2);

			var curvesValues = new Array(curves.length);
			for (var i = 0, l = curves.length; i < l; i++) {
				curvesValues[i] = curves[i].getValues();
			}
			var curveCollisions = CollisionDetection.findCurveBoundsCollisions(
					curvesValues, curvesValues, 0, true);
			var curveCollisionsMap = {};
			for (var i = 0; i < curves.length; i++) {
				var curve = curves[i],
					id = curve._path._id,
					map = curveCollisionsMap[id] = curveCollisionsMap[id] || {};
				map[curve.getIndex()] = {
					hor: getCurves(curveCollisions[i].hor),
					ver: getCurves(curveCollisions[i].ver)
				};
			}

			for (var i = 0, l = crossings.length; i < l; i++) {
				propagateWinding(crossings[i]._segment, _path1, _path2,
						curveCollisionsMap, operator);
			}
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i],
					inter = segment._intersection;
				if (!segment._winding) {
					propagateWinding(segment, _path1, _path2,
							curveCollisionsMap, operator);
				}
				if (!(inter && inter._overlap))
					segment._path._overlapsOnly = false;
			}
			paths = tracePaths(segments, operator);
		} else {
			paths = reorientPaths(
					paths2 ? paths1.concat(paths2) : paths1.slice(),
					function(w) {
						return !!operator[w];
					});
		}
		return createResult(paths, true, path1, path2, options);
	}

	function splitBoolean(path1, path2, operation) {
		var _path1 = preparePath(path1),
			_path2 = preparePath(path2),
			crossings = _path1.getIntersections(_path2, filterIntersection),
			subtract = operation === 'subtract',
			divide = operation === 'divide',
			added = {},
			paths = [];

		function addPath(path) {
			if (!added[path._id] && (divide ||
					_path2.contains(path.getPointAt(path.getLength() / 2))
						^ subtract)) {
				paths.unshift(path);
				return added[path._id] = true;
			}
		}

		for (var i = crossings.length - 1; i >= 0; i--) {
			var path = crossings[i].split();
			if (path) {
				if (addPath(path))
					path.getFirstSegment().setHandleIn(0, 0);
				_path1.getLastSegment().setHandleOut(0, 0);
			}
		}
		addPath(_path1);
		return createResult(paths, false, path1, path2);
	}

	function linkIntersections(from, to) {
		var prev = from;
		while (prev) {
			if (prev === to)
				return;
			prev = prev._previous;
		}
		while (from._next && from._next !== to)
			from = from._next;
		if (!from._next) {
			while (to._previous)
				to = to._previous;
			from._next = to;
			to._previous = from;
		}
	}

	function clearCurveHandles(curves) {
		for (var i = curves.length - 1; i >= 0; i--)
			curves[i].clearHandles();
	}

	function reorientPaths(paths, isInside, clockwise) {
		var length = paths && paths.length;
		if (length) {
			var lookup = Base.each(paths, function (path, i) {
					this[path._id] = {
						container: null,
						winding: path.isClockwise() ? 1 : -1,
						index: i
					};
				}, {}),
				sorted = paths.slice().sort(function (a, b) {
					return abs(b.getArea()) - abs(a.getArea());
				}),
				first = sorted[0];
			var collisions = CollisionDetection.findItemBoundsCollisions(sorted,
					null, Numerical.GEOMETRIC_EPSILON);
			if (clockwise == null)
				clockwise = first.isClockwise();
			for (var i = 0; i < length; i++) {
				var path1 = sorted[i],
					entry1 = lookup[path1._id],
					containerWinding = 0,
					indices = collisions[i];
				if (indices) {
					var point = null;
					for (var j = indices.length - 1; j >= 0; j--) {
						if (indices[j] < i) {
							point = point || path1.getInteriorPoint();
							var path2 = sorted[indices[j]];
							if (path2.contains(point)) {
								var entry2 = lookup[path2._id];
								containerWinding = entry2.winding;
								entry1.winding += containerWinding;
								entry1.container = entry2.exclude
									? entry2.container : path2;
								break;
							}
						}
					}
				}
				if (isInside(entry1.winding) === isInside(containerWinding)) {
					entry1.exclude = true;
					paths[entry1.index] = null;
				} else {
					var container = entry1.container;
					path1.setClockwise(
							container ? !container.isClockwise() : clockwise);
				}
			}
		}
		return paths;
	}

	function divideLocations(locations, include, clearLater) {
		var results = include && [],
			tMin = 1e-8,
			tMax = 1 - tMin,
			clearHandles = false,
			clearCurves = clearLater || [],
			clearLookup = clearLater && {},
			renormalizeLocs,
			prevCurve,
			prevTime;

		function getId(curve) {
			return curve._path._id + '.' + curve._segment1._index;
		}

		for (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {
			var curve = clearLater[i];
			if (curve._path)
				clearLookup[getId(curve)] = true;
		}

		for (var i = locations.length - 1; i >= 0; i--) {
			var loc = locations[i],
				time = loc._time,
				origTime = time,
				exclude = include && !include(loc),
				curve = loc._curve,
				segment;
			if (curve) {
				if (curve !== prevCurve) {
					clearHandles = !curve.hasHandles()
							|| clearLookup && clearLookup[getId(curve)];
					renormalizeLocs = [];
					prevTime = null;
					prevCurve = curve;
				} else if (prevTime >= tMin) {
					time /= prevTime;
				}
			}
			if (exclude) {
				if (renormalizeLocs)
					renormalizeLocs.push(loc);
				continue;
			} else if (include) {
				results.unshift(loc);
			}
			prevTime = origTime;
			if (time < tMin) {
				segment = curve._segment1;
			} else if (time > tMax) {
				segment = curve._segment2;
			} else {
				var newCurve = curve.divideAtTime(time, true);
				if (clearHandles)
					clearCurves.push(curve, newCurve);
				segment = newCurve._segment1;
				for (var j = renormalizeLocs.length - 1; j >= 0; j--) {
					var l = renormalizeLocs[j];
					l._time = (l._time - time) / (1 - time);
				}
			}
			loc._setSegment(segment);
			var inter = segment._intersection,
				dest = loc._intersection;
			if (inter) {
				linkIntersections(inter, dest);
				var other = inter;
				while (other) {
					linkIntersections(other._intersection, inter);
					other = other._next;
				}
			} else {
				segment._intersection = dest;
			}
		}
		if (!clearLater)
			clearCurveHandles(clearCurves);
		return results || locations;
	}

	function getWinding(point, curves, dir, closed, dontFlip) {
		var curvesList = Array.isArray(curves)
			? curves
			: curves[dir ? 'hor' : 'ver'];
		var ia = dir ? 1 : 0,
			io = ia ^ 1,
			pv = [point.x, point.y],
			pa = pv[ia],
			po = pv[io],
			windingEpsilon = 1e-9,
			qualityEpsilon = 1e-6,
			paL = pa - windingEpsilon,
			paR = pa + windingEpsilon,
			windingL = 0,
			windingR = 0,
			pathWindingL = 0,
			pathWindingR = 0,
			onPath = false,
			onAnyPath = false,
			quality = 1,
			roots = [],
			vPrev,
			vClose;

		function addWinding(v) {
			var o0 = v[io + 0],
				o3 = v[io + 6];
			if (po < min(o0, o3) || po > max(o0, o3)) {
				return;
			}
			var a0 = v[ia + 0],
				a1 = v[ia + 2],
				a2 = v[ia + 4],
				a3 = v[ia + 6];
			if (o0 === o3) {
				if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
					onPath = true;
				}
				return;
			}
			var t =   po === o0 ? 0
					: po === o3 ? 1
					: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)
					? 1
					: Curve.solveCubic(v, io, po, roots, 0, 1) > 0
						? roots[0]
						: 1,
				a =   t === 0 ? a0
					: t === 1 ? a3
					: Curve.getPoint(v, t)[dir ? 'y' : 'x'],
				winding = o0 > o3 ? 1 : -1,
				windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,
				a3Prev = vPrev[ia + 6];
			if (po !== o0) {
				if (a < paL) {
					pathWindingL += winding;
				} else if (a > paR) {
					pathWindingR += winding;
				} else {
					onPath = true;
				}
				if (a > pa - qualityEpsilon && a < pa + qualityEpsilon)
					quality /= 2;
			} else {
				if (winding !== windingPrev) {
					if (a0 < paL) {
						pathWindingL += winding;
					} else if (a0 > paR) {
						pathWindingR += winding;
					}
				} else if (a0 != a3Prev) {
					if (a3Prev < paR && a > paR) {
						pathWindingR += winding;
						onPath = true;
					} else if (a3Prev > paL && a < paL) {
						pathWindingL += winding;
						onPath = true;
					}
				}
				quality /= 4;
			}
			vPrev = v;
			return !dontFlip && a > paL && a < paR
					&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0
					&& getWinding(point, curves, !dir, closed, true);
		}

		function handleCurve(v) {
			var o0 = v[io + 0],
				o1 = v[io + 2],
				o2 = v[io + 4],
				o3 = v[io + 6];
			if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {
				var a0 = v[ia + 0],
					a1 = v[ia + 2],
					a2 = v[ia + 4],
					a3 = v[ia + 6],
					monoCurves = paL > max(a0, a1, a2, a3) ||
								 paR < min(a0, a1, a2, a3)
							? [v] : Curve.getMonoCurves(v, dir),
					res;
				for (var i = 0, l = monoCurves.length; i < l; i++) {
					if (res = addWinding(monoCurves[i]))
						return res;
				}
			}
		}

		for (var i = 0, l = curvesList.length; i < l; i++) {
			var curve = curvesList[i],
				path = curve._path,
				v = curve.getValues(),
				res;
			if (!i || curvesList[i - 1]._path !== path) {
				vPrev = null;
				if (!path._closed) {
					vClose = Curve.getValues(
							path.getLastCurve().getSegment2(),
							curve.getSegment1(),
							null, !closed);
					if (vClose[io] !== vClose[io + 6]) {
						vPrev = vClose;
					}
				}

				if (!vPrev) {
					vPrev = v;
					var prev = path.getLastCurve();
					while (prev && prev !== curve) {
						var v2 = prev.getValues();
						if (v2[io] !== v2[io + 6]) {
							vPrev = v2;
							break;
						}
						prev = prev.getPrevious();
					}
				}
			}

			if (res = handleCurve(v))
				return res;

			if (i + 1 === l || curvesList[i + 1]._path !== path) {
				if (vClose && (res = handleCurve(vClose)))
					return res;
				if (onPath && !pathWindingL && !pathWindingR) {
					pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir
							? 1 : -1;
				}
				windingL += pathWindingL;
				windingR += pathWindingR;
				pathWindingL = pathWindingR = 0;
				if (onPath) {
					onAnyPath = true;
					onPath = false;
				}
				vClose = null;
			}
		}
		windingL = abs(windingL);
		windingR = abs(windingR);
		return {
			winding: max(windingL, windingR),
			windingL: windingL,
			windingR: windingR,
			quality: quality,
			onPath: onAnyPath
		};
	}

	function propagateWinding(segment, path1, path2, curveCollisionsMap,
			operator) {
		var chain = [],
			start = segment,
			totalLength = 0,
			winding;
		do {
			var curve = segment.getCurve();
			if (curve) {
				var length = curve.getLength();
				chain.push({ segment: segment, curve: curve, length: length });
				totalLength += length;
			}
			segment = segment.getNext();
		} while (segment && !segment._intersection && segment !== start);
		var offsets = [0.5, 0.25, 0.75],
			winding = { winding: 0, quality: -1 },
			tMin = 1e-3,
			tMax = 1 - tMin;
		for (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {
			var length = totalLength * offsets[i];
			for (var j = 0, l = chain.length; j < l; j++) {
				var entry = chain[j],
					curveLength = entry.length;
				if (length <= curveLength) {
					var curve = entry.curve,
						path = curve._path,
						parent = path._parent,
						operand = parent instanceof CompoundPath ? parent : path,
						t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),
						pt = curve.getPointAtTime(t),
						dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;
					var wind = null;
					if (operator.subtract && path2) {
						var otherPath = operand === path1 ? path2 : path1,
							pathWinding = otherPath._getWinding(pt, dir, true);
						if (operand === path1 && pathWinding.winding ||
							operand === path2 && !pathWinding.winding) {
							if (pathWinding.quality < 1) {
								continue;
							} else {
								wind = { winding: 0, quality: 1 };
							}
						}
					}
					wind =  wind || getWinding(
							pt, curveCollisionsMap[path._id][curve.getIndex()],
							dir, true);
					if (wind.quality > winding.quality)
						winding = wind;
					break;
				}
				length -= curveLength;
			}
		}
		for (var j = chain.length - 1; j >= 0; j--) {
			chain[j].segment._winding = winding;
		}
	}

	function tracePaths(segments, operator) {
		var paths = [],
			starts;

		function isValid(seg) {
			var winding;
			return !!(seg && !seg._visited && (!operator
					|| operator[(winding = seg._winding || {}).winding]
						&& !(operator.unite && winding.winding === 2
							&& winding.windingL && winding.windingR)));
		}

		function isStart(seg) {
			if (seg) {
				for (var i = 0, l = starts.length; i < l; i++) {
					if (seg === starts[i])
						return true;
				}
			}
			return false;
		}

		function visitPath(path) {
			var segments = path._segments;
			for (var i = 0, l = segments.length; i < l; i++) {
				segments[i]._visited = true;
			}
		}

		function getCrossingSegments(segment, collectStarts) {
			var inter = segment._intersection,
				start = inter,
				crossings = [];
			if (collectStarts)
				starts = [segment];

			function collect(inter, end) {
				while (inter && inter !== end) {
					var other = inter._segment,
						path = other && other._path;
					if (path) {
						var next = other.getNext() || path.getFirstSegment(),
							nextInter = next._intersection;
						if (other !== segment && (isStart(other)
							|| isStart(next)
							|| next && (isValid(other) && (isValid(next)
								|| nextInter && isValid(nextInter._segment))))
						) {
							crossings.push(other);
						}
						if (collectStarts)
							starts.push(other);
					}
					inter = inter._next;
				}
			}

			if (inter) {
				collect(inter);
				while (inter && inter._previous)
					inter = inter._previous;
				collect(inter, start);
			}
			return crossings;
		}

		segments.sort(function(seg1, seg2) {
			var inter1 = seg1._intersection,
				inter2 = seg2._intersection,
				over1 = !!(inter1 && inter1._overlap),
				over2 = !!(inter2 && inter2._overlap),
				path1 = seg1._path,
				path2 = seg2._path;
			return over1 ^ over2
					? over1 ? 1 : -1
					: !inter1 ^ !inter2
						? inter1 ? 1 : -1
						: path1 !== path2
							? path1._id - path2._id
							: seg1._index - seg2._index;
		});

		for (var i = 0, l = segments.length; i < l; i++) {
			var seg = segments[i],
				valid = isValid(seg),
				path = null,
				finished = false,
				closed = true,
				branches = [],
				branch,
				visited,
				handleIn;
			if (valid && seg._path._overlapsOnly) {
				var path1 = seg._path,
					path2 = seg._intersection._segment._path;
				if (path1.compare(path2)) {
					if (path1.getArea())
						paths.push(path1.clone(false));
					visitPath(path1);
					visitPath(path2);
					valid = false;
				}
			}
			while (valid) {
				var first = !path,
					crossings = getCrossingSegments(seg, first),
					other = crossings.shift(),
					finished = !first && (isStart(seg) || isStart(other)),
					cross = !finished && other;
				if (first) {
					path = new Path(Item.NO_INSERT);
					branch = null;
				}
				if (finished) {
					if (seg.isFirst() || seg.isLast())
						closed = seg._path._closed;
					seg._visited = true;
					break;
				}
				if (cross && branch) {
					branches.push(branch);
					branch = null;
				}
				if (!branch) {
					if (cross)
						crossings.push(seg);
					branch = {
						start: path._segments.length,
						crossings: crossings,
						visited: visited = [],
						handleIn: handleIn
					};
				}
				if (cross)
					seg = other;
				if (!isValid(seg)) {
					path.removeSegments(branch.start);
					for (var j = 0, k = visited.length; j < k; j++) {
						visited[j]._visited = false;
					}
					visited.length = 0;
					do {
						seg = branch && branch.crossings.shift();
						if (!seg || !seg._path) {
							seg = null;
							branch = branches.pop();
							if (branch) {
								visited = branch.visited;
								handleIn = branch.handleIn;
							}
						}
					} while (branch && !isValid(seg));
					if (!seg)
						break;
				}
				var next = seg.getNext();
				path.add(new Segment(seg._point, handleIn,
						next && seg._handleOut));
				seg._visited = true;
				visited.push(seg);
				seg = next || seg._path.getFirstSegment();
				handleIn = next && next._handleIn;
			}
			if (finished) {
				if (closed) {
					path.getFirstSegment().setHandleIn(handleIn);
					path.setClosed(closed);
				}
				if (path.getArea() !== 0) {
					paths.push(path);
				}
			}
		}
		return paths;
	}

	return {
		_getWinding: function(point, dir, closed) {
			return getWinding(point, this.getCurves(), dir, closed);
		},

		unite: function(path, options) {
			return traceBoolean(this, path, 'unite', options);
		},

		intersect: function(path, options) {
			return traceBoolean(this, path, 'intersect', options);
		},

		subtract: function(path, options) {
			return traceBoolean(this, path, 'subtract', options);
		},

		exclude: function(path, options) {
			return traceBoolean(this, path, 'exclude', options);
		},

		divide: function(path, options) {
			return options && (options.trace == false || options.stroke)
					? splitBoolean(this, path, 'divide')
					: createResult([
						this.subtract(path, options),
						this.intersect(path, options)
					], true, this, path, options);
		},

		resolveCrossings: function() {
			var children = this._children,
				paths = children || [this];

			function hasOverlap(seg, path) {
				var inter = seg && seg._intersection;
				return inter && inter._overlap && inter._path === path;
			}

			var hasOverlaps = false,
				hasCrossings = false,
				intersections = this.getIntersections(null, function(inter) {
					return inter.hasOverlap() && (hasOverlaps = true) ||
							inter.isCrossing() && (hasCrossings = true);
				}),
				clearCurves = hasOverlaps && hasCrossings && [];
			intersections = CurveLocation.expand(intersections);
			if (hasOverlaps) {
				var overlaps = divideLocations(intersections, function(inter) {
					return inter.hasOverlap();
				}, clearCurves);
				for (var i = overlaps.length - 1; i >= 0; i--) {
					var overlap = overlaps[i],
						path = overlap._path,
						seg = overlap._segment,
						prev = seg.getPrevious(),
						next = seg.getNext();
					if (hasOverlap(prev, path) && hasOverlap(next, path)) {
						seg.remove();
						prev._handleOut._set(0, 0);
						next._handleIn._set(0, 0);
						if (prev !== seg && !prev.getCurve().hasLength()) {
							next._handleIn.set(prev._handleIn);
							prev.remove();
						}
					}
				}
			}
			if (hasCrossings) {
				divideLocations(intersections, hasOverlaps && function(inter) {
					var curve1 = inter.getCurve(),
						seg1 = inter.getSegment(),
						other = inter._intersection,
						curve2 = other._curve,
						seg2 = other._segment;
					if (curve1 && curve2 && curve1._path && curve2._path)
						return true;
					if (seg1)
						seg1._intersection = null;
					if (seg2)
						seg2._intersection = null;
				}, clearCurves);
				if (clearCurves)
					clearCurveHandles(clearCurves);
				paths = tracePaths(Base.each(paths, function(path) {
					Base.push(this, path._segments);
				}, []));
			}
			var length = paths.length,
				item;
			if (length > 1 && children) {
				if (paths !== children)
					this.setChildren(paths);
				item = this;
			} else if (length === 1 && !children) {
				if (paths[0] !== this)
					this.setSegments(paths[0].removeSegments());
				item = this;
			}
			if (!item) {
				item = new CompoundPath(Item.NO_INSERT);
				item.addChildren(paths);
				item = item.reduce();
				item.copyAttributes(this);
				this.replaceWith(item);
			}
			return item;
		},

		reorient: function(nonZero, clockwise) {
			var children = this._children;
			if (children && children.length) {
				this.setChildren(reorientPaths(this.removeChildren(),
						function(w) {
							return !!(nonZero ? w : w & 1);
						},
						clockwise));
			} else if (clockwise !== undefined) {
				this.setClockwise(clockwise);
			}
			return this;
		},

		getInteriorPoint: function() {
			var bounds = this.getBounds(),
				point = bounds.getCenter(true);
			if (!this.contains(point)) {
				var curves = this.getCurves(),
					y = point.y,
					intercepts = [],
					roots = [];
				for (var i = 0, l = curves.length; i < l; i++) {
					var v = curves[i].getValues(),
						o0 = v[1],
						o1 = v[3],
						o2 = v[5],
						o3 = v[7];
					if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {
						var monoCurves = Curve.getMonoCurves(v);
						for (var j = 0, m = monoCurves.length; j < m; j++) {
							var mv = monoCurves[j],
								mo0 = mv[1],
								mo3 = mv[7];
							if ((mo0 !== mo3) &&
								(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){
								var x = y === mo0 ? mv[0]
									: y === mo3 ? mv[6]
									: Curve.solveCubic(mv, 1, y, roots, 0, 1)
										=== 1
										? Curve.getPoint(mv, roots[0]).x
										: (mv[0] + mv[6]) / 2;
								intercepts.push(x);
							}
						}
					}
				}
				if (intercepts.length > 1) {
					intercepts.sort(function(a, b) { return a - b; });
					point.x = (intercepts[0] + intercepts[1]) / 2;
				}
			}
			return point;
		}
	};
});

var PathFlattener = Base.extend({
	_class: 'PathFlattener',

	initialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minSpan = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, t1, t2) {
			if ((t2 - t1) > minSpan
					&& !(ignoreStraight && Curve.isStraight(curve))
					&& !Curve.isFlatEnough(curve, flatness || 0.25)) {
				var halves = Curve.subdivide(curve, 0.5),
					tMid = (t1 + t2) / 2;
				computeParts(halves[0], index, t1, tMid);
				computeParts(halves[1], index, tMid, t2);
			} else {
				var dx = curve[6] - curve[0],
					dy = curve[7] - curve[1],
					dist = Math.sqrt(dx * dx + dy * dy);
				if (dist > 0) {
					length += dist;
					parts.push({
						offset: length,
						curve: curve,
						index: index,
						time: t2,
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2 || segment1, segments[0]);
		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	_get: function(offset) {
		var parts = this.parts,
			length = parts.length,
			start,
			i, j = this.index;
		for (;;) {
			i = j;
			if (!j || parts[--j].offset < offset)
				break;
		}
		for (; i < length; i++) {
			var part = parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = parts[i - 1],
					prevTime = prev && prev.index === part.index ? prev.time : 0,
					prevOffset = prev ? prev.offset : 0;
				return {
					index: part.index,
					time: prevTime + (part.time - prevTime)
						* (offset - prevOffset) / (part.offset - prevOffset)
				};
			}
		}
		return {
			index: parts[length - 1].index,
			time: 1
		};
	},

	drawPart: function(ctx, from, to) {
		var start = this._get(from),
			end = this._get(to);
		for (var i = start.index, l = end.index; i <= l; i++) {
			var curve = Curve.getPart(this.curves[i],
					i === start.index ? start.time : 0,
					i === end.index ? end.time : 1);
			if (i === start.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(Curve._evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset) {
			var param = this._get(offset);
			return Curve[name](this.curves[param.index], param.time);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path) {
		var points = this.points = [],
			segments = path._segments,
			closed = path._closed;
		for (var i = 0, prev, l = segments.length; i < l; i++) {
			var point = segments[i].point;
			if (!prev || !prev.equals(point)) {
				points.push(prev = point.clone());
			}
		}
		if (closed) {
			points.unshift(points[points.length - 1]);
			points.push(points[1]);
		}
		this.closed = closed;
	},

	fit: function(error) {
		var points = this.points,
			length = points.length,
			segments = null;
		if (length > 0) {
			segments = [new Segment(points[0])];
			if (length > 1) {
				this.fitCubic(segments, error, 0, length - 1,
						points[1].subtract(points[0]),
						points[length - 2].subtract(points[length - 1]));
				if (this.closed) {
					segments.shift();
					segments.pop();
				}
			}
		}
		return segments;
	},

	fitCubic: function(segments, error, first, last, tan1, tan2) {
		var points = this.points;
		if (last - first === 1) {
			var pt1 = points[first],
				pt2 = points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(error, error * error),
			split,
			parametersInOrder = true;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < error && parametersInOrder) {
				this.addCurve(segments, curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			parametersInOrder = this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var tanCenter = points[split - 1].subtract(points[split + 1]);
		this.fitCubic(segments, error, first, split, tan1, tanCenter);
		this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(segments, curve) {
		var prev = segments[segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-12,
			abs = Math.abs,
			points = this.points,
			pt1 = points[first],
			pt2 = points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1,
			alpha2;
		if (abs(detC0C1) > epsilon) {
			var detC0X = C[0][0] * X[1]    - C[1][0] * X[0],
				detXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0
							: abs(c1) > epsilon ? X[1] / c1
							: 0;
		}

		var segLength = pt2.getDistance(pt1),
			eps = epsilon * segLength,
			handle1,
			handle2;
		if (alpha1 < eps || alpha2 < eps) {
			alpha1 = alpha2 = segLength / 3;
		} else {
			var line = pt2.subtract(pt1);
			handle1 = tan1.normalize(alpha1);
			handle2 = tan2.normalize(alpha2);
			if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
				alpha1 = alpha2 = segLength / 3;
				handle1 = handle2 = null;
			}
		}

		return [pt1,
				pt1.add(handle1 || tan1.normalize(alpha1)),
				pt2.add(handle2 || tan2.normalize(alpha2)),
				pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
		for (var i = 1, l = u.length; i < l; i++) {
			if (u[i] <= u[i - 1])
				return false;
		}
		return true;
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		return Numerical.isMachineZero(df) ? u : u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsOptions: { stroke: false, handle: false },

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	copyContent: function(source) {
		this.setContent(source._content);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(521);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx, param, viewMatrix) {
		if (!this._content)
			return;
		this._setStyles(ctx, param, viewMatrix);
		var lines = this._lines,
			style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (hasFill) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(matrix, options) {
		var rect = options.drawnTextBounds ? this._getDrawnTextSize() : this._getMeasuredTextSize();
		return matrix ? matrix._transformBounds(rect, rect) : rect;
	},

	_getMeasuredTextSize: function() {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		return new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
	},

	_getDrawnTextSize: function() {
		var style = this._style;
		var lines = this._lines;
		var numLines = lines.length;
		var leading = style.getLeading();
		var justification = style.getJustification();

		var svg = SvgElement.create('svg', {
					version: '1.1',
					xmlns: SvgElement.svg
				});
		var node = SvgElement.create('text');
		node.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
		svg.appendChild(node);
		for (var i = 0; i < numLines; i++) {
			var tspanNode = SvgElement.create('tspan', {
				x: '0',
				dy: i === 0 ? '0' : leading + 'px'
			});
			tspanNode.textContent = this._lines[i];
			node.appendChild(tspanNode);
		}

		var element = document.createElement('span');
		element.style.visibility = ('hidden');
		element.style.whiteSpace = 'pre';
		element.style.fontSize = this.fontSize + 'px';
		element.style.fontFamily = this.font;
		element.style.lineHeight = this.leading / this.fontSize;

		var bbox;
		try {
			element.appendChild(svg);
			document.body.appendChild(element);
			bbox = svg.getBBox();
		} finally {
			document.body.removeChild(element);
		}

		var halfStrokeWidth = this.strokeWidth / 2;
		var width = bbox.width + (halfStrokeWidth * 2);
		var height = bbox.height + (halfStrokeWidth * 2);
		var x = bbox.x - halfStrokeWidth;
		var y = bbox.y - halfStrokeWidth;

		if (justification !== 'left') {
			var eltWidth = this.getView().getTextWidth(style.getFontStyle(), lines);
			x -= eltWidth / (justification === 'center' ? 2: 1);
		}

		return new Rectangle(x, y, width + 1, Math.max(height, numLines * leading));
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && (this.hasFill() || options.hitUnfilledPaths) && this._contains(point))
			return new HitResult('fill', this);
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		namedColors = {
			transparent: [0, 0, 0, 0]
		},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(
				/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i
			) || string.match(
				/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i
			),
			type = 'rgb',
			components;
		if (match) {
			var amount = match[4] ? 4 : 3;
			components = new Array(amount);
			for (var i = 0; i < amount; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^(rgb|hsl)a?\((.*)\)$/)) {
			type = match[1];
			components = match[2].trim().split(/[,\s]+/g);
			var isHSL = type === 'hsl';
			for (var i = 0, l = Math.min(components.length, 4); i < l; i++) {
				var component = components[i];
				var value = parseFloat(component);
				if (isHSL) {
					if (i === 0) {
						var unit = component.match(/([a-z]*)$/)[1];
						value *= ({
							turn: 360,
							rad: 180 / Math.PI,
							grad: 0.9
						}[unit] || 1);
					} else if (i < 3) {
						value /= 100;
					}
				} else if (i < 3) {
					value /= /%$/.test(component) ? 100 : 255;
				}
				components[i] = value;
			}
		} else {
			var color = namedColors[string];
			if (!color) {
				if (window) {
					if (!colorCtx) {
						colorCtx = CanvasProvider.getContext(1, 1);
						colorCtx.globalCompositeOperation = 'copy';
					}
					colorCtx.fillStyle = 'rgba(0,0,0,0)';
					colorCtx.fillStyle = string;
					colorCtx.fillRect(0, 0, 1, 1);
					var data = colorCtx.getImageData(0, 0, 1, 1).data;
					color = namedColors[string] = [
						data[0] / 255,
						data[1] / 255,
						data[2] / 255
					];
				} else {
					color = [0, 0, 0];
				}
			}
			components = color.slice();
		}
		return [type, components];
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = type === 'gradient'
					? name === 'gradient'
						? function(value) {
							var current = this._components[0];
							value = Gradient.read(
								Array.isArray(value)
									? value
									: arguments, 0, { readNull: true }
							);
							if (current !== value) {
								if (current)
									current._removeOwner(this);
								if (value)
									value._addOwner(this);
							}
							return value;
						}
						: function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
					: function(value) {
						return value == null || isNaN(value) ? 0 : +value;
					};
			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				this._components[index] = parser.call(this, value);
				this._changed();
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var args = arguments,
				reading = this.__read,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (reading)
						read = 1;
					args = Base.slice(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (reading) {
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					}
					if (values.length > length)
						values = Base.slice(values, 0, length);
				} else if (argType === 'string') {
					var converted = fromCSS(arg);
					type = converted[0];
					components = converted[1];
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type],
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && !i && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (reading && type)
					read = 1;
			}
			this._type = type || 'rgb';
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (reading)
				this.__read = read;
			return this;
		},

		set: '#initialize',

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner) {
				if (this._setter) {
					this._owner[this._setter](this);
				} else {
					this._owner._changed(129);
				}
			}
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this.getAlpha() === col.getAlpha()
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx, matrix, strokeMatrix) {
			var strokeMayChange = this._type === 'gradient' && strokeMatrix;
			if (this._canvasStyle && !strokeMayChange)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				highlight = components[3],
				inverse = matrix && matrix.inverted(),
				canvasGradient;
			if (inverse) {
				origin = inverse._transformPoint(origin);
				destination = inverse._transformPoint(destination);
				if (highlight)
					highlight = inverse._transformPoint(highlight);
			}
			if (strokeMatrix) {
				origin = strokeMatrix._transformPoint(origin);
				destination = strokeMatrix._transformPoint(destination);
				if (highlight)
					highlight = strokeMatrix._transformPoint(highlight);
			}
			if (gradient._radial) {
				var radius = destination.getDistance(origin);
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					offset = stop._offset;
				canvasGradient.addColorStop(
						offset == null ? i / (l - 1) : offset,
						stop._color.toCanvasStyle());
			}
			if (!strokeMayChange) this._canvasStyle = canvasGradient;
			return canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			},

			_setOwner: function(color, owner, setter) {
				if (color) {
					if (color._owner && owner && color._owner !== owner) {
						color = color.clone();
					}
					if (!color._owner ^ !owner) {
						color._owner = owner || null;
						color._setter = setter || null;
					}
				}
				return color;
			}
		}
	});
},
new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = UID.get();
		if (stops && Base.isPlainObject(stops)) {
			this.set(stops);
			stops = radial = null;
		}
		if (this._stops == null) {
			this.setStops(stops || ['white', 'black']);
		}
		if (this._radial == null) {
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
		}
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++) {
			this._owners[i]._changed();
		}
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (!this._owners.length)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++) {
			stops[i] = this._stops[i].clone();
		}
		return new Gradient(stops, this._radial);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (stops.length < 2) {
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		}
		var _stops = this._stops;
		if (_stops) {
			for (var i = 0, l = _stops.length; i < l; i++)
				_stops[i]._owner = undefined;
		}
		_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });
		for (var i = 0, l = _stops.length; i < l; i++)
			_stops[i]._owner = this;
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class) {
			var stops1 = this._stops,
				stops2 = gradient._stops,
				length = stops1.length;
			if (length === stops2.length) {
				for (var i = 0; i < length; i++) {
					if (!stops1[i].equals(stops2[i]))
						return false;
				}
				return true;
			}
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		var color = arg0,
			offset = arg1;
		if (typeof arg0 === 'object' && arg1 === undefined) {
			if (Array.isArray(arg0) && typeof arg0[0] !== 'number') {
				color = arg0[0];
				offset = arg0[1];
			} else if ('color' in arg0 || 'offset' in arg0
					|| 'rampPoint' in arg0) {
				color = arg0.color;
				offset = arg0.offset || arg0.rampPoint || 0;
			}
		}
		this.setColor(color);
		this.setOffset(offset);
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._offset);
	},

	_serialize: function(options, dictionary) {
		var color = this._color,
			offset = this._offset;
		return Base.serialize(offset == null ? [color] : [color, offset],
				options, true, dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(129);
	},

	getOffset: function() {
		return this._offset;
	},

	setOffset: function(offset) {
		this._offset = offset;
		this._changed();
	},

	getRampPoint: '#getOffset',
	setRampPoint: '#setOffset',

	getColor: function() {
		return this._color;
	},

	setColor: function() {
		Color._setOwner(this._color, null);
		this._color = Color._setOwner(Color.read(arguments, 0), this,
				'setColor');
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._offset == stop._offset
				|| false;
	}
});

var Style = Base.extend(new function() {
	var itemDefaults = {
		fillColor: null,
		fillRule: 'nonzero',
		strokeColor: null,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		shadowColor: null,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: null
	},
	groupDefaults = Base.set({}, itemDefaults, {
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		leading: null,
		justification: 'left'
	}),
	textDefaults = Base.set({}, groupDefaults, {
		fillColor: new Color()
	}),
	flags = {
		strokeWidth: 193,
		strokeCap: 193,
		strokeJoin: 193,
		strokeScaling: 201,
		miterLimit: 193,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	},
	item = {
		beans: true
	},
	fields = {
		_class: 'Style',
		beans: true,

		initialize: function Style(style, _owner, _project) {
			this._values = {};
			this._owner = _owner;
			this._project = _owner && _owner._project || _project
					|| paper.project;
			this._defaults = !_owner || _owner instanceof Group ? groupDefaults
					: _owner instanceof TextItem ? textDefaults
					: itemDefaults;
			if (style)
				this.set(style);
		}
	};

	Base.each(groupDefaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children,
				applyToChildren = children && children.length > 0
					&& !(owner instanceof CompoundPath);
			if (applyToChildren) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			}
			if ((key === 'selectedColor' || !applyToChildren)
					&& key in this._defaults) {
				var old = this._values[key];
				if (old !== value) {
					if (isColor) {
						if (old) {
							Color._setOwner(old, null);
							old._canvasStyle = null;
						}
						if (value && value.constructor === Color) {
							value = Color._setOwner(value, owner,
									applyToChildren && set);
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 129);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				applyToChildren = children && children.length > 0
					&& !(owner instanceof CompoundPath),
				value;
			if (applyToChildren && !_dontMerge) {
				for (var i = 0, l = children.length; i < l; i++) {
					var childValue = children[i]._style[get]();
					if (!i) {
						value = childValue;
					} else if (!Base.equals(value, childValue)) {
						return undefined;
					}
				}
			} else if (key in this._defaults) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone) {
						value = value.clone();
					}
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
					}
				}
			}
			if (value && isColor) {
				value = Color._setOwner(value, owner, applyToChildren && set);
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Base.each({
		Font: 'FontFamily',
		WindingRule: 'FillRule'
	}, function(value, key) {
		var get = 'get' + key,
			set = 'set' + key;
		fields[get] = item[get] = '#get' + value;
		fields[set] = item[set] = '#set' + value;
	});

	Item.inject(item);
	return fields;
}, {
	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		function compare(style1, style2, secondary) {
			var values1 = style1._values,
				values2 = style2._values,
				defaults2 = style2._defaults;
			for (var key in values1) {
				var value1 = values1[key],
					value2 = values2[key];
				if (!(secondary && key in values2) && !Base.equals(value1,
						value2 === undefined ? defaults2[key] : value2))
					return false;
			}
			return true;
		}

		return style === this || style && this._class === style._class
				&& compare(this, style)
				&& compare(style, this, true)
				|| false;
	},

	_dispose: function() {
		var color;
		color = this.getFillColor();
		if (color) color._canvasStyle = null;
		color = this.getStrokeColor();
		if (color) color._canvasStyle = null;
		color = this.getShadowColor();
		if (color) color._canvasStyle = null;
	},

	hasFill: function() {
		var color = this.getFillColor();
		return !!color && color.alpha > 0;
	},

	hasStroke: function() {
		var color = this.getStrokeColor();
		return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		var color = this.getShadowColor();
		return !!color && color.alpha > 0 && (this.getShadowBlur() > 0
				|| !this.getShadowOffset().isZero());
	},

	getView: function() {
		return this._project._view;
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		isInserted: function(el) {
			return document.body.contains(el);
		},

		getPrefixed: function(el, name) {
			return el && handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		if (el) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++) {
					var name = parts[i];
					var options = (
						el === document
						&& (name === 'touchstart' || name === 'touchmove')
					) ? { passive: false } : false;
					el.addEventListener(name, func, options);
				}
			}
		}
	},

	remove: function(el, events) {
		if (el) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++)
					el.removeEventListener(parts[i], func, false);
			}
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		timer;

	function handleCallbacks() {
		var functions = callbacks;
		callbacks = [];
		for (var i = 0, l = functions.length; i < l; i++)
			functions[i]();
		requested = nativeRequest && callbacks.length;
		if (requested)
			nativeRequest(handleCallbacks);
	}

	return function(callback) {
		callbacks.push(callback);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {

		function getSize(name) {
			return element[name] || parseInt(element.getAttribute(name), 10);
		}

		function getCanvasSize() {
			var size = DomElement.getSize(element);
			return size.isNaN() || size.isZero()
					? new Size(getSize('width'), getSize('height'))
					: size;
		}

		var size;
		if (window && element) {
			this._id = element.getAttribute('id');
			if (this._id == null)
				element.setAttribute('id', this._id = 'paper-view-' + View._id++);
			DomEvent.add(element, this._viewEvents);
			var none = 'none';
			DomElement.setPrefixed(element.style, {
				userDrag: none,
				userSelect: none,
				touchCallout: none,
				contentZooming: none,
				tapHighlightColor: 'rgba(0,0,0,0)'
			});

			if (PaperScope.hasAttribute(element, 'resize')) {
				var that = this;
				DomEvent.add(window, this._windowEvents = {
					resize: function() {
						that.setViewSize(getCanvasSize());
					}
				});
			}

			size = getCanvasSize();

			if (PaperScope.hasAttribute(element, 'stats')
					&& typeof Stats !== 'undefined') {
				this._stats = new Stats();
				var stats = this._stats.domElement,
					style = stats.style,
					offset = DomElement.getOffset(element);
				style.position = 'absolute';
				style.left = offset.x + 'px';
				style.top = offset.y + 'px';
				document.body.appendChild(stats);
			}
		} else {
			size = new Size(element);
			element = null;
		}
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		if (!this._pixelRatio)
			this._pixelRatio = window && window.devicePixelRatio || 1;
		this._setElementSize(size.width, size.height);
		this._viewSize = size;
		View._views.push(this);
		View._viewsById[this._id] = this;
		(this._matrix = new Matrix())._owner = this;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
		this._itemEvents = { native: {}, virtual: {} };
		this._autoUpdate = !paper.agent.node;
		this._needsUpdate = false;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		var project = this._project;
		if (project._view === this)
			project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: Base.each(
		Item._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),
		function(name) {
			this[name] = {};
		}, {
			onFrame: {
				install: function() {
					this.play();
				},

				uninstall: function() {
					this.pause();
				}
			}
		}
	),

	_animate: false,
	_time: 0,
	_count: 0,

	getAutoUpdate: function() {
		return this._autoUpdate;
	},

	setAutoUpdate: function(autoUpdate) {
		this._autoUpdate = autoUpdate;
		if (autoUpdate)
			this.requestUpdate();
	},

	update: function() {
	},

	draw: function() {
		this.update();
	},

	requestUpdate: function() {
		if (!this._requested) {
			var that = this;
			DomEvent.requestAnimationFrame(function() {
				that._requested = false;
				if (that._animate) {
					that.requestUpdate();
					var element = that._element;
					if ((!DomElement.getPrefixed(document, 'hidden')
							|| PaperScope.getAttribute(element, 'keepalive')
								=== 'true') && DomElement.isInView(element)) {
						that._handleFrame();
					}
				}
				if (that._autoUpdate)
					that.update();
			});
			this._requested = true;
		}
	},

	play: function() {
		this._animate = true;
		this.requestUpdate();
	},

	pause: function() {
		this._animate = false;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._last ? now - this._last : 0;
		this._last = now;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_changed: function() {
		this._project._changed(4097);
		this._bounds = this._decomposed = undefined;
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._setElementSize(size.width, size.height);
		this._viewSize.set(size);
		this._changed();
		this.emit('resize', { size: size, delta: delta });
		if (this._autoUpdate) {
			this.update();
		}
	},

	_setElementSize: function(width, height) {
		var element = this._element;
		if (element) {
			if (element.width !== width)
				element.width = width;
			if (element.height !== height)
				element.height = height;
		}
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	isInserted: function() {
		return DomElement.isInserted(this._element);
	},

	getPixelSize: function(size) {
		var element = this._element,
			pixels;
		if (element) {
			var parent = element.parentNode,
				temp = document.createElement('div');
			temp.style.fontSize = size;
			parent.appendChild(temp);
			pixels = parseFloat(DomElement.getStyles(temp).fontSize);
			parent.removeChild(temp);
		} else {
			pixels = parseFloat(pixels);
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		return 0;
	}
}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
	var rotate = key === 'rotate';
	this[key] = function() {
		var args = arguments,
			value = (rotate ? Base : Point).read(args),
			center = Point.read(args, 0, { readNull: true });
		return this.transform(new Matrix()[key](value,
				center || this.getCenter(true)));
	};
}, {
	_decompose: function() {
		return this._decomposed || (this._decomposed = this._matrix.decompose());
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.translate(this.getCenter().subtract(center));
	},

	getZoom: function() {
		var scaling = this._decompose().scaling;
		return (scaling.x + scaling.y) / 2;
	},

	setZoom: function(zoom) {
		this.transform(new Matrix().scale(zoom / this.getZoom(),
			this.getCenter()));
	},

	getRotation: function() {
		return this._decompose().rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			this.rotate(rotation - current);
		}
	},

	getScaling: function() {
		var scaling = this._decompose().scaling;
		return new LinkedPoint(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling(),
			scaling = Point.read(arguments, 0, { clone: true, readNull: true });
		if (current && scaling) {
			this.scale(scaling.x / current.x, scaling.y / current.y);
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.initialize.apply(matrix, arguments);
	},

	transform: function(matrix) {
		this._matrix.append(matrix);
	},

	scrollBy: function() {
		this.translate(Point.read(arguments).negate());
	}
}), {

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	getEventPoint: function(event) {
		return this.viewToProject(DomEvent.getOffset(event, this._element));
	},

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (document && typeof element === 'string')
				element = document.getElementById(element);
			var ctor = window ? CanvasView : View;
			return new ctor(project, element);
		}
	}
},
new function() {
	if (!window)
		return;
	var prevFocus,
		tempFocus,
		dragging = false,
		mouseDown = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[
				target.getAttribute('id')];
	}

	function updateFocus() {
		var view = View._focused;
		if (!view || !view.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				if ((view = View._views[i]).isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, event, point) {
		view._handleMouseEvent('mousemove', event, point);
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {},
		docEvents = {
			mouseout: function(event) {
				var view = View._focused,
					target = DomEvent.getRelatedTarget(event);
				if (view && (!target || target.nodeName === 'HTML')) {
					var offset = DomEvent.getOffset(event, view._element),
						x = offset.x,
						abs = Math.abs,
						ax = abs(x),
						max = 1 << 25,
						diff = ax - max;
					offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;
					handleMouseMove(view, event, view.viewToProject(offset));
				}
			},

			scroll: updateFocus
		};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event);
		if (!dragging) {
			dragging = true;
			view._handleMouseEvent('mousedown', event);
		}
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!mouseDown) {
			var target = getView(event);
			if (target) {
				if (view !== target) {
					if (view)
						handleMouseMove(view, event);
					if (!prevFocus)
						prevFocus = view;
					view = View._focused = tempFocus = target;
				}
			} else if (tempFocus && tempFocus === view) {
				if (prevFocus && !prevFocus.isInserted())
					prevFocus = null;
				view = View._focused = prevFocus;
				prevFocus = null;
				updateFocus();
			}
		}
		if (view)
			handleMouseMove(view, event);
	};

	docEvents[mousedown] = function() {
		mouseDown = true;
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (view && dragging)
			view._handleMouseEvent('mouseup', event);
		mouseDown = dragging = false;
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	var called = false,
		prevented = false,
		fallbacks = {
			doubleclick: 'click',
			mousedrag: 'mousemove'
		},
		wasInView = false,
		overView,
		downPoint,
		lastPoint,
		downItem,
		overItem,
		dragItem,
		clickItem,
		clickTime,
		dblClick;

	function emitMouseEvent(obj, target, type, event, point, prevPoint,
			stopItem) {
		var stopped = false,
			mouseEvent;

		function emit(obj, type) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point,
							target || obj,
							prevPoint ? point.subtract(prevPoint) : null);
				}
				if (obj.emit(type, mouseEvent)) {
					called = true;
					if (mouseEvent.prevented)
						prevented = true;
					if (mouseEvent.stopped)
						return stopped = true;
				}
			} else {
				var fallback = fallbacks[type];
				if (fallback)
					return emit(obj, fallback);
			}
		}

		while (obj && obj !== stopItem) {
			if (emit(obj, type))
				break;
			obj = obj._parent;
		}
		return stopped;
	}

	function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
		view._project.removeOn(type);
		prevented = called = false;
		return (dragItem && emitMouseEvent(dragItem, null, type, event,
					point, prevPoint)
			|| hitItem && hitItem !== dragItem
				&& !hitItem.isDescendant(dragItem)
				&& emitMouseEvent(hitItem, null, type === 'mousedrag' ?
					'mousemove' : type, event, point, prevPoint, dragItem)
			|| emitMouseEvent(view, dragItem || hitItem || view, type, event,
					point, prevPoint));
	}

	var itemEventsMap = {
		mousedown: {
			mousedown: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mouseup: {
			mouseup: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mousemove: {
			mousedrag: 1,
			mousemove: 1,
			mouseenter: 1,
			mouseleave: 1
		}
	};

	return {
		_viewEvents: viewEvents,

		_handleMouseEvent: function(type, event, point) {
			var itemEvents = this._itemEvents,
				hitItems = itemEvents.native[type],
				nativeMove = type === 'mousemove',
				tool = this._scope.tool,
				view = this;

			function responds(type) {
				return itemEvents.virtual[type] || view.responds(type)
						|| tool && tool.responds(type);
			}

			if (nativeMove && dragging && responds('mousedrag'))
				type = 'mousedrag';
			if (!point)
				point = this.getEventPoint(event);

			var inView = this.getBounds().contains(point),
				hit = hitItems && inView && view._project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				hitItem = hit && hit.item || null,
				handle = false,
				mouse = {};
			mouse[type.substr(5)] = true;

			if (hitItems && hitItem !== overItem) {
				if (overItem) {
					emitMouseEvent(overItem, null, 'mouseleave', event, point);
				}
				if (hitItem) {
					emitMouseEvent(hitItem, null, 'mouseenter', event, point);
				}
				overItem = hitItem;
			}
			if (wasInView ^ inView) {
				emitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',
						event, point);
				overView = inView ? this : null;
				handle = true;
			}
			if ((inView || mouse.drag) && !point.equals(lastPoint)) {
				emitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',
						event, point, lastPoint);
				handle = true;
			}
			wasInView = inView;
			if (mouse.down && inView || mouse.up && downPoint) {
				emitMouseEvents(this, hitItem, type, event, point, downPoint);
				if (mouse.down) {
					dblClick = hitItem === clickItem
						&& (Date.now() - clickTime < 300);
					downItem = clickItem = hitItem;
					if (!prevented && hitItem) {
						var item = hitItem;
						while (item && !item.responds('mousedrag'))
							item = item._parent;
						if (item)
							dragItem = hitItem;
					}
					downPoint = point;
				} else if (mouse.up) {
					if (!prevented && hitItem === downItem) {
						clickTime = Date.now();
						emitMouseEvents(this, hitItem, dblClick ? 'doubleclick'
								: 'click', event, point, downPoint);
						dblClick = false;
					}
					downItem = dragItem = null;
				}
				wasInView = false;
				handle = true;
			}
			lastPoint = point;
			if (handle && tool) {
				called = tool._handleMouseEvent(type, event, point, mouse)
					|| called;
			}

			if (
				event.cancelable !== false
				&& (called && !mouse.move || mouse.down && responds('mouseup'))
			) {
				event.preventDefault();
			}
		},

		_handleKeyEvent: function(type, event, key, character) {
			var scope = this._scope,
				tool = scope.tool,
				keyEvent;

			function emit(obj) {
				if (obj.responds(type)) {
					paper = scope;
					obj.emit(type, keyEvent = keyEvent
							|| new KeyEvent(type, event, key, character));
				}
			}

			if (this.isVisible()) {
				emit(this);
				if (tool && tool.responds(type))
					emit(tool);
			}
		},

		_countItemEvent: function(type, sign) {
			var itemEvents = this._itemEvents,
				native = itemEvents.native,
				virtual = itemEvents.virtual;
			for (var key in itemEventsMap) {
				native[key] = (native[key] || 0)
						+ (itemEventsMap[key][type] || 0) * sign;
			}
			virtual[type] = (virtual[type] || 0) + sign;
		},

		statics: {
			updateFocus: updateFocus,

			_resetState: function() {
				dragging = mouseDown = called = wasInView = false;
				prevFocus = tempFocus = overView = downPoint = lastPoint =
					downItem = overItem = dragItem = clickItem = clickTime =
					dblClick = null;
			}
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if (!(canvas instanceof window.HTMLCanvasElement)) {
			var size = Size.read(arguments, 1);
			if (size.isZero())
				throw new Error(
						'Cannot create CanvasView with the provided argument: '
						+ Base.slice(arguments, 1));
			canvas = CanvasProvider.getCanvas(size);
		}
		var ctx = this._context = canvas.getContext('2d');
		ctx.save();
		this._pixelRatio = 1;
		if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(ctx,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
		this._needsUpdate = true;
	},

	remove: function remove() {
		this._context.restore();
		return remove.base.call(this);
	},

	_setElementSize: function _setElementSize(width, height) {
		var pixelRatio = this._pixelRatio;
		_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);
		if (pixelRatio !== 1) {
			var element = this._element,
				ctx = this._context;
			if (!PaperScope.hasAttribute(element, 'resize')) {
				var style = element.style;
				style.width = width + 'px';
				style.height = height + 'px';
			}
			ctx.restore();
			ctx.save();
			ctx.scale(pixelRatio, pixelRatio);
		}
	},

	getContext: function() {
		return this._context;
	},

	getPixelSize: function getPixelSize(size) {
		var agent = paper.agent,
			pixels;
		if (agent && agent.firefox) {
			pixels = getPixelSize.base.call(this, size);
		} else {
			var ctx = this._context,
				prevFont = ctx.font;
			ctx.font = size + ' serif';
			pixels = parseFloat(ctx.font);
			ctx.font = prevFont;
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function() {
		if (!this._needsUpdate)
			return false;
		var project = this._project,
			ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		if (project)
			project.draw(ctx, this._matrix, this._pixelRatio);
		this._needsUpdate = false;
		return true;
	}
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
		this.type = event && event.type;
	},

	prevented: false,
	stopped: false,

	preventDefault: function() {
		this.prevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.stopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getTimeStamp: function() {
		return this.event.timeStamp;
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(type, event, key, character) {
		this.type = type;
		this.event = event;
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {
	var keyLookup = {
			'\t': 'tab',
			' ': 'space',
			'\b': 'backspace',
			'\x7f': 'delete',
			'Spacebar': 'space',
			'Del': 'delete',
			'Win': 'meta',
			'Esc': 'escape'
		},

		charLookup = {
			'tab': '\t',
			'space': ' ',
			'enter': '\r'
		},

		keyMap = {},
		charMap = {},
		metaFixMap,
		downKey,

		modifiers = new Base({
			shift: false,
			control: false,
			alt: false,
			meta: false,
			capsLock: false,
			space: false
		}).inject({
			option: {
				get: function() {
					return this.alt;
				}
			},

			command: {
				get: function() {
					var agent = paper && paper.agent;
					return agent && agent.mac ? this.meta : this.control;
				}
			}
		});

	function getKey(event) {
		var key = event.key || event.keyIdentifier;
		key = /^U\+/.test(key)
				? String.fromCharCode(parseInt(key.substr(2), 16))
				: /^Arrow[A-Z]/.test(key) ? key.substr(5)
				: key === 'Unidentified'  || key === undefined
					? String.fromCharCode(event.keyCode)
					: key;
		return keyLookup[key] ||
				(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
	}

	function handleKey(down, key, character, event) {
		var type = down ? 'keydown' : 'keyup',
			view = View._focused,
			name;
		keyMap[key] = down;
		if (down) {
			charMap[key] = character;
		} else {
			delete charMap[key];
		}
		if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
			modifiers[name] = down;
			var agent = paper && paper.agent;
			if (name === 'meta' && agent && agent.mac) {
				if (down) {
					metaFixMap = {};
				} else {
					for (var k in metaFixMap) {
						if (k in charMap)
							handleKey(false, k, metaFixMap[k], event);
					}
					metaFixMap = null;
				}
			}
		} else if (down && metaFixMap) {
			metaFixMap[key] = character;
		}
		if (view) {
			view._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,
					character);
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var key = getKey(event),
				agent = paper && paper.agent;
			if (key.length > 1 || agent && (agent.chrome && (event.altKey
						|| agent.mac && event.metaKey
						|| !agent.mac && event.ctrlKey))) {
				handleKey(true, key,
						charLookup[key] || (key.length > 1 ? '' : key), event);
			} else {
				downKey = key;
			}
		},

		keypress: function(event) {
			if (downKey) {
				var key = getKey(event),
					code = event.charCode,
					character = code >= 32 ? String.fromCharCode(code)
						: key.length > 1 ? '' : key;
				if (key !== downKey) {
					key = character.toLowerCase();
				}
				handleKey(true, key, character, event);
				downKey = null;
			}
		},

		keyup: function(event) {
			var key = getKey(event);
			if (key in charMap)
				handleKey(false, key, charMap[key], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var key in charMap)
				handleKey(false, key, charMap[key], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		this.type = type;
		this.event = event;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
				? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return this.tool[/^mouse(down|up)$/.test(this.type)
				? '_downCount' : '_moveCount'];
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',
			'onKeyUp'],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._moveCount = -1;
		this._downCount = -1;
		this.set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (minDistance != null && this._maxDistance != null
				&& minDistance > this._maxDistance) {
			this._maxDistance = minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && maxDistance != null
				&& maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = this._maxDistance = distance;
	},

	_handleMouseEvent: function(type, event, point, mouse) {
		paper = this._scope;
		if (mouse.drag && !this.responds(type))
			type = 'mousemove';
		var move = mouse.move || mouse.drag,
			responds = this.responds(type),
			minDistance = this.minDistance,
			maxDistance = this.maxDistance,
			called = false,
			tool = this;
		function update(minDistance, maxDistance) {
			var pt = point,
				toolPoint = move ? tool._point : (tool._downPoint || pt);
			if (move) {
				if (tool._moveCount >= 0 && pt.equals(toolPoint)) {
					return false;
				}
				if (toolPoint && (minDistance != null || maxDistance != null)) {
					var vector = pt.subtract(toolPoint),
						distance = vector.getLength();
					if (distance < (minDistance || 0))
						return false;
					if (maxDistance) {
						pt = toolPoint.add(vector.normalize(
								Math.min(distance, maxDistance)));
					}
				}
				tool._moveCount++;
			}
			tool._point = pt;
			tool._lastPoint = toolPoint || pt;
			if (mouse.down) {
				tool._moveCount = -1;
				tool._downPoint = pt;
				tool._downCount++;
			}
			return true;
		}

		function emit() {
			if (responds) {
				called = tool.emit(type, new ToolEvent(tool, type, event))
						|| called;
			}
		}

		if (mouse.down) {
			update();
			emit();
		} else if (mouse.up) {
			update(null, maxDistance);
			emit();
		} else if (responds) {
			while (update(minDistance, maxDistance))
				emit();
		}
		return called;
	}

});

var Tween = Base.extend(Emitter, {
	_class: 'Tween',

	statics: {
		easings: {
			linear: function(t) {
				return t;
			},

			easeInQuad: function(t) {
				return t * t;
			},

			easeOutQuad: function(t) {
				return t * (2 - t);
			},

			easeInOutQuad: function(t) {
				return t < 0.5
					? 2 * t * t
					: -1 + 2 * (2 - t) * t;
			},

			easeInCubic: function(t) {
				return t * t * t;
			},

			easeOutCubic: function(t) {
				return --t * t * t + 1;
			},

			easeInOutCubic: function(t) {
				return t < 0.5
					? 4 * t * t * t
					: (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
			},

			easeInQuart: function(t) {
				return t * t * t * t;
			},

			easeOutQuart: function(t) {
				return 1 - (--t) * t * t * t;
			},

			easeInOutQuart: function(t) {
				return t < 0.5
					? 8 * t * t * t * t
					: 1 - 8 * (--t) * t * t * t;
			},

			easeInQuint: function(t) {
				return t * t * t * t * t;
			},

			easeOutQuint: function(t) {
				return 1 + --t * t * t * t * t;
			},

			easeInOutQuint: function(t) {
				return t < 0.5
					? 16 * t * t * t * t * t
					: 1 + 16 * (--t) * t * t * t * t;
			}
		}
	},

	initialize: function Tween(object, from, to, duration, easing, start) {
		this.object = object;
		var type = typeof easing;
		var isFunction = type === 'function';
		this.type = isFunction
			? type
			: type === 'string'
				? easing
				: 'linear';
		this.easing = isFunction ? easing : Tween.easings[this.type];
		this.duration = duration;
		this.running = false;

		this._then = null;
		this._startTime = null;
		var state = from || to;
		this._keys = state ? Object.keys(state) : [];
		this._parsedKeys = this._parseKeys(this._keys);
		this._from = state && this._getState(from);
		this._to = state && this._getState(to);
		if (start !== false) {
			this.start();
		}
	},

	then: function(then) {
		this._then = then;
		return this;
	},

	start: function() {
		this._startTime = null;
		this.running = true;
		return this;
	},

	stop: function() {
		this.running = false;
		return this;
	},

	update: function(progress) {
		if (this.running) {
			if (progress > 1) {
				progress = 1;
				this.running = false;
			}

			var factor = this.easing(progress),
				keys = this._keys,
				getValue = function(value) {
					return typeof value === 'function'
						? value(factor, progress)
						: value;
				};
			for (var i = 0, l = keys && keys.length; i < l; i++) {
				var key = keys[i],
					from = getValue(this._from[key]),
					to = getValue(this._to[key]),
					value = (from && to && from.__add && to.__add)
						? to.__subtract(from).__multiply(factor).__add(from)
						: ((to - from) * factor) + from;
				this._setProperty(this._parsedKeys[key], value);
			}

			if (!this.running && this._then) {
				this._then(this.object);
			}
			if (this.responds('update')) {
				this.emit('update', new Base({
					progress: progress,
					factor: factor
				}));
			}
		}
		return this;
	},

	_events: {
		onUpdate: {}
	},

	_handleFrame: function(time) {
		var startTime = this._startTime,
			progress = startTime
				? (time - startTime) / this.duration
				: 0;
		if (!startTime) {
			this._startTime = time;
		}
		this.update(progress);
	},

	_getState: function(state) {
		var keys = this._keys,
			result = {};
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i],
				path = this._parsedKeys[key],
				current = this._getProperty(path),
				value;
			if (state) {
				var resolved = this._resolveValue(current, state[key]);
				this._setProperty(path, resolved);
				value = this._getProperty(path);
				value = value && value.clone ? value.clone() : value;
				this._setProperty(path, current);
			} else {
				value = current && current.clone ? current.clone() : current;
			}
			result[key] = value;
		}
		return result;
	},

	_resolveValue: function(current, value) {
		if (value) {
			if (Array.isArray(value) && value.length === 2) {
				var operator = value[0];
				return (
					operator &&
					operator.match &&
					operator.match(/^[+\-\*\/]=/)
				)
					? this._calculate(current, operator[0], value[1])
					: value;
			} else if (typeof value === 'string') {
				var match = value.match(/^[+\-*/]=(.*)/);
				if (match) {
					var parsed = JSON.parse(match[1].replace(
						/(['"])?([a-zA-Z0-9_]+)(['"])?:/g,
						'"$2": '
					));
					return this._calculate(current, value[0], parsed);
				}
			}
		}
		return value;
	},

	_calculate: function(left, operator, right) {
		return paper.PaperScript.calculateBinary(left, operator, right);
	},

	_parseKeys: function(keys) {
		var parsed = {};
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i],
				path = key
					.replace(/\.([^.]*)/g, '/$1')
					.replace(/\[['"]?([^'"\]]*)['"]?\]/g, '/$1');
			parsed[key] = path.split('/');
		}
		return parsed;
	},

	_getProperty: function(path, offset) {
		var obj = this.object;
		for (var i = 0, l = path.length - (offset || 0); i < l && obj; i++) {
			obj = obj[path[i]];
		}
		return obj;
	},

	_setProperty: function(path, value) {
		var dest = this._getProperty(path, 1);
		if (dest) {
			dest[path[path.length - 1]] = value;
		}
	}
});

var Http = {
	request: function(options) {
		var xhr = new self.XMLHttpRequest();
		xhr.open((options.method || 'get').toUpperCase(), options.url,
				Base.pick(options.async, true));
		if (options.mimeType)
			xhr.overrideMimeType(options.mimeType);
		xhr.onload = function() {
			var status = xhr.status;
			if (status === 0 || status === 200) {
				if (options.onLoad) {
					options.onLoad.call(xhr, xhr.responseText);
				}
			} else {
				xhr.onerror();
			}
		};
		xhr.onerror = function() {
			var status = xhr.status,
				message = 'Could not load "' + options.url + '" (Status: '
						+ status + ')';
			if (options.onError) {
				options.onError(message, status);
			} else {
				throw new Error(message);
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		if (!window)
			return null;
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
			clear = false;
		}
		var ctx = canvas.getContext('2d');
		if (!ctx) {
			throw new Error('Canvas ' + canvas +
					' is unable to provide a 2D context.');
		}
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		var canvas = this.getCanvas(width, height);
		return canvas ? canvas.getContext('2d') : null;
	},

	release: function(obj) {
		var canvas = obj && obj.canvas ? obj.canvas : obj;
		if (canvas && canvas.getContext) {
			canvas.getContext('2d').restore();
			this.canvases.push(canvas);
		}
	}
};

var BlendMode = new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa,
		br, bg, bb, ba,
		dr, dg, db;

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b),
			mn = min(r, g, b),
			md;
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	if (ctx) {
		Base.each(modes, function(func, mode) {
			var darken = mode === 'darken',
				ok = false;
			ctx.save();
			try {
				ctx.fillStyle = darken ? '#300' : '#a00';
				ctx.fillRect(0, 0, 1, 1);
				ctx.globalCompositeOperation = mode;
				if (ctx.globalCompositeOperation === mode) {
					ctx.fillStyle = darken ? '#a00' : '#300';
					ctx.fillRect(0, 0, 1, 1);
					ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken
							? 170 : 51;
				}
			} catch (e) {}
			ctx.restore();
			nativeModes[mode] = ok;
		});
		CanvasProvider.release(ctx);
	}

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst = dstData.data,
				src = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SvgElement = new function() {
	var svg = 'http://www.w3.org/2000/svg',
		xmlns = 'http://www.w3.org/2000/xmlns',
		xlink = 'http://www.w3.org/1999/xlink',
		attributeNamespace = {
			href: xlink,
			xlink: xmlns,
			xmlns: xmlns + '/',
			'xmlns:xlink': xmlns + '/'
		};

	function create(tag, attributes, formatter) {
		return set(document.createElementNS(svg, tag), attributes, formatter);
	}

	function get(node, name) {
		var namespace = attributeNamespace[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		return value === 'null' ? null : value;
	}

	function set(node, attributes, formatter) {
		for (var name in attributes) {
			var value = attributes[name],
				namespace = attributeNamespace[name];
			if (typeof value === 'number' && formatter)
				value = formatter.number(value);
			if (namespace) {
				node.setAttributeNS(namespace, name, value);
			} else {
				node.setAttribute(name, value);
			}
		}
		return node;
	}

	return {
		svg: svg,
		xmlns: xmlns,
		xlink: xlink,

		create: create,
		get: get,
		set: set
	};
};

var SvgStyles = Base.each({
	fillColor: ['fill', 'color'],
	fillRule: ['fill-rule', 'string'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'style']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

new function() {
	var formatter;

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			var point;
			if (matrix.isInvertible()) {
				matrix = matrix._shiftless();
				point = matrix._inverseTransform(trans);
				trans = null;
			} else {
				point = new Point();
			}
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling,
					skew = decomposed.skewing;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				if (skew.x)
					parts.push('skewX(' + formatter.number(skew.x) + ')');
				if (skew.y)
					parts.push('skewY(' + formatter.number(skew.y) + ')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = SvgElement.create('g', attrs, formatter);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = SvgElement.create('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					SvgElement.set(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item, options) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize(),
			image = item.getImage();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = options.embedImages == false && image && image.src
				|| item.toDataURL();
		return SvgElement.create('image', attrs, formatter);
	}

	function exportPath(item, options) {
		var matchShapes = options.matchShapes;
		if (matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			length = segments.length,
			type,
			attrs = getTransform(item._matrix);
		if (matchShapes && length >= 2 && !item.hasHandles()) {
			if (length > 2) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for (var i = 0; i < length; i++) {
					parts.push(formatter.point(segments[i]._point));
				}
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var start = segments[0]._point,
					end = segments[1]._point;
				attrs.set({
					x1: start.x,
					y1: start.y,
					x2: end.x,
					y2: end.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return SvgElement.create(type, attrs, formatter);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return SvgElement.create(type, attrs, formatter);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return SvgElement.create('path', attrs, formatter);
	}

	function exportSymbolItem(item, options) {
		var attrs = getTransform(item._matrix, true),
			definition = item._definition,
			node = getDefinition(definition, 'symbol'),
			definitionItem = definition._item,
			bounds = definitionItem.getStrokeBounds();
		if (!node) {
			node = SvgElement.create('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			node.appendChild(exportSVG(definitionItem, options));
			setDefinition(definition, node, 'symbol');
		}
		attrs.href = '#' + node.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = bounds.width;
		attrs.height = bounds.height;
		attrs.overflow = 'visible';
		return SvgElement.create('use', attrs, formatter);
	}

	function exportGradient(color, item) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin(),
				destination = color.getDestination(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			if (item instanceof paper.PointText) {
				attrs.gradientTransform = getTransform(
					item._matrix.clone().invert(), false, formatter).transform;
			}

			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = SvgElement.create((radial ? 'radial' : 'linear')
					+ 'Gradient', attrs, formatter);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha(),
					offset = stop._offset;
				attrs = {
					offset: offset == null ? i / (l - 1) : offset
				};
				if (stopColor)
					attrs['stop-color'] = stopColor.toCSS(true);
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(
						SvgElement.create('stop', attrs, formatter));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = SvgElement.create('text', getTransform(item._matrix, false),
				formatter);
		node.setAttribute('font-size', item.fontSize);
		node.setAttribute('xml:space', 'preserve');
		for (var i = 0; i < item._lines.length; i++) {
			var tspanNode = SvgElement.create('tspan', {
				x: '0',
				dy: i === 0 ? '0' : item.getLeading() + 'px'
			}, formatter);
			tspanNode.textContent = item._lines[i] ? item._lines[i] : ' ';
			node.appendChild(tspanNode);
		}
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		SymbolItem: exportSymbolItem,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent(),
			style = [];

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SvgStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();

			if (value === undefined) return;

			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value) ||
					  item instanceof paper.PointText) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				if (type === 'style') {
					style.push(entry.attribute + ': ' + value);
				} else {
					attrs[entry.attribute] = value == null ? 'none'
							: type === 'color' ? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array' ? value.join(',')
							: type === 'lookup' ? entry.toSVG[value]
							: value;
				}
			}
		});

		if (style.length)
			attrs.style = style.join(';');

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return SvgElement.set(node, attrs, formatter);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-'
				+ (item._id || item.__id || (item.__id = UID.get('svg')))];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + typeId;
		definitions.svgs[type + '-' + (item._id || item.__id)] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = SvgElement.create('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(SvgElement.create('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new self.XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data !== '{}' && data !== 'null')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var children = this._children,
				view = this.getView(),
				bounds = Base.pick(options.bounds, 'view'),
				mx = options.matrix || bounds === 'view' && view._matrix,
				matrix = mx && Matrix.read([mx]),
				rect = bounds === 'view'
					? new Rectangle([0, 0], view.getViewSize())
					: bounds === 'content'
						? Item._getBounds(children, matrix, { stroke: true, drawnTextBounds: true })
							.rect
						: Rectangle.read([bounds], 0, { readNull: true }),
				attrs = {
					version: '1.1',
					xmlns: SvgElement.svg,
					'xmlns:xlink': SvgElement.xlink,
				};
			if (rect) {
				attrs.width = rect.width;
				attrs.height = rect.height;
				if (rect.x || rect.x === 0 || rect.y || rect.y === 0)
					attrs.viewBox = formatter.rectangle(rect);
			}
			var node = SvgElement.create('svg', attrs, formatter),
				parent = node;
			if (matrix && !matrix.isIdentity()) {
				parent = node.appendChild(SvgElement.create('g',
						getTransform(matrix), formatter));
			}
			for (var i = 0, l = children.length; i < l; i++) {
				parent.appendChild(exportSVG(children[i], options, true));
			}
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	var definitions = {},
		rootSize;

	function getValue(node, name, isString, allowNull, allowPercent,
			defaultValue) {
		var value = SvgElement.get(node, name) || defaultValue,
			res = value == null
				? allowNull
					? null
					: isString ? '' : 0
				: isString
					? value
					: parseFloat(value);
		return /%\s*$/.test(value)
			? (res / 100) * (allowPercent ? 1
				: rootSize[/x|^width/.test(name) ? 'width' : 'height'])
			: res;
	}

	function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {
		x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);
		y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull, allowPercent) {
		w = getValue(node, w || 'width', false, allowNull, allowPercent);
		h = getValue(node, h || 'height', false, allowNull, allowPercent);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none' ? null
				: type === 'number' ? parseFloat(value)
				: type === 'array' ?
					value ? value.split(/[\s,]+/g).map(parseFloat) : []
				: type === 'color' ? getDefinition(value) || value
				: type === 'lookup' ? lookup[value]
				: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			isDefs = type === 'defs',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip && !isDefs) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		if (isRoot) {
			var defs = node.querySelectorAll('defs');
			for (var i = 0, l = defs.length; i < l; i++) {
				importNode(defs[i], options, false);
			}
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& !/^defs$/i.test(childNode.nodeName)
					&& (child = importNode(childNode, options, false))
					&& !(child instanceof SymbolDefinition))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || isDefs) {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		return PathItem.create(node.getAttribute('d'));
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			radial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
			if (gradient._radial ^ radial) {
				gradient = gradient.clone();
				gradient._radial = radial;
			}
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, radial);
		}
		var origin, destination, highlight,
			scaleToBounds = getValue(node, 'gradientUnits', true) !==
				'userSpaceOnUse';
		if (radial) {
			origin = getPoint(node, 'cx', 'cy', false, scaleToBounds,
				'50%', '50%');
			destination = origin.add(
				getValue(node, 'r', false, false, scaleToBounds, '50%'), 0);
			highlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);
		} else {
			origin = getPoint(node, 'x1', 'y1', false, scaleToBounds,
				'0%', '0%');
			destination = getPoint(node, 'x2', 'y2', false, scaleToBounds,
				'100%', '0%');
		}
		var color = applyAttributes(
				new Color(gradient, origin, destination, highlight), node);
		color._scaleToBounds = scaleToBounds;
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					return importNode(child, options, isRoot);
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node);
				this.setSize(size);
				var center = getPoint(node).add(size.divide(2));
				this._matrix.append(new Matrix().translate(center));
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new SymbolDefinition(
					importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node);
			return definition
					? definition instanceof SymbolDefinition
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(
					getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			return new Shape.Rectangle(new Rectangle(
						getPoint(node),
						getSize(node)
					), getSize(node, 'rx', 'ry'));
			},

		line: function(node) {
			return new Path.Line(
					getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {

			var fontSize = parseFloat(node.getAttribute("font-size"));
			var alignmentBaseline = node.getAttribute("alignment-baseline");
			if (node.childElementCount === 0) {
				var text = new PointText();
				text.setContent(node.textContent.trim() || '');
				text.translate(0, text._style.getLeading());
				if (!isNaN(fontSize)) text.setFontSize(fontSize);
				return text;
			} else {
				var lines = [];
				var spacing = 1.2;
				for (var i = 0; i < node.childNodes.length; i++) {
					var child = node.childNodes[i];
					if (!child.getAttribute) continue;
					lines.push(child.textContent);
					var dyString = child.getAttribute('dy');
					if (dyString) {
						var dy = parseFloat(dyString);
						if (!isNaN(dy)) {
							if (dyString.endsWith('em')) {
								spacing = dy;
							} else if (dyString.endsWith('px') && !isNaN(fontSize)) {
								spacing = dy / fontSize;
							}
						}
					}
				}
				var text = new PointText();
				if (!isNaN(fontSize)) text.setFontSize(fontSize);
				text.setLeading(text.fontSize * spacing);
				if (alignmentBaseline === 'text-before-edge') {
					text.setContent(' ');
					text.translate(0, text.bounds.height);
				}
				text.setContent(lines.join('\n'));
				return text;
			}
		},

		switch: importGroup
	};

	function applyTransform(item, value, name, node) {
		if (item.transform) {
			var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
				matrix = new Matrix();
			for (var i = 0, l = transforms.length; i < l; i++) {
				var transform = transforms[i];
				if (!transform)
					break;
				var parts = transform.split(/\(\s*/),
					command = parts[0],
					v = parts[1].split(/[\s,]+/g);
				for (var j = 0, m = v.length; j < m; j++)
					v[j] = parseFloat(v[j]);
				switch (command) {
				case 'matrix':
					matrix.append(
							new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
					break;
				case 'rotate':
					matrix.rotate(v[0], v[1] || 0, v[2] || 0);
					break;
				case 'translate':
					matrix.translate(v[0], v[1] || 0);
					break;
				case 'scale':
					matrix.scale(v);
					break;
				case 'skewX':
					matrix.skew(v[0], 0);
					break;
				case 'skewY':
					matrix.skew(0, v[0]);
					break;
				}
			}
			item.transform(matrix);
		}
	}

	function applyOpacity(item, value, name) {
		var key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',
			color = item[key] && item[key]();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.set(Base.each(SvgStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			if (item[entry.set]) {
				item[entry.set](convertValue(value, entry.type, entry.fromSVG));
				if (entry.type === 'color') {
					var color = item[entry.get]();
					if (color) {
						if (color._scaleToBounds) {
							var bounds = item.getBounds();
							color.transform(new Matrix()
								.translate(bounds.getPoint())
								.scale(bounds.getSize()));
						}
					}
				}
			}
		};
	}, {}), {
		id: function(item, value) {
			definitions[value] = item;
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			if (item.setVisible)
				item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			if (item.setVisible)
				item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			if (item.setOffset) {
				var percent = value.match(/(.*)%$/);
				item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
			}
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, null, null, true),
				group,
				matrix;
			if (item instanceof Group) {
				var scale = size ? size.divide(rect.getSize()) : 1,
				matrix = new Matrix().scale(scale)
						.translate(rect.getPoint().negate());
				group = item;
			} else if (item instanceof SymbolDefinition) {
				if (size)
					rect.setSize(size);
				group = item._item;
			}
			if (group)  {
				if (getAttribute(node, 'overflow', styles) !== 'visible') {
					var clip = new Shape.Rectangle(rect);
					clip.setClipMask(true);
					group.addChild(clip);
				}
				if (matrix)
					group.transform(matrix);
			}
		},

		'fill-rule': function(item, value) {
			if (value === 'evenodd' || value === 'nonzero') item.fillRule = value;
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value && node.style) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value ? undefined
				: value === 'none' ? null
				: value;
	}

	function applyAttributes(item, node, isRoot) {
		var parent = node.parentNode,
			styles = {
				node: DomElement.getStyles(node) || {},
				parent: !isRoot && !/^defs$/i.test(parent.tagName)
						&& DomElement.getStyles(parent) || {}
			};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			item = value !== undefined
					&& apply(item, value, name, node, styles) || item;
		});
		return item;
	}

	function getDefinition(value) {
		var match = value && value.match(/\((?:["'#]*)([^"')]+)/),
			name = match && match[1],
			res = name && definitions[window
					? name.replace(window.location.href.split('#')[0] + '#', '')
					: name];
		if (res && res._scaleToBounds) {
			res = res.clone();
			res._scaleToBounds = true;
		}
		return res;
	}

	function importNode(node, options, isRoot) {
		var type = node.nodeName.toLowerCase(),
			isElement = type !== '#document',
			body = document.body,
			container,
			parent,
			next;
		if (isRoot && isElement) {
			rootSize = paper.getView().getSize();
			rootSize = getSize(node, null, null, true) || rootSize;
			container = SvgElement.create('svg', {
				style: 'stroke-width: 1px; stroke-miterlimit: 10'
			});
			parent = node.parentNode;
			next = node.nextSibling;
			container.appendChild(node);
			body.appendChild(container);
		}
		var settings = paper.settings,
			applyMatrix = settings.applyMatrix,
			insertItems = settings.insertItems;
		settings.applyMatrix = false;
		settings.insertItems = false;
		var importer = importers[type],
			item = importer && importer(node, type, options, isRoot) || null;
		settings.insertItems = insertItems;
		settings.applyMatrix = applyMatrix;
		if (item) {
			if (isElement && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport,
				data = isElement && node.getAttribute('data-paper-data');
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (container) {
			body.removeChild(container);
			if (parent) {
				if (next) {
					parent.insertBefore(node, next);
				} else {
					parent.appendChild(node);
				}
			}
		}
		if (isRoot) {
			definitions = {};
			if (item && Base.pick(options.applyMatrix, applyMatrix))
				item.matrix.apply(true, true);
		}
		return item;
	}

	function importSVG(source, options, owner) {
		if (!source)
			return null;
		options = typeof options === 'function' ? { onLoad: options }
				: options || {};
		var scope = paper,
			item = null;

		function onLoad(svg) {
			try {
				var node = typeof svg === 'object'
					? svg
					: new self.DOMParser().parseFromString(
						svg,
						'image/svg+xml'
					);
				if (!node.nodeName) {
					node = null;
					throw new Error('Unsupported SVG source: ' + source);
				}
				paper = scope;
				item = importNode(node, options, true);
				if (!options || options.insert !== false) {
					owner._insertItem(undefined, item);
				}
				var onLoad = options.onLoad;
				if (onLoad)
					onLoad(item, svg);
			} catch (e) {
				onError(e);
			}
		}

		function onError(message, status) {
			var onError = options.onError;
			if (onError) {
				onError(message, status);
			} else {
				throw new Error(message);
			}
		}

		if (typeof source === 'string' && !/^[\s\S]*</.test(source)) {
			var node = document.getElementById(source);
			if (node) {
				onLoad(node);
			} else {
				Http.request({
					url: source,
					async: true,
					onLoad: onLoad,
					onError: onError
				});
			}
		} else if (typeof File !== 'undefined' && source instanceof File) {
			var reader = new FileReader();
			reader.onload = function() {
				onLoad(reader.result);
			};
			reader.onerror = function() {
				onError(reader.error);
			};
			return reader.readAsText(source);
		} else {
			onLoad(source);
		}

		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return importSVG(node, options, this);
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, this);
		}
	});
};

Base.exports.PaperScript = function() {
	var global = this,
		acorn = global.acorn;
	if (!acorn && "function" !== 'undefined') {
		try { acorn = __webpack_require__(95); } catch(e) {}
	}
	if (!acorn) {
		var exports, module;
		acorn = exports = module = {};

(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") return mod(exports);
  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  mod(root.acorn || (root.acorn = {}));
})(this, function(exports) {
  "use strict";

  exports.version = "0.5.0";

  var options, input, inputLen, sourceFile;

  exports.parse = function(inpt, opts) {
	input = String(inpt); inputLen = input.length;
	setOptions(opts);
	initTokenState();
	return parseTopLevel(options.program);
  };

  var defaultOptions = exports.defaultOptions = {
	ecmaVersion: 5,
	strictSemicolons: false,
	allowTrailingCommas: true,
	forbidReserved: false,
	allowReturnOutsideFunction: false,
	locations: false,
	onComment: null,
	ranges: false,
	program: null,
	sourceFile: null,
	directSourceFile: null
  };

  function setOptions(opts) {
	options = opts || {};
	for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))
	  options[opt] = defaultOptions[opt];
	sourceFile = options.sourceFile || null;
  }

  var getLineInfo = exports.getLineInfo = function(input, offset) {
	for (var line = 1, cur = 0;;) {
	  lineBreak.lastIndex = cur;
	  var match = lineBreak.exec(input);
	  if (match && match.index < offset) {
		++line;
		cur = match.index + match[0].length;
	  } else break;
	}
	return {line: line, column: offset - cur};
  };

  exports.tokenize = function(inpt, opts) {
	input = String(inpt); inputLen = input.length;
	setOptions(opts);
	initTokenState();

	var t = {};
	function getToken(forceRegexp) {
	  lastEnd = tokEnd;
	  readToken(forceRegexp);
	  t.start = tokStart; t.end = tokEnd;
	  t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;
	  t.type = tokType; t.value = tokVal;
	  return t;
	}
	getToken.jumpTo = function(pos, reAllowed) {
	  tokPos = pos;
	  if (options.locations) {
		tokCurLine = 1;
		tokLineStart = lineBreak.lastIndex = 0;
		var match;
		while ((match = lineBreak.exec(input)) && match.index < pos) {
		  ++tokCurLine;
		  tokLineStart = match.index + match[0].length;
		}
	  }
	  tokRegexpAllowed = reAllowed;
	  skipSpace();
	};
	return getToken;
  };

  var tokPos;

  var tokStart, tokEnd;

  var tokStartLoc, tokEndLoc;

  var tokType, tokVal;

  var tokRegexpAllowed;

  var tokCurLine, tokLineStart;

  var lastStart, lastEnd, lastEndLoc;

  var inFunction, labels, strict;

  function raise(pos, message) {
	var loc = getLineInfo(input, pos);
	message += " (" + loc.line + ":" + loc.column + ")";
	var err = new SyntaxError(message);
	err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
	throw err;
  }

  var empty = [];

  var _num = {type: "num"}, _regexp = {type: "regexp"}, _string = {type: "string"};
  var _name = {type: "name"}, _eof = {type: "eof"};

  var _break = {keyword: "break"}, _case = {keyword: "case", beforeExpr: true}, _catch = {keyword: "catch"};
  var _continue = {keyword: "continue"}, _debugger = {keyword: "debugger"}, _default = {keyword: "default"};
  var _do = {keyword: "do", isLoop: true}, _else = {keyword: "else", beforeExpr: true};
  var _finally = {keyword: "finally"}, _for = {keyword: "for", isLoop: true}, _function = {keyword: "function"};
  var _if = {keyword: "if"}, _return = {keyword: "return", beforeExpr: true}, _switch = {keyword: "switch"};
  var _throw = {keyword: "throw", beforeExpr: true}, _try = {keyword: "try"}, _var = {keyword: "var"};
  var _while = {keyword: "while", isLoop: true}, _with = {keyword: "with"}, _new = {keyword: "new", beforeExpr: true};
  var _this = {keyword: "this"};

  var _null = {keyword: "null", atomValue: null}, _true = {keyword: "true", atomValue: true};
  var _false = {keyword: "false", atomValue: false};

  var _in = {keyword: "in", binop: 7, beforeExpr: true};

  var keywordTypes = {"break": _break, "case": _case, "catch": _catch,
					  "continue": _continue, "debugger": _debugger, "default": _default,
					  "do": _do, "else": _else, "finally": _finally, "for": _for,
					  "function": _function, "if": _if, "return": _return, "switch": _switch,
					  "throw": _throw, "try": _try, "var": _var, "while": _while, "with": _with,
					  "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
					  "instanceof": {keyword: "instanceof", binop: 7, beforeExpr: true}, "this": _this,
					  "typeof": {keyword: "typeof", prefix: true, beforeExpr: true},
					  "void": {keyword: "void", prefix: true, beforeExpr: true},
					  "delete": {keyword: "delete", prefix: true, beforeExpr: true}};

  var _bracketL = {type: "[", beforeExpr: true}, _bracketR = {type: "]"}, _braceL = {type: "{", beforeExpr: true};
  var _braceR = {type: "}"}, _parenL = {type: "(", beforeExpr: true}, _parenR = {type: ")"};
  var _comma = {type: ",", beforeExpr: true}, _semi = {type: ";", beforeExpr: true};
  var _colon = {type: ":", beforeExpr: true}, _dot = {type: "."}, _question = {type: "?", beforeExpr: true};

  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};
  var _assign = {isAssign: true, beforeExpr: true};
  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};
  var _logicalOR = {binop: 1, beforeExpr: true};
  var _logicalAND = {binop: 2, beforeExpr: true};
  var _bitwiseOR = {binop: 3, beforeExpr: true};
  var _bitwiseXOR = {binop: 4, beforeExpr: true};
  var _bitwiseAND = {binop: 5, beforeExpr: true};
  var _equality = {binop: 6, beforeExpr: true};
  var _relational = {binop: 7, beforeExpr: true};
  var _bitShift = {binop: 8, beforeExpr: true};
  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};
  var _multiplyModulo = {binop: 10, beforeExpr: true};

  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
					  parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
					  dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,
					  num: _num, regexp: _regexp, string: _string};
  for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

  function makePredicate(words) {
	words = words.split(" ");
	var f = "", cats = [];
	out: for (var i = 0; i < words.length; ++i) {
	  for (var j = 0; j < cats.length; ++j)
		if (cats[j][0].length == words[i].length) {
		  cats[j].push(words[i]);
		  continue out;
		}
	  cats.push([words[i]]);
	}
	function compareTo(arr) {
	  if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
	  f += "switch(str){";
	  for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
	  f += "return true}return false;";
	}

	if (cats.length > 3) {
	  cats.sort(function(a, b) {return b.length - a.length;});
	  f += "switch(str.length){";
	  for (var i = 0; i < cats.length; ++i) {
		var cat = cats[i];
		f += "case " + cat[0].length + ":";
		compareTo(cat);
	  }
	  f += "}";

	} else {
	  compareTo(words);
	}
	return new Function("str", f);
  }

  var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");

  var isReservedWord5 = makePredicate("class enum extends super const export import");

  var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");

  var isStrictBadIdWord = makePredicate("eval arguments");

  var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");

  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  var newline = /[\n\r\u2028\u2029]/;

  var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

  var isIdentifierStart = exports.isIdentifierStart = function(code) {
	if (code < 65) return code === 36;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123)return true;
	return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  };

  var isIdentifierChar = exports.isIdentifierChar = function(code) {
	if (code < 48) return code === 36;
	if (code < 58) return true;
	if (code < 65) return false;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123)return true;
	return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  };

  function line_loc_t() {
	this.line = tokCurLine;
	this.column = tokPos - tokLineStart;
  }

  function initTokenState() {
	tokCurLine = 1;
	tokPos = tokLineStart = 0;
	tokRegexpAllowed = true;
	skipSpace();
  }

  function finishToken(type, val) {
	tokEnd = tokPos;
	if (options.locations) tokEndLoc = new line_loc_t;
	tokType = type;
	skipSpace();
	tokVal = val;
	tokRegexpAllowed = type.beforeExpr;
  }

  function skipBlockComment() {
	var startLoc = options.onComment && options.locations && new line_loc_t;
	var start = tokPos, end = input.indexOf("*/", tokPos += 2);
	if (end === -1) raise(tokPos - 2, "Unterminated comment");
	tokPos = end + 2;
	if (options.locations) {
	  lineBreak.lastIndex = start;
	  var match;
	  while ((match = lineBreak.exec(input)) && match.index < tokPos) {
		++tokCurLine;
		tokLineStart = match.index + match[0].length;
	  }
	}
	if (options.onComment)
	  options.onComment(true, input.slice(start + 2, end), start, tokPos,
						startLoc, options.locations && new line_loc_t);
  }

  function skipLineComment() {
	var start = tokPos;
	var startLoc = options.onComment && options.locations && new line_loc_t;
	var ch = input.charCodeAt(tokPos+=2);
	while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	  ++tokPos;
	  ch = input.charCodeAt(tokPos);
	}
	if (options.onComment)
	  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,
						startLoc, options.locations && new line_loc_t);
  }

  function skipSpace() {
	while (tokPos < inputLen) {
	  var ch = input.charCodeAt(tokPos);
	  if (ch === 32) {
		++tokPos;
	  } else if (ch === 13) {
		++tokPos;
		var next = input.charCodeAt(tokPos);
		if (next === 10) {
		  ++tokPos;
		}
		if (options.locations) {
		  ++tokCurLine;
		  tokLineStart = tokPos;
		}
	  } else if (ch === 10 || ch === 8232 || ch === 8233) {
		++tokPos;
		if (options.locations) {
		  ++tokCurLine;
		  tokLineStart = tokPos;
		}
	  } else if (ch > 8 && ch < 14) {
		++tokPos;
	  } else if (ch === 47) {
		var next = input.charCodeAt(tokPos + 1);
		if (next === 42) {
		  skipBlockComment();
		} else if (next === 47) {
		  skipLineComment();
		} else break;
	  } else if (ch === 160) {
		++tokPos;
	  } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
		++tokPos;
	  } else {
		break;
	  }
	}
  }

  function readToken_dot() {
	var next = input.charCodeAt(tokPos + 1);
	if (next >= 48 && next <= 57) return readNumber(true);
	++tokPos;
	return finishToken(_dot);
  }

  function readToken_slash() {
	var next = input.charCodeAt(tokPos + 1);
	if (tokRegexpAllowed) {++tokPos; return readRegexp();}
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_slash, 1);
  }

  function readToken_mult_modulo() {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_multiplyModulo, 1);
  }

  function readToken_pipe_amp(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
  }

  function readToken_caret() {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_bitwiseXOR, 1);
  }

  function readToken_plus_min(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === code) {
	  if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&
		  newline.test(input.slice(lastEnd, tokPos))) {
		tokPos += 3;
		skipLineComment();
		skipSpace();
		return readToken();
	  }
	  return finishOp(_incDec, 2);
	}
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_plusMin, 1);
  }

  function readToken_lt_gt(code) {
	var next = input.charCodeAt(tokPos + 1);
	var size = 1;
	if (next === code) {
	  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
	  if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
	  return finishOp(_bitShift, size);
	}
	if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&
		input.charCodeAt(tokPos + 3) == 45) {
	  tokPos += 4;
	  skipLineComment();
	  skipSpace();
	  return readToken();
	}
	if (next === 61)
	  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
	return finishOp(_relational, size);
  }

  function readToken_eq_excl(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
	return finishOp(code === 61 ? _eq : _prefix, 1);
  }

  function getTokenFromCode(code) {
	switch(code) {
	case 46:
	  return readToken_dot();

	case 40: ++tokPos; return finishToken(_parenL);
	case 41: ++tokPos; return finishToken(_parenR);
	case 59: ++tokPos; return finishToken(_semi);
	case 44: ++tokPos; return finishToken(_comma);
	case 91: ++tokPos; return finishToken(_bracketL);
	case 93: ++tokPos; return finishToken(_bracketR);
	case 123: ++tokPos; return finishToken(_braceL);
	case 125: ++tokPos; return finishToken(_braceR);
	case 58: ++tokPos; return finishToken(_colon);
	case 63: ++tokPos; return finishToken(_question);

	case 48:
	  var next = input.charCodeAt(tokPos + 1);
	  if (next === 120 || next === 88) return readHexNumber();
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:
	  return readNumber(false);

	case 34: case 39:
	  return readString(code);

	case 47:
	  return readToken_slash(code);

	case 37: case 42:
	  return readToken_mult_modulo();

	case 124: case 38:
	  return readToken_pipe_amp(code);

	case 94:
	  return readToken_caret();

	case 43: case 45:
	  return readToken_plus_min(code);

	case 60: case 62:
	  return readToken_lt_gt(code);

	case 61: case 33:
	  return readToken_eq_excl(code);

	case 126:
	  return finishOp(_prefix, 1);
	}

	return false;
  }

  function readToken(forceRegexp) {
	if (!forceRegexp) tokStart = tokPos;
	else tokPos = tokStart + 1;
	if (options.locations) tokStartLoc = new line_loc_t;
	if (forceRegexp) return readRegexp();
	if (tokPos >= inputLen) return finishToken(_eof);

	var code = input.charCodeAt(tokPos);
	if (isIdentifierStart(code) || code === 92 ) return readWord();

	var tok = getTokenFromCode(code);

	if (tok === false) {
	  var ch = String.fromCharCode(code);
	  if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
	  raise(tokPos, "Unexpected character '" + ch + "'");
	}
	return tok;
  }

  function finishOp(type, size) {
	var str = input.slice(tokPos, tokPos + size);
	tokPos += size;
	finishToken(type, str);
  }

  function readRegexp() {
	var content = "", escaped, inClass, start = tokPos;
	for (;;) {
	  if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
	  var ch = input.charAt(tokPos);
	  if (newline.test(ch)) raise(start, "Unterminated regular expression");
	  if (!escaped) {
		if (ch === "[") inClass = true;
		else if (ch === "]" && inClass) inClass = false;
		else if (ch === "/" && !inClass) break;
		escaped = ch === "\\";
	  } else escaped = false;
	  ++tokPos;
	}
	var content = input.slice(start, tokPos);
	++tokPos;
	var mods = readWord1();
	if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");
	try {
	  var value = new RegExp(content, mods);
	} catch (e) {
	  if (e instanceof SyntaxError) raise(start, e.message);
	  raise(e);
	}
	return finishToken(_regexp, value);
  }

  function readInt(radix, len) {
	var start = tokPos, total = 0;
	for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	  var code = input.charCodeAt(tokPos), val;
	  if (code >= 97) val = code - 97 + 10;
	  else if (code >= 65) val = code - 65 + 10;
	  else if (code >= 48 && code <= 57) val = code - 48;
	  else val = Infinity;
	  if (val >= radix) break;
	  ++tokPos;
	  total = total * radix + val;
	}
	if (tokPos === start || len != null && tokPos - start !== len) return null;

	return total;
  }

  function readHexNumber() {
	tokPos += 2;
	var val = readInt(16);
	if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
	if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
	return finishToken(_num, val);
  }

  function readNumber(startsWithDot) {
	var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
	if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
	if (input.charCodeAt(tokPos) === 46) {
	  ++tokPos;
	  readInt(10);
	  isFloat = true;
	}
	var next = input.charCodeAt(tokPos);
	if (next === 69 || next === 101) {
	  next = input.charCodeAt(++tokPos);
	  if (next === 43 || next === 45) ++tokPos;
	  if (readInt(10) === null) raise(start, "Invalid number");
	  isFloat = true;
	}
	if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");

	var str = input.slice(start, tokPos), val;
	if (isFloat) val = parseFloat(str);
	else if (!octal || str.length === 1) val = parseInt(str, 10);
	else if (/[89]/.test(str) || strict) raise(start, "Invalid number");
	else val = parseInt(str, 8);
	return finishToken(_num, val);
  }

  function readString(quote) {
	tokPos++;
	var out = "";
	for (;;) {
	  if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
	  var ch = input.charCodeAt(tokPos);
	  if (ch === quote) {
		++tokPos;
		return finishToken(_string, out);
	  }
	  if (ch === 92) {
		ch = input.charCodeAt(++tokPos);
		var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
		if (octal) octal = octal[0];
		while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
		if (octal === "0") octal = null;
		++tokPos;
		if (octal) {
		  if (strict) raise(tokPos - 2, "Octal literal in strict mode");
		  out += String.fromCharCode(parseInt(octal, 8));
		  tokPos += octal.length - 1;
		} else {
		  switch (ch) {
		  case 110: out += "\n"; break;
		  case 114: out += "\r"; break;
		  case 120: out += String.fromCharCode(readHexChar(2)); break;
		  case 117: out += String.fromCharCode(readHexChar(4)); break;
		  case 85: out += String.fromCharCode(readHexChar(8)); break;
		  case 116: out += "\t"; break;
		  case 98: out += "\b"; break;
		  case 118: out += "\u000b"; break;
		  case 102: out += "\f"; break;
		  case 48: out += "\0"; break;
		  case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;
		  case 10:
			if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }
			break;
		  default: out += String.fromCharCode(ch); break;
		  }
		}
	  } else {
		if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, "Unterminated string constant");
		out += String.fromCharCode(ch);
		++tokPos;
	  }
	}
  }

  function readHexChar(len) {
	var n = readInt(16, len);
	if (n === null) raise(tokStart, "Bad character escape sequence");
	return n;
  }

  var containsEsc;

  function readWord1() {
	containsEsc = false;
	var word, first = true, start = tokPos;
	for (;;) {
	  var ch = input.charCodeAt(tokPos);
	  if (isIdentifierChar(ch)) {
		if (containsEsc) word += input.charAt(tokPos);
		++tokPos;
	  } else if (ch === 92) {
		if (!containsEsc) word = input.slice(start, tokPos);
		containsEsc = true;
		if (input.charCodeAt(++tokPos) != 117)
		  raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
		++tokPos;
		var esc = readHexChar(4);
		var escStr = String.fromCharCode(esc);
		if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
		if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
		  raise(tokPos - 4, "Invalid Unicode escape");
		word += escStr;
	  } else {
		break;
	  }
	  first = false;
	}
	return containsEsc ? word : input.slice(start, tokPos);
  }

  function readWord() {
	var word = readWord1();
	var type = _name;
	if (!containsEsc && isKeyword(word))
	  type = keywordTypes[word];
	return finishToken(type, word);
  }

  function next() {
	lastStart = tokStart;
	lastEnd = tokEnd;
	lastEndLoc = tokEndLoc;
	readToken();
  }

  function setStrict(strct) {
	strict = strct;
	tokPos = tokStart;
	if (options.locations) {
	  while (tokPos < tokLineStart) {
		tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
		--tokCurLine;
	  }
	}
	skipSpace();
	readToken();
  }

  function node_t() {
	this.type = null;
	this.start = tokStart;
	this.end = null;
  }

  function node_loc_t() {
	this.start = tokStartLoc;
	this.end = null;
	if (sourceFile !== null) this.source = sourceFile;
  }

  function startNode() {
	var node = new node_t();
	if (options.locations)
	  node.loc = new node_loc_t();
	if (options.directSourceFile)
	  node.sourceFile = options.directSourceFile;
	if (options.ranges)
	  node.range = [tokStart, 0];
	return node;
  }

  function startNodeFrom(other) {
	var node = new node_t();
	node.start = other.start;
	if (options.locations) {
	  node.loc = new node_loc_t();
	  node.loc.start = other.loc.start;
	}
	if (options.ranges)
	  node.range = [other.range[0], 0];

	return node;
  }

  function finishNode(node, type) {
	node.type = type;
	node.end = lastEnd;
	if (options.locations)
	  node.loc.end = lastEndLoc;
	if (options.ranges)
	  node.range[1] = lastEnd;
	return node;
  }

  function isUseStrict(stmt) {
	return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
	  stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
  }

  function eat(type) {
	if (tokType === type) {
	  next();
	  return true;
	}
  }

  function canInsertSemicolon() {
	return !options.strictSemicolons &&
	  (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
  }

  function semicolon() {
	if (!eat(_semi) && !canInsertSemicolon()) unexpected();
  }

  function expect(type) {
	if (tokType === type) next();
	else unexpected();
  }

  function unexpected() {
	raise(tokStart, "Unexpected token");
  }

  function checkLVal(expr) {
	if (expr.type !== "Identifier" && expr.type !== "MemberExpression")
	  raise(expr.start, "Assigning to rvalue");
	if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name))
	  raise(expr.start, "Assigning to " + expr.name + " in strict mode");
  }

  function parseTopLevel(program) {
	lastStart = lastEnd = tokPos;
	if (options.locations) lastEndLoc = new line_loc_t;
	inFunction = strict = null;
	labels = [];
	readToken();

	var node = program || startNode(), first = true;
	if (!program) node.body = [];
	while (tokType !== _eof) {
	  var stmt = parseStatement();
	  node.body.push(stmt);
	  if (first && isUseStrict(stmt)) setStrict(true);
	  first = false;
	}
	return finishNode(node, "Program");
  }

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  function parseStatement() {
	if (tokType === _slash || tokType === _assign && tokVal == "/=")
	  readToken(true);

	var starttype = tokType, node = startNode();

	switch (starttype) {
	case _break: case _continue:
	  next();
	  var isBreak = starttype === _break;
	  if (eat(_semi) || canInsertSemicolon()) node.label = null;
	  else if (tokType !== _name) unexpected();
	  else {
		node.label = parseIdent();
		semicolon();
	  }

	  for (var i = 0; i < labels.length; ++i) {
		var lab = labels[i];
		if (node.label == null || lab.name === node.label.name) {
		  if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
		  if (node.label && isBreak) break;
		}
	  }
	  if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
	  return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

	case _debugger:
	  next();
	  semicolon();
	  return finishNode(node, "DebuggerStatement");

	case _do:
	  next();
	  labels.push(loopLabel);
	  node.body = parseStatement();
	  labels.pop();
	  expect(_while);
	  node.test = parseParenExpression();
	  semicolon();
	  return finishNode(node, "DoWhileStatement");

	case _for:
	  next();
	  labels.push(loopLabel);
	  expect(_parenL);
	  if (tokType === _semi) return parseFor(node, null);
	  if (tokType === _var) {
		var init = startNode();
		next();
		parseVar(init, true);
		finishNode(init, "VariableDeclaration");
		if (init.declarations.length === 1 && eat(_in))
		  return parseForIn(node, init);
		return parseFor(node, init);
	  }
	  var init = parseExpression(false, true);
	  if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}
	  return parseFor(node, init);

	case _function:
	  next();
	  return parseFunction(node, true);

	case _if:
	  next();
	  node.test = parseParenExpression();
	  node.consequent = parseStatement();
	  node.alternate = eat(_else) ? parseStatement() : null;
	  return finishNode(node, "IfStatement");

	case _return:
	  if (!inFunction && !options.allowReturnOutsideFunction)
		raise(tokStart, "'return' outside of function");
	  next();

	  if (eat(_semi) || canInsertSemicolon()) node.argument = null;
	  else { node.argument = parseExpression(); semicolon(); }
	  return finishNode(node, "ReturnStatement");

	case _switch:
	  next();
	  node.discriminant = parseParenExpression();
	  node.cases = [];
	  expect(_braceL);
	  labels.push(switchLabel);

	  for (var cur, sawDefault; tokType != _braceR;) {
		if (tokType === _case || tokType === _default) {
		  var isCase = tokType === _case;
		  if (cur) finishNode(cur, "SwitchCase");
		  node.cases.push(cur = startNode());
		  cur.consequent = [];
		  next();
		  if (isCase) cur.test = parseExpression();
		  else {
			if (sawDefault) raise(lastStart, "Multiple default clauses"); sawDefault = true;
			cur.test = null;
		  }
		  expect(_colon);
		} else {
		  if (!cur) unexpected();
		  cur.consequent.push(parseStatement());
		}
	  }
	  if (cur) finishNode(cur, "SwitchCase");
	  next();
	  labels.pop();
	  return finishNode(node, "SwitchStatement");

	case _throw:
	  next();
	  if (newline.test(input.slice(lastEnd, tokStart)))
		raise(lastEnd, "Illegal newline after throw");
	  node.argument = parseExpression();
	  semicolon();
	  return finishNode(node, "ThrowStatement");

	case _try:
	  next();
	  node.block = parseBlock();
	  node.handler = null;
	  if (tokType === _catch) {
		var clause = startNode();
		next();
		expect(_parenL);
		clause.param = parseIdent();
		if (strict && isStrictBadIdWord(clause.param.name))
		  raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
		expect(_parenR);
		clause.guard = null;
		clause.body = parseBlock();
		node.handler = finishNode(clause, "CatchClause");
	  }
	  node.guardedHandlers = empty;
	  node.finalizer = eat(_finally) ? parseBlock() : null;
	  if (!node.handler && !node.finalizer)
		raise(node.start, "Missing catch or finally clause");
	  return finishNode(node, "TryStatement");

	case _var:
	  next();
	  parseVar(node);
	  semicolon();
	  return finishNode(node, "VariableDeclaration");

	case _while:
	  next();
	  node.test = parseParenExpression();
	  labels.push(loopLabel);
	  node.body = parseStatement();
	  labels.pop();
	  return finishNode(node, "WhileStatement");

	case _with:
	  if (strict) raise(tokStart, "'with' in strict mode");
	  next();
	  node.object = parseParenExpression();
	  node.body = parseStatement();
	  return finishNode(node, "WithStatement");

	case _braceL:
	  return parseBlock();

	case _semi:
	  next();
	  return finishNode(node, "EmptyStatement");

	default:
	  var maybeName = tokVal, expr = parseExpression();
	  if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
		for (var i = 0; i < labels.length; ++i)
		  if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
		var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
		labels.push({name: maybeName, kind: kind});
		node.body = parseStatement();
		labels.pop();
		node.label = expr;
		return finishNode(node, "LabeledStatement");
	  } else {
		node.expression = expr;
		semicolon();
		return finishNode(node, "ExpressionStatement");
	  }
	}
  }

  function parseParenExpression() {
	expect(_parenL);
	var val = parseExpression();
	expect(_parenR);
	return val;
  }

  function parseBlock(allowStrict) {
	var node = startNode(), first = true, strict = false, oldStrict;
	node.body = [];
	expect(_braceL);
	while (!eat(_braceR)) {
	  var stmt = parseStatement();
	  node.body.push(stmt);
	  if (first && allowStrict && isUseStrict(stmt)) {
		oldStrict = strict;
		setStrict(strict = true);
	  }
	  first = false;
	}
	if (strict && !oldStrict) setStrict(false);
	return finishNode(node, "BlockStatement");
  }

  function parseFor(node, init) {
	node.init = init;
	expect(_semi);
	node.test = tokType === _semi ? null : parseExpression();
	expect(_semi);
	node.update = tokType === _parenR ? null : parseExpression();
	expect(_parenR);
	node.body = parseStatement();
	labels.pop();
	return finishNode(node, "ForStatement");
  }

  function parseForIn(node, init) {
	node.left = init;
	node.right = parseExpression();
	expect(_parenR);
	node.body = parseStatement();
	labels.pop();
	return finishNode(node, "ForInStatement");
  }

  function parseVar(node, noIn) {
	node.declarations = [];
	node.kind = "var";
	for (;;) {
	  var decl = startNode();
	  decl.id = parseIdent();
	  if (strict && isStrictBadIdWord(decl.id.name))
		raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
	  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
	  node.declarations.push(finishNode(decl, "VariableDeclarator"));
	  if (!eat(_comma)) break;
	}
	return node;
  }

  function parseExpression(noComma, noIn) {
	var expr = parseMaybeAssign(noIn);
	if (!noComma && tokType === _comma) {
	  var node = startNodeFrom(expr);
	  node.expressions = [expr];
	  while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
	  return finishNode(node, "SequenceExpression");
	}
	return expr;
  }

  function parseMaybeAssign(noIn) {
	var left = parseMaybeConditional(noIn);
	if (tokType.isAssign) {
	  var node = startNodeFrom(left);
	  node.operator = tokVal;
	  node.left = left;
	  next();
	  node.right = parseMaybeAssign(noIn);
	  checkLVal(left);
	  return finishNode(node, "AssignmentExpression");
	}
	return left;
  }

  function parseMaybeConditional(noIn) {
	var expr = parseExprOps(noIn);
	if (eat(_question)) {
	  var node = startNodeFrom(expr);
	  node.test = expr;
	  node.consequent = parseExpression(true);
	  expect(_colon);
	  node.alternate = parseExpression(true, noIn);
	  return finishNode(node, "ConditionalExpression");
	}
	return expr;
  }

  function parseExprOps(noIn) {
	return parseExprOp(parseMaybeUnary(), -1, noIn);
  }

  function parseExprOp(left, minPrec, noIn) {
	var prec = tokType.binop;
	if (prec != null && (!noIn || tokType !== _in)) {
	  if (prec > minPrec) {
		var node = startNodeFrom(left);
		node.left = left;
		node.operator = tokVal;
		var op = tokType;
		next();
		node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
		var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? "LogicalExpression" : "BinaryExpression");
		return parseExprOp(exprNode, minPrec, noIn);
	  }
	}
	return left;
  }

  function parseMaybeUnary() {
	if (tokType.prefix) {
	  var node = startNode(), update = tokType.isUpdate;
	  node.operator = tokVal;
	  node.prefix = true;
	  tokRegexpAllowed = true;
	  next();
	  node.argument = parseMaybeUnary();
	  if (update) checkLVal(node.argument);
	  else if (strict && node.operator === "delete" &&
			   node.argument.type === "Identifier")
		raise(node.start, "Deleting local variable in strict mode");
	  return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	}
	var expr = parseExprSubscripts();
	while (tokType.postfix && !canInsertSemicolon()) {
	  var node = startNodeFrom(expr);
	  node.operator = tokVal;
	  node.prefix = false;
	  node.argument = expr;
	  checkLVal(expr);
	  next();
	  expr = finishNode(node, "UpdateExpression");
	}
	return expr;
  }

  function parseExprSubscripts() {
	return parseSubscripts(parseExprAtom());
  }

  function parseSubscripts(base, noCalls) {
	if (eat(_dot)) {
	  var node = startNodeFrom(base);
	  node.object = base;
	  node.property = parseIdent(true);
	  node.computed = false;
	  return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
	} else if (eat(_bracketL)) {
	  var node = startNodeFrom(base);
	  node.object = base;
	  node.property = parseExpression();
	  node.computed = true;
	  expect(_bracketR);
	  return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
	} else if (!noCalls && eat(_parenL)) {
	  var node = startNodeFrom(base);
	  node.callee = base;
	  node.arguments = parseExprList(_parenR, false);
	  return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
	} else return base;
  }

  function parseExprAtom() {
	switch (tokType) {
	case _this:
	  var node = startNode();
	  next();
	  return finishNode(node, "ThisExpression");
	case _name:
	  return parseIdent();
	case _num: case _string: case _regexp:
	  var node = startNode();
	  node.value = tokVal;
	  node.raw = input.slice(tokStart, tokEnd);
	  next();
	  return finishNode(node, "Literal");

	case _null: case _true: case _false:
	  var node = startNode();
	  node.value = tokType.atomValue;
	  node.raw = tokType.keyword;
	  next();
	  return finishNode(node, "Literal");

	case _parenL:
	  var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;
	  next();
	  var val = parseExpression();
	  val.start = tokStart1;
	  val.end = tokEnd;
	  if (options.locations) {
		val.loc.start = tokStartLoc1;
		val.loc.end = tokEndLoc;
	  }
	  if (options.ranges)
		val.range = [tokStart1, tokEnd];
	  expect(_parenR);
	  return val;

	case _bracketL:
	  var node = startNode();
	  next();
	  node.elements = parseExprList(_bracketR, true, true);
	  return finishNode(node, "ArrayExpression");

	case _braceL:
	  return parseObj();

	case _function:
	  var node = startNode();
	  next();
	  return parseFunction(node, false);

	case _new:
	  return parseNew();

	default:
	  unexpected();
	}
  }

  function parseNew() {
	var node = startNode();
	next();
	node.callee = parseSubscripts(parseExprAtom(), true);
	if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);
	else node.arguments = empty;
	return finishNode(node, "NewExpression");
  }

  function parseObj() {
	var node = startNode(), first = true, sawGetSet = false;
	node.properties = [];
	next();
	while (!eat(_braceR)) {
	  if (!first) {
		expect(_comma);
		if (options.allowTrailingCommas && eat(_braceR)) break;
	  } else first = false;

	  var prop = {key: parsePropertyName()}, isGetSet = false, kind;
	  if (eat(_colon)) {
		prop.value = parseExpression(true);
		kind = prop.kind = "init";
	  } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" &&
				 (prop.key.name === "get" || prop.key.name === "set")) {
		isGetSet = sawGetSet = true;
		kind = prop.kind = prop.key.name;
		prop.key = parsePropertyName();
		if (tokType !== _parenL) unexpected();
		prop.value = parseFunction(startNode(), false);
	  } else unexpected();

	  if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
		for (var i = 0; i < node.properties.length; ++i) {
		  var other = node.properties[i];
		  if (other.key.name === prop.key.name) {
			var conflict = kind == other.kind || isGetSet && other.kind === "init" ||
			  kind === "init" && (other.kind === "get" || other.kind === "set");
			if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
			if (conflict) raise(prop.key.start, "Redefinition of property");
		  }
		}
	  }
	  node.properties.push(prop);
	}
	return finishNode(node, "ObjectExpression");
  }

  function parsePropertyName() {
	if (tokType === _num || tokType === _string) return parseExprAtom();
	return parseIdent(true);
  }

  function parseFunction(node, isStatement) {
	if (tokType === _name) node.id = parseIdent();
	else if (isStatement) unexpected();
	else node.id = null;
	node.params = [];
	var first = true;
	expect(_parenL);
	while (!eat(_parenR)) {
	  if (!first) expect(_comma); else first = false;
	  node.params.push(parseIdent());
	}

	var oldInFunc = inFunction, oldLabels = labels;
	inFunction = true; labels = [];
	node.body = parseBlock(true);
	inFunction = oldInFunc; labels = oldLabels;

	if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
	  for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
		var id = i < 0 ? node.id : node.params[i];
		if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))
		  raise(id.start, "Defining '" + id.name + "' in strict mode");
		if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)
		  raise(id.start, "Argument name clash in strict mode");
	  }
	}

	return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  }

  function parseExprList(close, allowTrailingComma, allowEmpty) {
	var elts = [], first = true;
	while (!eat(close)) {
	  if (!first) {
		expect(_comma);
		if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
	  } else first = false;

	  if (allowEmpty && tokType === _comma) elts.push(null);
	  else elts.push(parseExpression(true));
	}
	return elts;
  }

  function parseIdent(liberal) {
	var node = startNode();
	if (liberal && options.forbidReserved == "everywhere") liberal = false;
	if (tokType === _name) {
	  if (!liberal &&
		  (options.forbidReserved &&
		   (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||
		   strict && isStrictReservedWord(tokVal)) &&
		  input.slice(tokStart, tokEnd).indexOf("\\") == -1)
		raise(tokStart, "The keyword '" + tokVal + "' is reserved");
	  node.name = tokVal;
	} else if (liberal && tokType.keyword) {
	  node.name = tokType.keyword;
	} else {
	  unexpected();
	}
	tokRegexpAllowed = false;
	next();
	return finishNode(node, "Identifier");
  }

});

		if (!acorn.version)
			acorn = null;
	}

	function parse(code, options) {
		return (global.acorn || acorn).parse(code, options);
	}

	var binaryOperators = {
		'+': '__add',
		'-': '__subtract',
		'*': '__multiply',
		'/': '__divide',
		'%': '__modulo',
		'==': '__equals',
		'!=': '__equals'
	};

	var unaryOperators = {
		'-': '__negate',
		'+': '__self'
	};

	var fields = Base.each(
		['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],
		function(name) {
			this['__' + name] = '#' + name;
		},
		{
			__self: function() {
				return this;
			}
		}
	);
	Point.inject(fields);
	Size.inject(fields);
	Color.inject(fields);

	function __$__(left, operator, right) {
		var handler = binaryOperators[operator];
		if (left && left[handler]) {
			var res = left[handler](right);
			return operator === '!=' ? !res : res;
		}
		switch (operator) {
		case '+': return left + right;
		case '-': return left - right;
		case '*': return left * right;
		case '/': return left / right;
		case '%': return left % right;
		case '==': return left == right;
		case '!=': return left != right;
		}
	}

	function $__(operator, value) {
		var handler = unaryOperators[operator];
		if (value && value[handler])
			return value[handler]();
		switch (operator) {
		case '+': return +value;
		case '-': return -value;
		}
	}

	function compile(code, options) {
		if (!code)
			return '';
		options = options || {};

		var insertions = [];

		function getOffset(offset) {
			for (var i = 0, l = insertions.length; i < l; i++) {
				var insertion = insertions[i];
				if (insertion[0] >= offset)
					break;
				offset += insertion[1];
			}
			return offset;
		}

		function getCode(node) {
			return code.substring(getOffset(node.range[0]),
					getOffset(node.range[1]));
		}

		function getBetween(left, right) {
			return code.substring(getOffset(left.range[1]),
					getOffset(right.range[0]));
		}

		function replaceCode(node, str) {
			var start = getOffset(node.range[0]),
				end = getOffset(node.range[1]),
				insert = 0;
			for (var i = insertions.length - 1; i >= 0; i--) {
				if (start > insertions[i][0]) {
					insert = i + 1;
					break;
				}
			}
			insertions.splice(insert, 0, [start, str.length - end + start]);
			code = code.substring(0, start) + str + code.substring(end);
		}

		function handleOverloading(node, parent) {
			switch (node.type) {
			case 'UnaryExpression':
				if (node.operator in unaryOperators
						&& node.argument.type !== 'Literal') {
					var arg = getCode(node.argument);
					replaceCode(node, '$__("' + node.operator + '", '
							+ arg + ')');
				}
				break;
			case 'BinaryExpression':
				if (node.operator in binaryOperators
						&& node.left.type !== 'Literal') {
					var left = getCode(node.left),
						right = getCode(node.right),
						between = getBetween(node.left, node.right),
						operator = node.operator;
					replaceCode(node, '__$__(' + left + ','
							+ between.replace(new RegExp('\\' + operator),
								'"' + operator + '"')
							+ ', ' + right + ')');
				}
				break;
			case 'UpdateExpression':
			case 'AssignmentExpression':
				var parentType = parent && parent.type;
				if (!(
						parentType === 'ForStatement'
						|| parentType === 'BinaryExpression'
							&& /^[=!<>]/.test(parent.operator)
						|| parentType === 'MemberExpression' && parent.computed
				)) {
					if (node.type === 'UpdateExpression') {
						var arg = getCode(node.argument),
							exp = '__$__(' + arg + ', "' + node.operator[0]
									+ '", 1)',
							str = arg + ' = ' + exp;
						if (node.prefix) {
							str = '(' + str + ')';
						} else if (
							parentType === 'AssignmentExpression' ||
							parentType === 'VariableDeclarator' ||
							parentType === 'BinaryExpression'
						) {
							if (getCode(parent.left || parent.id) === arg)
								str = exp;
							str = arg + '; ' + str;
						}
						replaceCode(node, str);
					} else {
						if (/^.=$/.test(node.operator)
								&& node.left.type !== 'Literal') {
							var left = getCode(node.left),
								right = getCode(node.right),
								exp = left + ' = __$__(' + left + ', "'
									+ node.operator[0] + '", ' + right + ')';
							replaceCode(node, /^\(.*\)$/.test(getCode(node))
									? '(' + exp + ')' : exp);
						}
					}
				}
				break;
			}
		}

		function handleExports(node) {
			switch (node.type) {
			case 'ExportDefaultDeclaration':
				replaceCode({
					range: [node.start, node.declaration.start]
				}, 'module.exports = ');
				break;
			case 'ExportNamedDeclaration':
				var declaration = node.declaration;
				var specifiers = node.specifiers;
				if (declaration) {
					var declarations = declaration.declarations;
					if (declarations) {
						declarations.forEach(function(dec) {
							replaceCode(dec, 'module.exports.' + getCode(dec));
						});
						replaceCode({
							range: [
								node.start,
								declaration.start + declaration.kind.length
							]
						}, '');
					}
				} else if (specifiers) {
					var exports = specifiers.map(function(specifier) {
						var name = getCode(specifier);
						return 'module.exports.' + name + ' = ' + name + '; ';
					}).join('');
					if (exports) {
						replaceCode(node, exports);
					}
				}
				break;
			}
		}

		function walkAST(node, parent, paperFeatures) {
			if (node) {
				for (var key in node) {
					if (key !== 'range' && key !== 'loc') {
						var value = node[key];
						if (Array.isArray(value)) {
							for (var i = 0, l = value.length; i < l; i++) {
								walkAST(value[i], node, paperFeatures);
							}
						} else if (value && typeof value === 'object') {
							walkAST(value, node, paperFeatures);
						}
					}
				}
				if (paperFeatures.operatorOverloading !== false) {
					handleOverloading(node, parent);
				}
				if (paperFeatures.moduleExports !== false) {
					handleExports(node);
				}
			}
		}

		function encodeVLQ(value) {
			var res = '',
				base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
			value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);
			while (value || !res) {
				var next = value & (32 - 1);
				value >>= 5;
				if (value)
					next |= 32;
				res += base64[next];
			}
			return res;
		}

		var url = options.url || '',
			sourceMaps = options.sourceMaps,
			paperFeatures = options.paperFeatures || {},
			source = options.source || code,
			offset = options.offset || 0,
			agent = paper.agent,
			version = agent.versionNumber,
			offsetCode = false,
			lineBreaks = /\r\n|\n|\r/mg,
			map;
		if (sourceMaps && (agent.chrome && version >= 30
				|| agent.webkit && version >= 537.76
				|| agent.firefox && version >= 23
				|| agent.node)) {
			if (agent.node) {
				offset -= 2;
			} else if (window && url && !window.location.href.indexOf(url)) {
				var html = document.getElementsByTagName('html')[0].innerHTML;
				offset = html.substr(0, html.indexOf(code) + 1).match(
						lineBreaks).length + 1;
			}
			offsetCode = offset > 0 && !(
					agent.chrome && version >= 36 ||
					agent.safari && version >= 600 ||
					agent.firefox && version >= 40 ||
					agent.node);
			var mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];
			mappings.length = (code.match(lineBreaks) || []).length + 1
					+ (offsetCode ? offset : 0);
			map = {
				version: 3,
				file: url,
				names:[],
				mappings: mappings.join(';AACA'),
				sourceRoot: '',
				sources: [url],
				sourcesContent: [source]
			};
		}
		if (
			paperFeatures.operatorOverloading !== false ||
			paperFeatures.moduleExports !== false
		) {
			walkAST(parse(code, {
				ranges: true,
				preserveParens: true,
				sourceType: 'module'
			}), null, paperFeatures);
		}
		if (map) {
			if (offsetCode) {
				code = new Array(offset + 1).join('\n') + code;
			}
			if (/^(inline|both)$/.test(sourceMaps)) {
				code += "\n//# sourceMappingURL=data:application/json;base64,"
						+ self.btoa(unescape(encodeURIComponent(
							JSON.stringify(map))));
			}
			code += "\n//# sourceURL=" + (url || 'paperscript');
		}
		return {
			url: url,
			source: source,
			code: code,
			map: map
		};
	}

	function execute(code, scope, options) {
		paper = scope;
		var view = scope.getView(),
			tool = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/
					.test(code) && !/\bnew\s+Tool\b/.test(code)
						? new Tool() : null,
			toolHandlers = tool ? tool._events : [],
			handlers = ['onFrame', 'onResize'].concat(toolHandlers),
			params = [],
			args = [],
			func,
			compiled = typeof code === 'object' ? code : compile(code, options);
		code = compiled.code;
		function expose(scope, hidden) {
			for (var key in scope) {
				if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)'
						+ key.replace(/\$/g, '\\$') + '\\b').test(code)) {
					params.push(key);
					args.push(scope[key]);
				}
			}
		}
		expose({ __$__: __$__, $__: $__, paper: scope, tool: tool },
				true);
		expose(scope);
		code = 'var module = { exports: {} }; ' + code;
		var exports = Base.each(handlers, function(key) {
			if (new RegExp('\\s+' + key + '\\b').test(code)) {
				params.push(key);
				this.push('module.exports.' + key + ' = ' + key + ';');
			}
		}, []).join('\n');
		if (exports) {
			code += '\n' + exports;
		}
		code += '\nreturn module.exports;';
		var agent = paper.agent;
		if (document && (agent.chrome
				|| agent.firefox && agent.versionNumber < 40)) {
			var script = document.createElement('script'),
				head = document.head || document.getElementsByTagName('head')[0];
			if (agent.firefox)
				code = '\n' + code;
			script.appendChild(document.createTextNode(
				'document.__paperscript__ = function(' + params + ') {' +
					code +
				'\n}'
			));
			head.appendChild(script);
			func = document.__paperscript__;
			delete document.__paperscript__;
			head.removeChild(script);
		} else {
			func = Function(params, code);
		}
		var exports = func && func.apply(scope, args);
		var obj = exports || {};
		Base.each(toolHandlers, function(key) {
			var value = obj[key];
			if (value)
				tool[key] = value;
		});
		if (view) {
			if (obj.onResize)
				view.setOnResize(obj.onResize);
			view.emit('resize', {
				size: view.size,
				delta: new Point()
			});
			if (obj.onFrame)
				view.setOnFrame(obj.onFrame);
			view.requestUpdate();
		}
		return exports;
	}

	function loadScript(script) {
		if (/^text\/(?:x-|)paperscript$/.test(script.type)
				&& PaperScope.getAttribute(script, 'ignore') !== 'true') {
			var canvasId = PaperScope.getAttribute(script, 'canvas'),
				canvas = document.getElementById(canvasId),
				src = script.src || script.getAttribute('data-src'),
				async = PaperScope.hasAttribute(script, 'async'),
				scopeAttribute = 'data-paper-scope';
			if (!canvas)
				throw new Error('Unable to find canvas with id "'
						+ canvasId + '"');
			var scope = PaperScope.get(canvas.getAttribute(scopeAttribute))
						|| new PaperScope().setup(canvas);
			canvas.setAttribute(scopeAttribute, scope._id);
			if (src) {
				Http.request({
					url: src,
					async: async,
					mimeType: 'text/plain',
					onLoad: function(code) {
						execute(code, scope, src);
					}
				});
			} else {
				execute(script.innerHTML, scope, script.baseURI);
			}
			script.setAttribute('data-paper-ignore', 'true');
			return scope;
		}
	}

	function loadAll() {
		Base.each(document && document.getElementsByTagName('script'),
				loadScript);
	}

	function load(script) {
		return script ? loadScript(script) : loadAll();
	}

	if (window) {
		if (document.readyState === 'complete') {
			setTimeout(loadAll);
		} else {
			DomEvent.add(window, { load: loadAll });
		}
	}

	return {
		compile: compile,
		execute: execute,
		load: load,
		parse: parse,
		calculateBinary: __$__,
		calculateUnary: $__
	};

}.call(this);

var paper = new (PaperScope.inject(Base.exports, {
	Base: Base,
	Numerical: Numerical,
	Key: Key,
	DomEvent: DomEvent,
	DomElement: DomElement,
	document: document,
	window: window,
	Symbol: SymbolDefinition,
	PlacedSymbol: SymbolItem
}))();

if (paper.agent.node) {
	__webpack_require__(96)(paper);
}

if (true) {
	!(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

return paper;
}.call(this, typeof self === 'object' ? self : null);


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.selectRootItem = exports.processRectangularSelection = exports.getSelectedSegments = exports.getSelectedRootItems = exports.getSelectedLeafItems = exports.setItemSelection = exports.cloneSelection = exports.deleteSelection = exports.clearSelection = exports.selectAllSegments = exports.selectAllItems = exports.getAllSelectableRootItems = exports.getAllRootItems = exports.getItems = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _group = __webpack_require__(24);

var _item = __webpack_require__(26);

var _compoundPath = __webpack_require__(48);

var _math = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Wrapper for paper.project.getItems that excludes our helper items
 * @param {?object} options See paper.js docs for paper.Item.getItems
 * @return {Array<paper.Item>} items that match options
 */
var getItems = function getItems(options) {
    var newMatcher = function newMatcher(item) {
        return !(item instanceof _paper2.default.Layer) && item.layer.data && item.layer.data.isPaintingLayer && !item.locked && !item.isClipMask() && !(item.data && item.data.isHelperItem) && (!options.match || options.match(item));
    };
    var newOptions = _extends({}, options, { match: newMatcher });
    return _paper2.default.project.getItems(newOptions);
};

/**
 * @param {boolean} includeGuides True if guide layer items like the bounding box should
 *     be included in the returned items.
 * @return {Array<paper.item>} all top-level (direct descendants of a paper.Layer) items
 */
var getAllRootItems = function getAllRootItems(includeGuides) {
    includeGuides = includeGuides || false;
    var allItems = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = _paper2.default.project.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var layer = _step.value;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = layer.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var child = _step2.value;

                    // don't give guides back
                    if (!includeGuides && child.guide) {
                        continue;
                    }
                    allItems.push(child);
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return allItems;
};

/**
 * @return {Array<paper.item>} all top-level (direct descendants of a paper.Layer) items
 *     that aren't guide items or helper items.
 */
var getAllSelectableRootItems = function getAllSelectableRootItems() {
    var allItems = getAllRootItems();
    var selectables = [];
    for (var i = 0; i < allItems.length; i++) {
        if (allItems[i].data && !allItems[i].data.isHelperItem) {
            selectables.push(allItems[i]);
        }
    }
    return selectables;
};

var selectItemSegments = function selectItemSegments(item, state) {
    if (item.children) {
        for (var i = 0; i < item.children.length; i++) {
            var child = item.children[i];
            if (child.children && child.children.length > 0) {
                selectItemSegments(child, state);
            } else {
                child.fullySelected = state;
            }
        }
    } else {
        for (var _i = 0; _i < item.segments.length; _i++) {
            item.segments[_i].selected = state;
        }
    }
};

var _setGroupSelection = function _setGroupSelection(root, selected, fullySelected) {
    root.fullySelected = fullySelected;
    root.selected = selected;
    // select children of compound-path or group
    if ((0, _compoundPath.isCompoundPath)(root) || (0, _group.isGroup)(root)) {
        var children = root.children;
        if (children) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var child = _step3.value;

                    if ((0, _group.isGroup)(child)) {
                        _setGroupSelection(child, selected, fullySelected);
                    } else {
                        child.fullySelected = fullySelected;
                        child.selected = selected;
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
        }
    }
};

var setItemSelection = function setItemSelection(item, state, fullySelected) {
    var parentGroup = (0, _group.getItemsGroup)(item);
    var itemsCompoundPath = (0, _compoundPath.getItemsCompoundPath)(item);

    // if selection is in a group, select group
    if (parentGroup) {
        // do it recursive
        setItemSelection(parentGroup, state, fullySelected);
    } else if (itemsCompoundPath) {
        _setGroupSelection(itemsCompoundPath, state, fullySelected);
    } else {
        if (item.data && item.data.noSelect) {
            return;
        }
        _setGroupSelection(item, state, fullySelected);
    }
};

/** @return {boolean} true if anything was selected */
var selectAllItems = function selectAllItems() {
    var items = getAllSelectableRootItems();
    if (items.length === 0) return false;

    for (var i = 0; i < items.length; i++) {
        setItemSelection(items[i], true);
    }
    return true;
};

/** @return {boolean} true if anything was selected */
var selectAllSegments = function selectAllSegments() {
    var items = getAllSelectableRootItems();
    if (items.length === 0) return false;

    for (var i = 0; i < items.length; i++) {
        selectItemSegments(items[i], true);
    }
    return true;
};

/** @param {!function} dispatchClearSelect Function to update the Redux select state */
var clearSelection = function clearSelection(dispatchClearSelect) {
    _paper2.default.project.deselectAll();
    dispatchClearSelect();
};

/**
 * This gets all selected non-grouped items and groups
 * (alternative to paper.project.selectedItems, which includes
 * group children in addition to the group)
 * @return {Array<paper.Item>} in increasing Z order.
 */
var getSelectedRootItems = function getSelectedRootItems() {
    var allItems = getAllSelectableRootItems();
    var items = [];

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = allItems[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var item = _step4.value;

            if (item.selected) {
                items.push(item);
            } else if (item instanceof _paper2.default.CompoundPath) {
                // Consider a compound path selected if any of its paths are selected
                var _iteratorNormalCompletion5 = true;
                var _didIteratorError5 = false;
                var _iteratorError5 = undefined;

                try {
                    for (var _iterator5 = item.children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        var child = _step5.value;

                        if (child.selected) {
                            items.push(item);
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError5 = true;
                    _iteratorError5 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion5 && _iterator5.return) {
                            _iterator5.return();
                        }
                    } finally {
                        if (_didIteratorError5) {
                            throw _iteratorError5;
                        }
                    }
                }
            }
        }

        // sort items by index (0 at bottom)
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    items.sort(function (a, b) {
        return parseFloat(a.index) - parseFloat(b.index);
    });
    return items;
};

/**
 * This gets all selected items that are as deeply nested as possible. Does not
 * return the parent groups.
 * @return {Array<paper.Item>} in increasing Z order.
 */
var getSelectedLeafItems = function getSelectedLeafItems() {
    var allItems = _paper2.default.project.selectedItems;
    var items = [];

    for (var i = 0; i < allItems.length; i++) {
        var item = allItems[i];
        if (!(item instanceof _paper2.default.Layer) && !(0, _group.isGroup)(item) && item.data && !item.data.isSelectionBound) {
            items.push(item);
        }
    }
    items.sort(_math.sortItemsByZIndex);
    return items;
};

/**
 * This gets all selected path segments.
 * @return {Array<paper.Segment>} selected segments
 */
var getSelectedSegments = function getSelectedSegments() {
    var selected = getSelectedLeafItems();
    var segments = [];
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
        for (var _iterator6 = selected[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var item = _step6.value;

            if (!item.segments) {
                continue;
            }
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
                for (var _iterator7 = item.segments[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    var seg = _step7.value;

                    if (seg.selected) {
                        segments.push(seg);
                    }
                }
            } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
                        _iterator7.return();
                    }
                } finally {
                    if (_didIteratorError7) {
                        throw _iteratorError7;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
                _iterator6.return();
            }
        } finally {
            if (_didIteratorError6) {
                throw _iteratorError6;
            }
        }
    }

    return segments;
};

var _deleteItemSelection = function _deleteItemSelection(items, onUpdateImage) {
    // @todo: Update toolbar state on change
    if (items.length === 0) {
        return false;
    }
    for (var i = 0; i < items.length; i++) {
        items[i].remove();
    }
    onUpdateImage();
    return true;
};

// Return true if anything was removed
var _removeSelectedSegments = function _removeSelectedSegments(items, onUpdateImage) {
    var segmentsToRemove = [];

    for (var i = 0; i < items.length; i++) {
        if (!items[i].segments) continue;
        var segments = items[i].segments;
        for (var j = 0; j < segments.length; j++) {
            var seg = segments[j];
            if (seg.selected) {
                segmentsToRemove.push(seg);
            }
        }
    }

    var removedSegments = false;
    for (var _i2 = 0; _i2 < segmentsToRemove.length; _i2++) {
        var _seg = segmentsToRemove[_i2];
        _seg.remove();
        removedSegments = true;
    }
    if (removedSegments) {
        onUpdateImage();
    }
    return removedSegments;
};

// Return whether anything was deleted
var deleteSelection = function deleteSelection(mode, onUpdateImage) {
    if (mode === _modes2.default.RESHAPE) {
        var _selectedItems = getSelectedLeafItems();
        // If there are points selected remove them. If not delete the item selected.
        if (_removeSelectedSegments(_selectedItems, onUpdateImage)) {
            return true;
        }
        return _deleteItemSelection(_selectedItems, onUpdateImage);
    }
    var selectedItems = getSelectedRootItems();
    return _deleteItemSelection(selectedItems, onUpdateImage);
};

var cloneSelection = function cloneSelection(recursive, onUpdateImage) {
    var selectedItems = recursive ? getSelectedLeafItems() : getSelectedRootItems();
    for (var i = 0; i < selectedItems.length; i++) {
        var item = selectedItems[i];
        item.clone();
        item.selected = false;
    }
    onUpdateImage();
};

var _checkBoundsItem = function _checkBoundsItem(selectionRect, item, event) {
    var itemBounds = new _paper2.default.Path([item.localToGlobal(item.internalBounds.topLeft), item.localToGlobal(item.internalBounds.topRight), item.localToGlobal(item.internalBounds.bottomRight), item.localToGlobal(item.internalBounds.bottomLeft)]);
    itemBounds.closed = true;
    itemBounds.guide = true;

    for (var i = 0; i < itemBounds.segments.length; i++) {
        var seg = itemBounds.segments[i];
        if (selectionRect.contains(seg.point) || i === 0 && selectionRect.getIntersections(itemBounds).length > 0) {
            if (event.modifiers.shift && item.selected) {
                setItemSelection(item, false);
            } else {
                setItemSelection(item, true);
            }
            itemBounds.remove();
            return true;
        }
    }

    itemBounds.remove();
};

var _handleRectangularSelectionItems = function _handleRectangularSelectionItems(item, event, rect, mode, root) {
    if ((0, _item.isPathItem)(item)) {
        var segmentMode = false;

        // first round checks for segments inside the selectionRect
        for (var j = 0; j < item.segments.length; j++) {
            var seg = item.segments[j];
            if (rect.contains(seg.point)) {
                if (mode === _modes2.default.RESHAPE) {
                    if (event.modifiers.shift && seg.selected) {
                        seg.selected = false;
                    } else {
                        seg.selected = true;
                    }
                    segmentMode = true;
                } else {
                    if (event.modifiers.shift && item.selected) {
                        setItemSelection(root, false);
                    } else {
                        setItemSelection(root, true, true /* fullySelected */);
                    }
                    return false;
                }
            }
        }

        // second round checks for path intersections
        var intersections = item.getIntersections(rect);
        if (intersections.length > 0 && !segmentMode) {
            // if in reshape mode, select the curves that intersect
            // with the selectionRect
            if (mode === _modes2.default.RESHAPE) {
                for (var k = 0; k < intersections.length; k++) {
                    var curve = intersections[k].curve;
                    // intersections contains every curve twice because
                    // the selectionRect intersects a circle always at
                    // two points. so we skip every other curve
                    if (k % 2 === 1) {
                        continue;
                    }

                    if (event.modifiers.shift) {
                        curve.selected = !curve.selected;
                    } else {
                        curve.selected = true;
                    }
                }
            } else {
                if (event.modifiers.shift && item.selected) {
                    setItemSelection(item, false);
                } else {
                    setItemSelection(item, true);
                }
                return false;
            }
        }
        // @todo: Update toolbar state on change
    } else if ((0, _item.isBoundsItem)(item)) {
        if (_checkBoundsItem(rect, item, event)) {
            return false;
        }
    }
    return true;
};

// if the rectangular selection found a group, drill into it recursively
var _rectangularSelectionGroupLoop = function _rectangularSelectionGroupLoop(group, rect, root, event, mode) {
    for (var i = 0; i < group.children.length; i++) {
        var child = group.children[i];

        if ((0, _group.isGroup)(child) || (0, _item.isCompoundPathItem)(child)) {
            _rectangularSelectionGroupLoop(child, rect, root, event, mode);
        } else {
            _handleRectangularSelectionItems(child, event, rect, mode, root);
        }
    }
    return true;
};

/**
 * Called after drawing a selection rectangle in a select mode. In reshape mode, this
 * selects all control points and curves within the rectangle. In select mode, this
 * selects all items and groups that intersect the rectangle
 * @param {!MouseEvent} event The mouse event to draw the rectangle
 * @param {!paper.Rect} rect The selection rectangle
 * @param {Modes} mode The mode of the paint editor when drawing the rectangle
 */
var processRectangularSelection = function processRectangularSelection(event, rect, mode) {
    var allItems = getAllSelectableRootItems();

    for (var i = 0; i < allItems.length; i++) {
        var item = allItems[i];
        if (mode === _modes2.default.RESHAPE && (0, _item.isPGTextItem)((0, _item.getRootItem)(item))) {
            continue;
        }
        if ((0, _group.isGroup)(item) || (0, _item.isCompoundPathItem)(item)) {
            // check for item segment points inside
            _rectangularSelectionGroupLoop(item, rect, item, event, mode);
        } else {
            _handleRectangularSelectionItems(item, event, rect, mode, item);
        }
    }
};

/**
 * When switching to the select tool while having a child object of a
 * compound path selected, deselect the child and select the compound path
 * instead. (otherwise the compound path breaks because of scale-grouping)
 */
var selectRootItem = function selectRootItem() {
    var items = getSelectedLeafItems();
    var _iteratorNormalCompletion8 = true;
    var _didIteratorError8 = false;
    var _iteratorError8 = undefined;

    try {
        for (var _iterator8 = items[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var item = _step8.value;

            if ((0, _compoundPath.isCompoundPathChild)(item)) {
                var cp = (0, _compoundPath.getItemsCompoundPath)(item);
                setItemSelection(cp, true, true /* fullySelected */);
            }
            var rootItem = (0, _item.getRootItem)(item);
            if (item !== rootItem) {
                setItemSelection(rootItem, true, true /* fullySelected */);
            }
        }
    } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
                _iterator8.return();
            }
        } finally {
            if (_didIteratorError8) {
                throw _iteratorError8;
            }
        }
    }
};

exports.getItems = getItems;
exports.getAllRootItems = getAllRootItems;
exports.getAllSelectableRootItems = getAllSelectableRootItems;
exports.selectAllItems = selectAllItems;
exports.selectAllSegments = selectAllSegments;
exports.clearSelection = clearSelection;
exports.deleteSelection = deleteSelection;
exports.cloneSelection = cloneSelection;
exports.setItemSelection = setItemSelection;
exports.getSelectedLeafItems = getSelectedLeafItems;
exports.getSelectedRootItems = getSelectedRootItems;
exports.getSelectedSegments = getSelectedSegments;
exports.processRectangularSelection = processRectangularSelection;
exports.selectRootItem = selectRootItem;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GradientToolsModes = exports.BitmapModes = exports.VectorModes = exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _keymirror = __webpack_require__(34);

var _keymirror2 = _interopRequireDefault(_keymirror);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var vectorModesObj = {
    BRUSH: null,
    ERASER: null,
    LINE: null,
    FILL: null,
    SELECT: null,
    RESHAPE: null,
    OVAL: null,
    RECT: null,
    ROUNDED_RECT: null,
    TEXT: null
};
var bitmapModesObj = {
    BIT_BRUSH: null,
    BIT_LINE: null,
    BIT_OVAL: null,
    BIT_RECT: null,
    BIT_TEXT: null,
    BIT_FILL: null,
    BIT_ERASER: null,
    BIT_SELECT: null
};
var VectorModes = (0, _keymirror2.default)(vectorModesObj);
var BitmapModes = (0, _keymirror2.default)(bitmapModesObj);
var Modes = (0, _keymirror2.default)(_extends({}, vectorModesObj, bitmapModesObj));

var GradientToolsModes = (0, _keymirror2.default)({
    FILL: null,
    SELECT: null,
    RESHAPE: null,
    OVAL: null,
    RECT: null,
    LINE: null,

    BIT_OVAL: null,
    BIT_RECT: null,
    BIT_SELECT: null,
    BIT_FILL: null
});

exports.default = Modes;
exports.VectorModes = VectorModes;
exports.BitmapModes = BitmapModes;
exports.GradientToolsModes = GradientToolsModes;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/** Used to compose bitmasks for function metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_BOUND_FLAG = 4,
    CURRY_FLAG = 8,
    CURRY_RIGHT_FLAG = 16,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64,
    ARY_FLAG = 128,
    REARG_FLAG = 256,
    FLIP_FLAG = 512;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** Used to associate wrap methods with their bit flags. */
var wrapFlags = [
  ['ary', ARY_FLAG],
  ['bind', BIND_FLAG],
  ['bindKey', BIND_KEY_FLAG],
  ['curry', CURRY_FLAG],
  ['curryRight', CURRY_RIGHT_FLAG],
  ['flip', FLIP_FLAG],
  ['partial', PARTIAL_FLAG],
  ['partialRight', PARTIAL_RIGHT_FLAG],
  ['rearg', REARG_FLAG]
];

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to match wrap detail comments. */
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
    reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
    reSplitDetails = /,? & /;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * Gets the number of `placeholder` occurrences in `array`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} placeholder The placeholder to search for.
 * @returns {number} Returns the placeholder count.
 */
function countHolders(array, placeholder) {
  var length = array.length,
      result = 0;

  while (length--) {
    if (array[length] === placeholder) {
      result++;
    }
  }
  return result;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index] = PLACEHOLDER;
      result[resIndex++] = index;
    }
  }
  return result;
}

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/* Used to set `toString` methods. */
var defineProperty = (function() {
  var func = getNative(Object, 'defineProperty'),
      name = getNative.name;

  return (name && name.length > 2) ? func : undefined;
}());

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersLength = holders.length,
      leftIndex = -1,
      leftLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(leftLength + rangeLength),
      isUncurried = !isCurried;

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersIndex = -1,
      holdersLength = holders.length,
      rightIndex = -1,
      rightLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(rangeLength + rightLength),
      isUncurried = !isCurried;

  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & BIND_FLAG,
      Ctor = createCtor(func);

  function wrapper() {
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtor(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length,
        placeholder = getHolder(wrapper);

    while (index--) {
      args[index] = arguments[index];
    }
    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
      ? []
      : replaceHolders(args, placeholder);

    length -= holders.length;
    if (length < arity) {
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, undefined,
        args, holders, undefined, undefined, arity - length);
    }
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return apply(fn, this, args);
  }
  return wrapper;
}

/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided
 *  to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & ARY_FLAG,
      isBind = bitmask & BIND_FLAG,
      isBindKey = bitmask & BIND_KEY_FLAG,
      isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
      isFlip = bitmask & FLIP_FLAG,
      Ctor = isBindKey ? undefined : createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length;

    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder(wrapper),
          holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders(args, placeholder);
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
        args, newHolders, argPos, ary, arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary < length) {
      args.length = ary;
    }
    if (this && this !== root && this instanceof wrapper) {
      fn = Ctor || createCtor(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & BIND_FLAG,
      Ctor = createCtor(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

/**
 * Creates a function that wraps `func` to continue currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {Function} wrapFunc The function to create the `func` wrapper.
 * @param {*} placeholder The placeholder value.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & CURRY_FLAG,
      newHolders = isCurry ? holders : undefined,
      newHoldersRight = isCurry ? undefined : holders,
      newPartials = isCurry ? partials : undefined,
      newPartialsRight = isCurry ? undefined : partials;

  bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

  if (!(bitmask & CURRY_BOUND_FLAG)) {
    bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
  }

  var result = wrapFunc(func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity);
  result.placeholder = placeholder;
  return setWrapToString(result, func, bitmask);
}

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags.
 *  The bitmask may be composed of the following flags:
 *     1 - `_.bind`
 *     2 - `_.bindKey`
 *     4 - `_.curry` or `_.curryRight` of a bound function
 *     8 - `_.curry`
 *    16 - `_.curryRight`
 *    32 - `_.partial`
 *    64 - `_.partialRight`
 *   128 - `_.rearg`
 *   256 - `_.ary`
 *   512 - `_.flip`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }
  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
  arity = arity === undefined ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }

  var newData = [
    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
    argPos, ary, arity
  ];

  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] == null
    ? (isBindKey ? 0 : func.length)
    : nativeMax(newData[9] - length, 0);

  if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
    bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == BIND_FLAG) {
    var result = createBind(func, bitmask, thisArg);
  } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
    result = createCurry(func, bitmask, arity);
  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
    result = createPartial(func, bitmask, thisArg, partials);
  } else {
    result = createHybrid.apply(undefined, newData);
  }
  return setWrapToString(result, func, bitmask);
}

/**
 * Gets the argument placeholder value for `func`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */
function getHolder(func) {
  var object = func;
  return object.placeholder;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Extracts wrapper details from the `source` body comment.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {Array} Returns the wrapper details.
 */
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}

/**
 * Inserts wrapper `details` in a comment at the top of the `source` body.
 *
 * @private
 * @param {string} source The source to modify.
 * @returns {Array} details The details to insert.
 * @returns {string} Returns the modified source.
 */
function insertWrapDetails(source, details) {
  var length = details.length,
      lastIndex = length - 1;

  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
  details = details.join(length > 2 ? ', ' : ' ');
  return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
}

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin(indexes.length, arrLength),
      oldArray = copyArray(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

/**
 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
 * with wrapper details in a comment at the top of the source body.
 *
 * @private
 * @param {Function} wrapper The function to modify.
 * @param {Function} reference The reference function.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Function} Returns `wrapper`.
 */
var setWrapToString = !defineProperty ? identity : function(wrapper, reference, bitmask) {
  var source = (reference + '');
  return defineProperty(wrapper, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
  });
};

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Updates wrapper `details` based on `bitmask` flags.
 *
 * @private
 * @returns {Array} details The details to modify.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Array} Returns `details`.
 */
function updateWrapDetails(details, bitmask) {
  arrayEach(wrapFlags, function(pair) {
    var value = '_.' + pair[0];
    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}

/**
 * Creates a function that invokes `func` with the `this` binding of `thisArg`
 * and `partials` prepended to the arguments it receives.
 *
 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for partially applied arguments.
 *
 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
 * property of bound functions.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new bound function.
 * @example
 *
 * function greet(greeting, punctuation) {
 *   return greeting + ' ' + this.user + punctuation;
 * }
 *
 * var object = { 'user': 'fred' };
 *
 * var bound = _.bind(greet, object, 'hi');
 * bound('!');
 * // => 'hi fred!'
 *
 * // Bound with placeholders.
 * var bound = _.bind(greet, object, _, '!');
 * bound('hi');
 * // => 'hi fred!'
 */
var bind = baseRest(function(func, thisArg, partials) {
  var bitmask = BIND_FLAG;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bind));
    bitmask |= PARTIAL_FLAG;
  }
  return createWrap(func, bitmask, thisArg, partials, holders);
});

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * Binds methods of an object to the object itself, overwriting the existing
 * method.
 *
 * **Note:** This method doesn't set the "length" property of bound functions.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {Object} object The object to bind and assign the bound methods to.
 * @param {...(string|string[])} methodNames The object method names to bind.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var view = {
 *   'label': 'docs',
 *   'click': function() {
 *     console.log('clicked ' + this.label);
 *   }
 * };
 *
 * _.bindAll(view, ['click']);
 * jQuery(element).on('click', view.click);
 * // => Logs 'clicked docs' when clicked.
 */
var bindAll = baseRest(function(object, methodNames) {
  arrayEach(baseFlatten(methodNames, 1), function(key) {
    key = toKey(key);
    object[key] = bind(object[key], object);
  });
  return object;
});

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

// Assign default placeholders.
bind.placeholder = {};

module.exports = bindAll;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(59)))

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("react-redux");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CHANGE_SELECTED_ITEMS = exports.clearSelectedItems = exports.setSelectedItems = exports.redrawSelectionBox = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_SELECTED_ITEMS = 'scratch-paint/select/CHANGE_SELECTED_ITEMS';
var REDRAW_SELECTION_BOX = 'scratch-paint/select/REDRAW_SELECTION_BOX';
var initialState = [];

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case REDRAW_SELECTION_BOX:
            if (state.length > 0) return state.slice(0); // Sends an update even though the items haven't changed
            return state;
        case CHANGE_SELECTED_ITEMS:
            if (!action.selectedItems || !(action.selectedItems instanceof Array)) {
                _log2.default.warn('No selected items or wrong format provided: ' + action.selectedItems);
                return state;
            }
            if (action.selectedItems.length > 1 && action.bitmapMode) {
                _log2.default.warn('Multiselect should not be possible in bitmap mode: ' + action.selectedItems);
                return state;
            }
            // If they are both empty, no change
            if (action.selectedItems.length === 0 && state.length === 0) {
                return state;
            }
            return action.selectedItems;
        default:
            return state;
    }
};

// Action creators ==================================
/**
 * Set the selected item state to the given array of items
 * @param {Array<paper.Item>} selectedItems from paper.project.selectedItems
 * @param {?boolean} bitmapMode True if the items are being selected in bitmap mode
 * @return {object} Redux action to change the selected items.
 */
var setSelectedItems = function setSelectedItems(selectedItems, bitmapMode) {
    return {
        type: CHANGE_SELECTED_ITEMS,
        selectedItems: selectedItems,
        bitmapMode: bitmapMode
    };
};
var clearSelectedItems = function clearSelectedItems() {
    return {
        type: CHANGE_SELECTED_ITEMS,
        selectedItems: []
    };
};
var redrawSelectionBox = function redrawSelectionBox() {
    return {
        type: REDRAW_SELECTION_BOX
    };
};

exports.default = reducer;
exports.redrawSelectionBox = redrawSelectionBox;
exports.setSelectedItems = setSelectedItems;
exports.clearSelectedItems = clearSelectedItems;
exports.CHANGE_SELECTED_ITEMS = CHANGE_SELECTED_ITEMS;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _minilog = __webpack_require__(97);

var _minilog2 = _interopRequireDefault(_minilog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_minilog2.default.enable();

exports.default = (0, _minilog2.default)('scratch-paint');

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.swapColorsInSelection = exports.styleCursorPreview = exports.styleShape = exports.styleBlob = exports.MIXED = exports.generateSecondaryColor = exports.getColorsFromSelection = exports.createGradientObject = exports.applyStrokeWidthToSelection = exports.applyGradientTypeToSelection = exports.applyColorToSelection = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _selection = __webpack_require__(3);

var _item = __webpack_require__(26);

var _group = __webpack_require__(24);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _fillStyle = __webpack_require__(18);

var _compoundPath = __webpack_require__(48);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MIXED = 'scratch-paint/style-path/mixed';

// Check if the item color matches the incoming color. If the item color is a gradient, we assume
// that the incoming color never matches, since we don't support gradients yet.
var _colorMatch = function _colorMatch(itemColor, incomingColor) {
    if (itemColor && itemColor.type === 'gradient') return false;
    // Either both are null or both are the same color when converted to CSS.
    return !itemColor && !incomingColor || itemColor && incomingColor && itemColor.toCSS() === new _paper2.default.Color(incomingColor).toCSS();
};

// Selected items and currently active text edit items respond to color changes.
var _getColorStateListeners = function _getColorStateListeners(textEditTargetId) {
    var items = (0, _selection.getSelectedLeafItems)();
    if (textEditTargetId) {
        var matches = (0, _selection.getItems)({
            match: function match(item) {
                return item.id === textEditTargetId;
            }
        });
        if (matches.length) {
            items.push(matches[0]);
        }
    }
    return items;
};

/**
 * Transparent R, G, B values need to match the other color of the gradient
 * in order to form a smooth gradient, otherwise it fades through black. This
 * function gets the transparent color for a given color string.
 * @param {?string} colorToMatch CSS string of other color of gradient, or null for transparent
 * @return {string} CSS string for matching color of transparent
 */
var getColorStringForTransparent = function getColorStringForTransparent(colorToMatch) {
    var color = new _paper2.default.Color(colorToMatch);
    color.alpha = 0;
    return color.toCSS();
};

/**
 * Generate a color that contrasts well with the passed-in color.
 * @param {string} firstColor The "primary" color
 * @return {string} CSS string for generated color
 */
var generateSecondaryColor = function generateSecondaryColor(firstColor) {
    if (firstColor === MIXED) return null;
    var color = new _paper2.default.Color(firstColor);
    if (!firstColor || color.alpha === 0) return _fillStyle.DEFAULT_COLOR;

    color.type = 'hsb';
    var desaturated = color.saturation <= 0.15;
    // If the color is desaturated or dark enough that a hue shift would be hard to see, do a brightness shift.
    if (desaturated || color.brightness <= 0.4) {
        // Choose the shade that contrasts the most with the given color.
        // Use a brightness of 0.1 instead of 0 because if the brightness is 0, it's black and we lose the hue.
        color.brightness = color.brightness < 0.55 ? 1 : 0.1;
    }
    // If the color was desaturated, don't do a hue shift, as it would be hard to see anyway.
    if (!desaturated) {
        color.hue -= 72;
    }
    // The returned color will be one of three things:
    // 1. If the color was bright and saturated (e.g. colorful), it will be that color, hue-shifted.
    // 2. If the color was dark and saturated, it will be that color, brightened and hue-shifted.
    // 3. If the color was not saturated, it will be that color, brightened or darkened as needed to contrast most.
    return color.toCSS(true /* hex */);
};

/**
 * Convert params to a paper.Color gradient object
 * @param {?string} color1 CSS string, or null for transparent
 * @param {?string} color2 CSS string, or null for transparent
 * @param {GradientType} gradientType gradient type
 * @param {paper.Rectangle} bounds Bounds of the object
 * @param {?paper.Point} [radialCenter] Where the center of a radial gradient should be, if the gradient is radial.
 * Defaults to center of bounds.
 * @param {number} [minSize] The minimum width/height of the gradient object.
 * @return {paper.Color} Color object with gradient, may be null or color string if the gradient type is solid
 */
var createGradientObject = function createGradientObject(color1, color2, gradientType, bounds, radialCenter, minSize) {
    if (gradientType === _gradientTypes2.default.SOLID) return color1;
    if (color1 === null) {
        color1 = getColorStringForTransparent(color2);
    }
    if (color2 === null) {
        color2 = getColorStringForTransparent(color1);
    }

    // Force gradients to have a minimum length. If the gradient start and end points are the same or very close
    // (e.g. applying a vertical gradient to a perfectly horizontal line or vice versa), the gradient will not appear.
    if (!minSize) minSize = 1e-2;

    var start = void 0;
    var end = void 0;
    switch (gradientType) {
        case _gradientTypes2.default.HORIZONTAL:
            {
                // clone these points so that adding/subtracting doesn't affect actual bounds
                start = bounds.leftCenter.clone();
                end = bounds.rightCenter.clone();

                var gradientSize = Math.abs(end.x - start.x);
                if (gradientSize < minSize) {
                    var sizeDiff = (minSize - gradientSize) / 2;
                    end.x += sizeDiff;
                    start.x -= sizeDiff;
                }
                break;
            }
        case _gradientTypes2.default.VERTICAL:
            {
                // clone these points so that adding/subtracting doesn't affect actual bounds
                start = bounds.topCenter.clone();
                end = bounds.bottomCenter.clone();

                var _gradientSize = Math.abs(end.y - start.y);
                if (_gradientSize < minSize) {
                    var _sizeDiff = (minSize - _gradientSize) / 2;
                    end.y += _sizeDiff;
                    start.y -= _sizeDiff;
                }
                break;
            }

        case _gradientTypes2.default.RADIAL:
            {
                var halfLongestDimension = Math.max(bounds.width, bounds.height) / 2;
                start = radialCenter || bounds.center;
                end = start.add(new _paper2.default.Point(Math.max(halfLongestDimension, minSize / 2), 0));
                break;
            }
    }
    return {
        gradient: {
            stops: [color1, color2],
            radial: gradientType === _gradientTypes2.default.RADIAL
        },
        origin: start,
        destination: end
    };
};

/**
 * Called when setting an item's color
 * @param {string} colorString color, css format, or null if completely transparent
 * @param {number} colorIndex index of color being changed
 * @param {boolean} isSolidGradient True if is solid gradient. Sometimes the item has a gradient but the color
 *     picker is set to a solid gradient. This happens when a mix of colors and gradient types is selected.
 *     When changing the color in this case, the solid gradient should override the existing gradient on the item.
 * @param {?boolean} applyToStroke True if changing the selection's stroke, false if changing its fill.
 * @param {?string} textEditTargetId paper.Item.id of text editing target, if any
 * @return {boolean} Whether the color application actually changed visibly.
 */
var applyColorToSelection = function applyColorToSelection(colorString, colorIndex, isSolidGradient, applyToStroke, textEditTargetId) {
    var items = _getColorStateListeners(textEditTargetId);
    var changed = false;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            if (item.parent instanceof _paper2.default.CompoundPath) {
                item = item.parent;
            }

            var itemColorProp = applyToStroke ? 'strokeColor' : 'fillColor';
            var itemColor = item[itemColorProp];

            if (isSolidGradient || !itemColor || !itemColor.gradient || !itemColor.gradient.stops.length === 2) {
                // Applying a solid color
                if (!_colorMatch(itemColor, colorString)) {
                    changed = true;
                    if ((0, _item.isPointTextItem)(item) && !colorString) {
                        // Allows transparent text to be hit
                        item[itemColorProp] = 'rgba(0,0,0,0)';
                    } else {
                        item[itemColorProp] = colorString;
                    }
                }
            } else if (!_colorMatch(itemColor.gradient.stops[colorIndex].color, colorString)) {
                // Changing one color of an existing gradient
                changed = true;
                var otherIndex = colorIndex === 0 ? 1 : 0;
                if (colorString === null) {
                    colorString = getColorStringForTransparent(itemColor.gradient.stops[otherIndex].color.toCSS());
                }
                var colors = [0, 0];
                colors[colorIndex] = colorString;
                // If the other color is transparent, its RGB values need to be adjusted for the gradient to be smooth
                if (itemColor.gradient.stops[otherIndex].color.alpha === 0) {
                    colors[otherIndex] = getColorStringForTransparent(colorString);
                } else {
                    colors[otherIndex] = itemColor.gradient.stops[otherIndex].color.toCSS();
                }
                // There seems to be a bug where setting colors on stops doesn't always update the view, so set gradient.
                itemColor.gradient = { stops: colors, radial: itemColor.gradient.radial };
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return changed;
};

/**
 * Called to swap gradient colors
 * @param {?boolean} applyToStroke True if changing the selection's stroke, false if changing its fill.
 * @param {?string} textEditTargetId paper.Item.id of text editing target, if any
 * @return {boolean} Whether the color application actually changed visibly.
 */
var swapColorsInSelection = function swapColorsInSelection(applyToStroke, textEditTargetId) {
    var items = _getColorStateListeners(textEditTargetId);
    var changed = false;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var item = _step2.value;

            // If an item is a child path, do not swap colors.
            // At some point, we'll iterate over its parent path, and we don't want to swap colors twice--
            // that would leave us right where we started.
            if ((0, _compoundPath.isCompoundPathChild)(item)) continue;

            var itemColor = applyToStroke ? item.strokeColor : item.fillColor;
            if (!itemColor || !itemColor.gradient || !itemColor.gradient.stops.length === 2) {
                // Only one color; nothing to swap
                continue;
            } else if (!itemColor.gradient.stops[0].color.equals(itemColor.gradient.stops[1].color)) {
                // Changing one color of an existing gradient
                changed = true;
                var colors = [itemColor.gradient.stops[1].color.toCSS(), itemColor.gradient.stops[0].color.toCSS()];
                // There seems to be a bug where setting colors on stops doesn't always update the view, so set gradient.
                itemColor.gradient = { stops: colors, radial: itemColor.gradient.radial };
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return changed;
};

/**
 * Called when setting gradient type
 * @param {GradientType} gradientType gradient type
 * @param {?boolean} applyToStroke True if changing the selection's stroke, false if changing its fill.
 * @param {?string} textEditTargetId paper.Item.id of text editing target, if any
 * @return {boolean} Whether the color application actually changed visibly.
 */
var applyGradientTypeToSelection = function applyGradientTypeToSelection(gradientType, applyToStroke, textEditTargetId) {
    var items = _getColorStateListeners(textEditTargetId);
    var changed = false;
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var item = _step3.value;

            if (item.parent instanceof _paper2.default.CompoundPath) {
                item = item.parent;
            }

            var itemColorProp = applyToStroke ? 'strokeColor' : 'fillColor';
            var itemColor = item[itemColorProp];

            var hasGradient = itemColor && itemColor.gradient;

            var itemColor1 = void 0;
            if (itemColor === null || itemColor.alpha === 0) {
                // Transparent
                itemColor1 = null;
            } else if (!hasGradient) {
                // Solid color
                itemColor1 = itemColor.toCSS();
            } else if (!itemColor.gradient.stops[0] || itemColor.gradient.stops[0].color.alpha === 0) {
                // Gradient where first color is transparent
                itemColor1 = null;
            } else {
                // Gradient where first color is not transparent
                itemColor1 = itemColor.gradient.stops[0].color.toCSS();
            }

            var itemColor2 = void 0;
            if (!hasGradient || !itemColor.gradient.stops[1]) {
                // If item color is solid or a gradient that has no 2nd color, set the 2nd color based on the first color
                itemColor2 = generateSecondaryColor(itemColor1);
            } else if (itemColor.gradient.stops[1].color.alpha === 0) {
                // Gradient has 2nd color which is transparent
                itemColor2 = null;
            } else {
                // Gradient has 2nd color which is not transparent
                itemColor2 = itemColor.gradient.stops[1].color.toCSS();
            }

            if (gradientType === _gradientTypes2.default.SOLID) {
                if (itemColor && itemColor.gradient) {
                    changed = true;
                    item[itemColorProp] = itemColor1;
                }
                continue;
            }

            // If this is a stroke, we don't display it as having a gradient in the color picker
            // if there's no stroke width. Then treat it as if it doesn't have a gradient.
            var hasDisplayGradient = hasGradient;
            if (applyToStroke) hasDisplayGradient = hasGradient && item.strokeWidth > 0;
            if (!hasDisplayGradient) {
                var noColorOriginally = !itemColor || itemColor.gradient && itemColor.gradient.stops && itemColor.gradient.stops[0].color.alpha === 0;
                var addingStroke = applyToStroke && item.strokeWidth === 0;
                var hasGradientNow = itemColor1 || itemColor2;
                if ((noColorOriginally || addingStroke) && hasGradientNow) {
                    if (applyToStroke) {
                        // Make outline visible
                        item.strokeWidth = 1;
                    }
                    // Make the gradient black to white
                    itemColor1 = 'black';
                    itemColor2 = 'white';
                }
            }

            if (itemColor1 === null) {
                itemColor1 = getColorStringForTransparent(itemColor2);
            }
            if (itemColor2 === null) {
                itemColor2 = getColorStringForTransparent(itemColor1);
            }

            var gradientTypeDiffers = false;
            // If the item's gradient type differs from the gradient type we want to apply, then we change it
            switch (gradientType) {
                case _gradientTypes2.default.RADIAL:
                    {
                        var hasRadialGradient = hasDisplayGradient && itemColor.gradient.radial;
                        gradientTypeDiffers = !hasRadialGradient;
                        break;
                    }
                case _gradientTypes2.default.HORIZONTAL:
                    {
                        var hasHorizontalGradient = hasDisplayGradient && !itemColor.gradient.radial && Math.abs(itemColor.origin.y - itemColor.destination.y) < 1e-8;
                        gradientTypeDiffers = !hasHorizontalGradient;
                        break;
                    }
                case _gradientTypes2.default.VERTICAL:
                    {
                        var hasVerticalGradient = hasDisplayGradient && !itemColor.gradient.radial && Math.abs(itemColor.origin.x - itemColor.destination.x) < 1e-8;
                        gradientTypeDiffers = !hasVerticalGradient;
                        break;
                    }
            }

            if (gradientTypeDiffers) {
                changed = true;
                item[itemColorProp] = createGradientObject(itemColor1, itemColor2, gradientType, item.bounds, null, // radialCenter
                item.strokeWidth);
            }
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    return changed;
};

/**
 * Called when setting stroke width
 * @param {number} value New stroke width
 * @param {?string} textEditTargetId paper.Item.id of text editing target, if any
 * @return {boolean} Whether the color application actually changed visibly.
 */
var applyStrokeWidthToSelection = function applyStrokeWidthToSelection(value, textEditTargetId) {
    var changed = false;
    var items = _getColorStateListeners(textEditTargetId);
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = items[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var item = _step4.value;

            if (item.parent instanceof _paper2.default.CompoundPath) {
                item = item.parent;
            }
            if ((0, _group.isGroup)(item)) {
                continue;
            } else if (item.strokeWidth !== value) {
                item.strokeWidth = value;
                changed = true;
            }
        }
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    return changed;
};

var _colorStateFromGradient = function _colorStateFromGradient(gradient) {
    var colorState = {};
    // Scratch only recognizes 2 color gradients
    if (gradient.stops.length === 2) {
        if (gradient.radial) {
            colorState.gradientType = _gradientTypes2.default.RADIAL;
        } else {
            // Always use horizontal for linear gradients, since horizontal and vertical gradients
            // are the same with rotation. We don't want to show MIXED just because anything is rotated.
            colorState.gradientType = _gradientTypes2.default.HORIZONTAL;
        }
        colorState.primary = gradient.stops[0].color.alpha === 0 ? null : gradient.stops[0].color.toCSS();
        colorState.secondary = gradient.stops[1].color.alpha === 0 ? null : gradient.stops[1].color.toCSS();
    } else {
        if (gradient.stops.length < 2) _log2.default.warn('Gradient has ' + gradient.stops.length + ' stop(s)');

        colorState.primary = MIXED;
        colorState.secondary = MIXED;
    }

    return colorState;
};

/**
 * Get state of colors and stroke width for selection
 * @param {!Array<paper.Item>} selectedItems Selected paper items
 * @param {?boolean} bitmapMode True if the item is being selected in bitmap mode
 * @return {?object} Object of strokeColor, strokeWidth, fillColor, thickness of the selection.
 *     Gives MIXED when there are mixed values for a color, and null for transparent.
 *     Gives null when there are mixed values for stroke width.
 *     Thickness is line thickness, used in the bitmap editor
 */
var getColorsFromSelection = function getColorsFromSelection(selectedItems, bitmapMode) {
    // TODO: DRY out this code
    var selectionFillColorString = void 0;
    var selectionFillColor2String = void 0;
    var selectionStrokeColorString = void 0;
    var selectionStrokeColor2String = void 0;
    var selectionStrokeWidth = void 0;
    var selectionThickness = void 0;
    var selectionFillGradientType = void 0;
    var selectionStrokeGradientType = void 0;
    var firstChild = true;

    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
        for (var _iterator5 = selectedItems[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var item = _step5.value;

            if (item.parent instanceof _paper2.default.CompoundPath) {
                // Compound path children inherit fill and stroke color from their parent.
                item = item.parent;
            }
            var itemFillColorString = void 0;
            var itemFillColor2String = void 0;
            var itemStrokeColorString = void 0;
            var itemStrokeColor2String = void 0;
            var itemFillGradientType = _gradientTypes2.default.SOLID;
            var itemStrokeGradientType = _gradientTypes2.default.SOLID;

            if (!(0, _group.isGroup)(item)) {
                if (item.fillColor) {
                    // hack bc text items with null fill can't be detected by fill-hitTest anymore
                    if ((0, _item.isPointTextItem)(item) && item.fillColor.alpha === 0) {
                        itemFillColorString = null;
                    } else if (item.fillColor.type === 'gradient') {
                        var _colorStateFromGradie = _colorStateFromGradient(item.fillColor.gradient),
                            primary = _colorStateFromGradie.primary,
                            secondary = _colorStateFromGradie.secondary,
                            gradientType = _colorStateFromGradie.gradientType;

                        itemFillColorString = primary;
                        itemFillColor2String = secondary;
                        itemFillGradientType = gradientType;
                    } else {
                        itemFillColorString = item.fillColor.alpha === 0 ? null : item.fillColor.toCSS();
                        itemFillColor2String = null;
                    }
                }
                if (item.strokeColor) {
                    if (item.strokeColor.type === 'gradient') {
                        var _colorStateFromGradie2 = _colorStateFromGradient(item.strokeColor.gradient),
                            _primary = _colorStateFromGradie2.primary,
                            _secondary = _colorStateFromGradie2.secondary,
                            _gradientType = _colorStateFromGradie2.gradientType;

                        var strokeColorString = _primary;
                        var strokeColor2String = _secondary;
                        var strokeGradientType = _gradientType;

                        // If the item's stroke width is 0, pretend the stroke color is null
                        if (!item.strokeWidth) {
                            strokeColorString = null;
                            // Hide the second color. This way if you choose a second color, remove
                            // the gradient, and re-add it, your second color selection is preserved.
                            strokeGradientType = _gradientTypes2.default.SOLID;
                        }

                        // Stroke color is fill color in bitmap
                        if (bitmapMode) {
                            itemFillColorString = strokeColorString;
                            itemFillColor2String = strokeColor2String;
                            itemFillGradientType = strokeGradientType;
                        } else {
                            itemStrokeColorString = strokeColorString;
                            itemStrokeColor2String = strokeColor2String;
                            itemStrokeGradientType = strokeGradientType;
                        }
                    } else {
                        var _strokeColorString = item.strokeColor.alpha === 0 || !item.strokeWidth ? null : item.strokeColor.toCSS();

                        // Stroke color is fill color in bitmap
                        if (bitmapMode) {
                            itemFillColorString = _strokeColorString;
                        } else {
                            itemStrokeColorString = _strokeColorString;
                        }
                    }
                } else {
                    itemStrokeColorString = null;
                    itemStrokeColor2String = null;
                }
                // check every style against the first of the items
                if (firstChild) {
                    firstChild = false;
                    selectionFillColorString = itemFillColorString;
                    selectionFillColor2String = itemFillColor2String;
                    selectionStrokeColorString = itemStrokeColorString;
                    selectionStrokeColor2String = itemStrokeColor2String;
                    selectionFillGradientType = itemFillGradientType;
                    selectionStrokeGradientType = itemStrokeGradientType;
                    selectionStrokeWidth = itemStrokeColorString || itemStrokeColor2String ? item.strokeWidth : 0;
                    if (item.strokeWidth && item.data && item.data.zoomLevel) {
                        selectionThickness = item.strokeWidth / item.data.zoomLevel;
                    }
                }
                if (itemFillColorString !== selectionFillColorString) {
                    selectionFillColorString = MIXED;
                }
                if (itemFillColor2String !== selectionFillColor2String) {
                    selectionFillColor2String = MIXED;
                }
                if (itemFillGradientType !== selectionFillGradientType) {
                    selectionFillGradientType = _gradientTypes2.default.SOLID;
                    selectionFillColorString = MIXED;
                    selectionFillColor2String = MIXED;
                }
                if (itemStrokeGradientType !== selectionStrokeGradientType) {
                    selectionStrokeGradientType = _gradientTypes2.default.SOLID;
                    selectionStrokeColorString = MIXED;
                    selectionStrokeColor2String = MIXED;
                }
                if (itemStrokeColorString !== selectionStrokeColorString) {
                    selectionStrokeColorString = MIXED;
                }
                if (itemStrokeColor2String !== selectionStrokeColor2String) {
                    selectionStrokeColor2String = MIXED;
                }
                var itemStrokeWidth = itemStrokeColorString || itemStrokeColor2String ? item.strokeWidth : 0;
                if (selectionStrokeWidth !== itemStrokeWidth) {
                    selectionStrokeWidth = null;
                }
            }
        }
        // Convert selection gradient type from horizontal to vertical if first item is exactly vertical
        // This is because up to this point, we assume all non-radial gradients are horizontal
        // Otherwise, if there were a mix of horizontal/vertical gradient types in the selection, they would show as MIXED
        // whereas we want them to show as horizontal (or vertical if the first item is vertical)
    } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
            }
        } finally {
            if (_didIteratorError5) {
                throw _iteratorError5;
            }
        }
    }

    if (selectedItems && selectedItems.length) {
        var firstItem = selectedItems[0];
        if (firstItem.parent instanceof _paper2.default.CompoundPath) firstItem = firstItem.parent;

        if (selectionFillGradientType !== _gradientTypes2.default.SOLID) {
            // Stroke color is fill color in bitmap if fill color is missing
            // TODO: this whole "treat horizontal/vertical gradients specially" logic is janky; refactor at some point
            var firstItemColor = bitmapMode && firstItem.strokeColor ? firstItem.strokeColor : firstItem.fillColor;
            var direction = firstItemColor.destination.subtract(firstItemColor.origin);
            if (Math.abs(direction.angle) === 90) {
                selectionFillGradientType = _gradientTypes2.default.VERTICAL;
            }
        }

        if (selectionStrokeGradientType !== _gradientTypes2.default.SOLID) {
            var _direction = firstItem.strokeColor.destination.subtract(firstItem.strokeColor.origin);
            if (Math.abs(_direction.angle) === 90) {
                selectionStrokeGradientType = _gradientTypes2.default.VERTICAL;
            }
        }
    }
    if (bitmapMode) {
        return {
            fillColor: selectionFillColorString ? selectionFillColorString : null,
            fillColor2: selectionFillColor2String ? selectionFillColor2String : null,
            fillGradientType: selectionFillGradientType,
            thickness: selectionThickness
        };
    }
    return {
        fillColor: selectionFillColorString ? selectionFillColorString : null,
        fillColor2: selectionFillColor2String ? selectionFillColor2String : null,
        fillGradientType: selectionFillGradientType,
        strokeColor: selectionStrokeColorString ? selectionStrokeColorString : null,
        strokeColor2: selectionStrokeColor2String ? selectionStrokeColor2String : null,
        strokeGradientType: selectionStrokeGradientType,
        strokeWidth: selectionStrokeWidth || selectionStrokeWidth === null ? selectionStrokeWidth : 0
    };
};

var styleBlob = function styleBlob(path, options) {
    if (options.isEraser) {
        path.fillColor = 'white';
    } else if (options.fillColor) {
        path.fillColor = options.fillColor;
    } else {
        // Make sure something visible is drawn
        path.fillColor = 'black';
    }
};

var styleCursorPreview = function styleCursorPreview(path, options) {
    if (options.isEraser) {
        path.fillColor = 'white';
        path.strokeColor = 'cornflowerblue';
        path.strokeWidth = 1;
    } else if (options.fillColor) {
        path.fillColor = options.fillColor;
    } else {
        // Make sure something visible is drawn
        path.fillColor = 'black';
    }
};

var styleShape = function styleShape(path, options) {
    var _arr = ['fillColor', 'strokeColor'];

    for (var _i = 0; _i < _arr.length; _i++) {
        var colorKey = _arr[_i];
        if (options[colorKey] === null) {
            path[colorKey] = null;
        } else if (options[colorKey].gradientType === _gradientTypes2.default.SOLID) {
            path[colorKey] = options[colorKey].primary;
        } else {
            var _options$colorKey = options[colorKey],
                primary = _options$colorKey.primary,
                secondary = _options$colorKey.secondary,
                gradientType = _options$colorKey.gradientType;

            path[colorKey] = createGradientObject(primary, secondary, gradientType, path.bounds, null, // radialCenter
            options.strokeWidth // minimum gradient size is stroke width
            );
        }
    }
    if (Object.prototype.hasOwnProperty.call(options, 'strokeWidth')) path.strokeWidth = options.strokeWidth;
};

exports.applyColorToSelection = applyColorToSelection;
exports.applyGradientTypeToSelection = applyGradientTypeToSelection;
exports.applyStrokeWidthToSelection = applyStrokeWidthToSelection;
exports.createGradientObject = createGradientObject;
exports.getColorsFromSelection = getColorsFromSelection;
exports.generateSecondaryColor = generateSecondaryColor;
exports.MIXED = MIXED;
exports.styleBlob = styleBlob;
exports.styleShape = styleShape;
exports.styleCursorPreview = styleCursorPreview;
exports.swapColorsInSelection = swapColorsInSelection;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeMode = exports.default = undefined;

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_MODE = 'scratch-paint/modes/CHANGE_MODE';
var initialState = _modes2.default.SELECT;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_MODE:
            if (action.mode in _modes2.default) {
                return action.mode;
            }
            _log2.default.warn('Mode does not exist: ' + action.mode);
        /* falls through */
        default:
            return state;
    }
};

// Action creators ==================================
var changeMode = function changeMode(mode) {
    return {
        type: CHANGE_MODE,
        mode: mode
    };
};

exports.default = reducer;
exports.changeMode = changeMode;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isBitmap = exports.isVector = exports.default = undefined;

var _keymirror = __webpack_require__(34);

var _keymirror2 = _interopRequireDefault(_keymirror);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Formats = (0, _keymirror2.default)({
    BITMAP: null,
    VECTOR: null,
    // Format changes which should not trigger conversions, for instance undo
    BITMAP_SKIP_CONVERT: null,
    VECTOR_SKIP_CONVERT: null
});

var isVector = function isVector(format) {
    return format === Formats.VECTOR || format === Formats.VECTOR_SKIP_CONVERT;
};

var isBitmap = function isBitmap(format) {
    return format === Formats.BITMAP || format === Formats.BITMAP_SKIP_CONVERT;
};

exports.default = Formats;
exports.isVector = isVector;
exports.isBitmap = isBitmap;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupLayers = exports.setGuideItem = exports.getRaster = exports.clearRaster = exports.convertBackgroundGuideLayer = exports.getBackgroundGuideLayer = exports.getGuideLayer = exports.getDragCrosshairLayer = exports.showGuideLayers = exports.hideGuideLayers = exports.createCanvas = exports.CROSSHAIR_FULL_OPACITY = exports.CROSSHAIR_SIZE = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _view = __webpack_require__(22);

var _item = __webpack_require__(26);

var _format = __webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHECKERBOARD_SIZE = 8;
var CROSSHAIR_SIZE = 16;
var CROSSHAIR_FULL_OPACITY = 0.75;

var _getLayer = function _getLayer(layerString) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = _paper2.default.project.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var layer = _step.value;

            if (layer.data && layer.data[layerString]) {
                return layer;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
};

var _getPaintingLayer = function _getPaintingLayer() {
    return _getLayer('isPaintingLayer');
};

/**
 * Creates a canvas with width and height matching the art board size.
 * @param {?number} width Width of the canvas. Defaults to ART_BOARD_WIDTH.
 * @param {?number} height Height of the canvas. Defaults to ART_BOARD_HEIGHT.
 * @return {HTMLCanvasElement} the canvas
 */
var createCanvas = function createCanvas(width, height) {
    var canvas = document.createElement('canvas');
    canvas.width = width ? width : _view.ART_BOARD_WIDTH;
    canvas.height = height ? height : _view.ART_BOARD_HEIGHT;
    canvas.getContext('2d').imageSmoothingEnabled = false;
    return canvas;
};

var clearRaster = function clearRaster() {
    var layer = _getLayer('isRasterLayer');
    layer.removeChildren();

    // Generate blank raster
    var raster = new _paper2.default.Raster(createCanvas());
    raster.canvas.getContext('2d').imageSmoothingEnabled = false;
    raster.parent = layer;
    raster.guide = true;
    raster.locked = true;
    raster.position = _view.CENTER;
};

var getRaster = function getRaster() {
    var layer = _getLayer('isRasterLayer');
    // Generate blank raster
    if (layer.children.length === 0) {
        clearRaster();
    }
    return _getLayer('isRasterLayer').children[0];
};

var getDragCrosshairLayer = function getDragCrosshairLayer() {
    return _getLayer('isDragCrosshairLayer');
};

var getBackgroundGuideLayer = function getBackgroundGuideLayer() {
    return _getLayer('isBackgroundGuideLayer');
};

var _convertLayer = function _convertLayer(layer, format) {
    layer.bitmapBackground.visible = (0, _format.isBitmap)(format);
    layer.vectorBackground.visible = (0, _format.isVector)(format);
};

var convertBackgroundGuideLayer = function convertBackgroundGuideLayer(format) {
    _convertLayer(getBackgroundGuideLayer(), format);
};

var _makeGuideLayer = function _makeGuideLayer() {
    var guideLayer = new _paper2.default.Layer();
    guideLayer.data.isGuideLayer = true;
    return guideLayer;
};

var getGuideLayer = function getGuideLayer() {
    var layer = _getLayer('isGuideLayer');
    if (!layer) {
        layer = _makeGuideLayer();
        _getPaintingLayer().activate();
    }
    return layer;
};

var setGuideItem = function setGuideItem(item) {
    item.locked = true;
    item.guide = true;
    if ((0, _item.isGroupItem)(item)) {
        for (var i = 0; i < item.children.length; i++) {
            setGuideItem(item.children[i]);
        }
    }
};

/**
 * Removes the guide layers, e.g. for purposes of exporting the image. Must call showGuideLayers to re-add them.
 * @param {boolean} includeRaster true if the raster layer should also be hidden
 * @return {object} an object of the removed layers, which should be passed to showGuideLayers to re-add them.
 */
var hideGuideLayers = function hideGuideLayers(includeRaster) {
    var backgroundGuideLayer = getBackgroundGuideLayer();
    var dragCrosshairLayer = getDragCrosshairLayer();
    var outlineLayer = _getLayer('isOutlineLayer');
    var guideLayer = getGuideLayer();
    dragCrosshairLayer.remove();
    outlineLayer.remove();
    guideLayer.remove();
    backgroundGuideLayer.remove();
    var rasterLayer = void 0;
    if (includeRaster) {
        rasterLayer = _getLayer('isRasterLayer');
        rasterLayer.remove();
    }
    return {
        dragCrosshairLayer: dragCrosshairLayer,
        outlineLayer: outlineLayer,
        guideLayer: guideLayer,
        backgroundGuideLayer: backgroundGuideLayer,
        rasterLayer: rasterLayer
    };
};

/**
 * Add back the guide layers removed by calling hideGuideLayers. This must be done before any editing operations are
 * taken in the paint editor.
 * @param {!object} guideLayers object of the removed layers, which was returned by hideGuideLayers
 */
var showGuideLayers = function showGuideLayers(guideLayers) {
    var backgroundGuideLayer = guideLayers.backgroundGuideLayer;
    var dragCrosshairLayer = guideLayers.dragCrosshairLayer;
    var outlineLayer = guideLayers.outlineLayer;
    var guideLayer = guideLayers.guideLayer;
    var rasterLayer = guideLayers.rasterLayer;
    if (rasterLayer && !rasterLayer.index) {
        _paper2.default.project.addLayer(rasterLayer);
        rasterLayer.sendToBack();
    }
    if (!backgroundGuideLayer.index) {
        _paper2.default.project.addLayer(backgroundGuideLayer);
        backgroundGuideLayer.sendToBack();
    }
    if (!dragCrosshairLayer.index) {
        _paper2.default.project.addLayer(dragCrosshairLayer);
        dragCrosshairLayer.bringToFront();
    }
    if (!outlineLayer.index) {
        _paper2.default.project.addLayer(outlineLayer);
        outlineLayer.bringToFront();
    }
    if (!guideLayer.index) {
        _paper2.default.project.addLayer(guideLayer);
        guideLayer.bringToFront();
    }
    if (_paper2.default.project.activeLayer !== _getPaintingLayer()) {
        _log2.default.error('Wrong active layer');
        _log2.default.error(_paper2.default.project.activeLayer.data);
    }
};

var _makePaintingLayer = function _makePaintingLayer() {
    var paintingLayer = new _paper2.default.Layer();
    paintingLayer.data.isPaintingLayer = true;
    return paintingLayer;
};

var _makeRasterLayer = function _makeRasterLayer() {
    var rasterLayer = new _paper2.default.Layer();
    rasterLayer.data.isRasterLayer = true;
    clearRaster();
    return rasterLayer;
};

var _makeBackgroundPaper = function _makeBackgroundPaper(width, height, color, opacity) {
    // creates a checkerboard path of width * height squares in color on white
    var x = 0;
    var y = 0;
    var pathPoints = [];
    while (x < width) {
        pathPoints.push(new _paper2.default.Point(x, y));
        x++;
        pathPoints.push(new _paper2.default.Point(x, y));
        y = y === 0 ? height : 0;
    }
    y = height - 1;
    x = width;
    while (y > 0) {
        pathPoints.push(new _paper2.default.Point(x, y));
        x = x === 0 ? width : 0;
        pathPoints.push(new _paper2.default.Point(x, y));
        y--;
    }
    var vRect = new _paper2.default.Shape.Rectangle(new _paper2.default.Point(0, 0), new _paper2.default.Point(_view.ART_BOARD_WIDTH / CHECKERBOARD_SIZE, _view.ART_BOARD_HEIGHT / CHECKERBOARD_SIZE));
    vRect.fillColor = '#fff';
    vRect.guide = true;
    vRect.locked = true;
    vRect.position = _view.CENTER;
    var vPath = new _paper2.default.Path(pathPoints);
    vPath.fillRule = 'evenodd';
    vPath.fillColor = color;
    vPath.opacity = opacity;
    vPath.guide = true;
    vPath.locked = true;
    vPath.position = _view.CENTER;
    var mask = new _paper2.default.Shape.Rectangle(_view.MAX_WORKSPACE_BOUNDS);
    mask.position = _view.CENTER;
    mask.guide = true;
    mask.locked = true;
    mask.scale(1 / CHECKERBOARD_SIZE);
    var vGroup = new _paper2.default.Group([vRect, vPath, mask]);
    mask.clipMask = true;
    return vGroup;
};

// Helper function for drawing a crosshair
var _makeCrosshair = function _makeCrosshair(opacity, parent) {
    var crosshair = new _paper2.default.Group();

    var vLine2 = new _paper2.default.Path.Line(new _paper2.default.Point(0, -7), new _paper2.default.Point(0, 7));
    vLine2.strokeWidth = 6;
    vLine2.strokeColor = 'white';
    vLine2.strokeCap = 'round';
    crosshair.addChild(vLine2);
    var hLine2 = new _paper2.default.Path.Line(new _paper2.default.Point(-7, 0), new _paper2.default.Point(7, 0));
    hLine2.strokeWidth = 6;
    hLine2.strokeColor = 'white';
    hLine2.strokeCap = 'round';
    crosshair.addChild(hLine2);
    var circle2 = new _paper2.default.Shape.Circle(new _paper2.default.Point(0, 0), 5.5);
    circle2.strokeWidth = 6;
    circle2.strokeColor = 'white';
    crosshair.addChild(circle2);

    var vLine = new _paper2.default.Path.Line(new _paper2.default.Point(0, -7), new _paper2.default.Point(0, 7));
    vLine.strokeWidth = 2;
    vLine.strokeColor = 'black';
    vLine.strokeCap = 'round';
    crosshair.addChild(vLine);
    var hLine = new _paper2.default.Path.Line(new _paper2.default.Point(-7, 0), new _paper2.default.Point(7, 0));
    hLine.strokeWidth = 2;
    hLine.strokeColor = 'black';
    hLine.strokeCap = 'round';
    crosshair.addChild(hLine);
    var circle = new _paper2.default.Shape.Circle(new _paper2.default.Point(0, 0), 5.5);
    circle.strokeWidth = 2;
    circle.strokeColor = 'black';
    crosshair.addChild(circle);

    setGuideItem(crosshair);
    crosshair.position = _view.CENTER;
    crosshair.opacity = opacity;
    crosshair.parent = parent;
    crosshair.applyMatrix = false;
    parent.dragCrosshair = crosshair;
    crosshair.scale(CROSSHAIR_SIZE / crosshair.bounds.width / _paper2.default.view.zoom);
};

var _makeDragCrosshairLayer = function _makeDragCrosshairLayer() {
    var dragCrosshairLayer = new _paper2.default.Layer();
    _makeCrosshair(CROSSHAIR_FULL_OPACITY, dragCrosshairLayer);
    dragCrosshairLayer.data.isDragCrosshairLayer = true;
    dragCrosshairLayer.visible = false;
    return dragCrosshairLayer;
};

var _makeOutlineLayer = function _makeOutlineLayer() {
    var outlineLayer = new _paper2.default.Layer();
    var whiteRect = new _paper2.default.Shape.Rectangle(_view.ART_BOARD_BOUNDS.expand(1));
    whiteRect.strokeWidth = 2;
    whiteRect.strokeColor = 'white';
    setGuideItem(whiteRect);
    var blueRect = new _paper2.default.Shape.Rectangle(_view.ART_BOARD_BOUNDS.expand(5));
    blueRect.strokeWidth = 2;
    blueRect.strokeColor = '#4280D7';
    blueRect.opacity = 0.25;
    setGuideItem(blueRect);
    outlineLayer.data.isOutlineLayer = true;
    return outlineLayer;
};

var _makeBackgroundGuideLayer = function _makeBackgroundGuideLayer(format) {
    var guideLayer = new _paper2.default.Layer();
    guideLayer.locked = true;

    var vWorkspaceBounds = new _paper2.default.Shape.Rectangle(_view.MAX_WORKSPACE_BOUNDS);
    vWorkspaceBounds.fillColor = '#ECF1F9';
    vWorkspaceBounds.position = _view.CENTER;

    // Add 1 to the height because it's an odd number otherwise, and we want it to be even
    // so the corner of the checkerboard to line up with the center crosshair
    var vBackground = _makeBackgroundPaper(_view.MAX_WORKSPACE_BOUNDS.width / CHECKERBOARD_SIZE, _view.MAX_WORKSPACE_BOUNDS.height / CHECKERBOARD_SIZE + 1, '#D9E3F2', 0.55);
    vBackground.position = _view.CENTER;
    vBackground.scaling = new _paper2.default.Point(CHECKERBOARD_SIZE, CHECKERBOARD_SIZE);

    var vectorBackground = new _paper2.default.Group();
    vectorBackground.addChild(vWorkspaceBounds);
    vectorBackground.addChild(vBackground);
    setGuideItem(vectorBackground);
    guideLayer.vectorBackground = vectorBackground;

    var bitmapBackground = _makeBackgroundPaper(_view.ART_BOARD_WIDTH / CHECKERBOARD_SIZE, _view.ART_BOARD_HEIGHT / CHECKERBOARD_SIZE, '#D9E3F2', 0.55);
    bitmapBackground.position = _view.CENTER;
    bitmapBackground.scaling = new _paper2.default.Point(CHECKERBOARD_SIZE, CHECKERBOARD_SIZE);
    bitmapBackground.guide = true;
    bitmapBackground.locked = true;
    guideLayer.bitmapBackground = bitmapBackground;

    _convertLayer(guideLayer, format);

    _makeCrosshair(0.16, guideLayer);

    guideLayer.data.isBackgroundGuideLayer = true;
    return guideLayer;
};

var setupLayers = function setupLayers(format) {
    var backgroundGuideLayer = _makeBackgroundGuideLayer(format);
    _makeRasterLayer();
    var paintLayer = _makePaintingLayer();
    var dragCrosshairLayer = _makeDragCrosshairLayer();
    var outlineLayer = _makeOutlineLayer();
    var guideLayer = _makeGuideLayer();
    backgroundGuideLayer.sendToBack();
    dragCrosshairLayer.bringToFront();
    outlineLayer.bringToFront();
    guideLayer.bringToFront();
    paintLayer.activate();
};

exports.CROSSHAIR_SIZE = CROSSHAIR_SIZE;
exports.CROSSHAIR_FULL_OPACITY = CROSSHAIR_FULL_OPACITY;
exports.createCanvas = createCanvas;
exports.hideGuideLayers = hideGuideLayers;
exports.showGuideLayers = showGuideLayers;
exports.getDragCrosshairLayer = getDragCrosshairLayer;
exports.getGuideLayer = getGuideLayer;
exports.getBackgroundGuideLayer = getBackgroundGuideLayer;
exports.convertBackgroundGuideLayer = convertBackgroundGuideLayer;
exports.clearRaster = clearRaster;
exports.getRaster = getRaster;
exports.setGuideItem = setGuideItem;
exports.setupLayers = setupLayers;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    for (var i = 0; i < modules.length; i++) {
      var item = [].concat(modules[i]);

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keymirror = __webpack_require__(34);

var _keymirror2 = _interopRequireDefault(_keymirror);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GradientTypes = (0, _keymirror2.default)({
    SOLID: null,
    HORIZONTAL: null,
    VERTICAL: null,
    RADIAL: null
});
exports.default = GradientTypes;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactIntl = __webpack_require__(23);

var _button = __webpack_require__(38);

var _button2 = _interopRequireDefault(_button);

var _toolSelectBase = __webpack_require__(110);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ToolSelectComponent = function ToolSelectComponent(props) {
    return _react2.default.createElement(
        _button2.default,
        {
            className: (0, _classnames2.default)(props.className, _toolSelectBase2.default.modToolSelect, _defineProperty({}, _toolSelectBase2.default.isSelected, props.isSelected)),
            disabled: props.disabled,
            title: props.intl.formatMessage(props.imgDescriptor),
            onClick: props.onMouseDown
        },
        _react2.default.createElement('img', {
            alt: props.intl.formatMessage(props.imgDescriptor),
            className: _toolSelectBase2.default.toolSelectIcon,
            draggable: false,
            src: props.imgSrc
        })
    );
};

ToolSelectComponent.propTypes = {
    className: _propTypes2.default.string,
    disabled: _propTypes2.default.bool,
    imgDescriptor: _propTypes2.default.shape({
        defaultMessage: _propTypes2.default.string,
        description: _propTypes2.default.string,
        id: _propTypes2.default.string
    }).isRequired,
    imgSrc: _propTypes2.default.string.isRequired,
    intl: _reactIntl.intlShape.isRequired,
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = (0, _reactIntl.injectIntl)(ToolSelectComponent);

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _reactIntl = __webpack_require__(23);

var messages = (0, _reactIntl.defineMessages)({
    brush: {
        'id': 'paint.brushMode.brush',
        'defaultMessage': 'Brush'
    },
    eraser: {
        'id': 'paint.eraserMode.eraser',
        'defaultMessage': 'Eraser'
    },
    fill: {
        'id': 'paint.fillMode.fill',
        'defaultMessage': 'Fill'
    },
    line: {
        'id': 'paint.lineMode.line',
        'defaultMessage': 'Line'
    },
    oval: {
        'id': 'paint.ovalMode.oval',
        'defaultMessage': 'Circle'
    },
    rect: {
        'id': 'paint.rectMode.rect',
        'defaultMessage': 'Rectangle'
    },
    reshape: {
        'id': 'paint.reshapeMode.reshape',
        'defaultMessage': 'Reshape'
    },
    roundedRect: {
        'id': 'paint.roundedRectMode.roundedRect',
        'defaultMessage': 'Rounded Rectangle'
    },
    select: {
        'id': 'paint.selectMode.select',
        'defaultMessage': 'Select'
    },
    text: {
        'id': 'paint.textMode.text',
        'defaultMessage': 'Text'
    }
});

exports.default = messages;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CHANGE_FILL_GRADIENT_TYPE = exports.DEFAULT_COLOR = exports.clearFillGradient = exports.changeFillGradientType = exports.changeFillColor2 = exports.changeFillColor = exports.default = undefined;

var _makeColorStyleReducer = __webpack_require__(62);

var _makeColorStyleReducer2 = _interopRequireDefault(_makeColorStyleReducer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_FILL_COLOR = 'scratch-paint/fill-style/CHANGE_FILL_COLOR';
var CHANGE_FILL_COLOR_2 = 'scratch-paint/fill-style/CHANGE_FILL_COLOR_2';
var CHANGE_FILL_GRADIENT_TYPE = 'scratch-paint/fill-style/CHANGE_FILL_GRADIENT_TYPE';
var CLEAR_FILL_GRADIENT = 'scratch-paint/fill-style/CLEAR_FILL_GRADIENT';
var DEFAULT_COLOR = '#9966FF';

var reducer = (0, _makeColorStyleReducer2.default)({
    changePrimaryColorAction: CHANGE_FILL_COLOR,
    changeSecondaryColorAction: CHANGE_FILL_COLOR_2,
    changeGradientTypeAction: CHANGE_FILL_GRADIENT_TYPE,
    clearGradientAction: CLEAR_FILL_GRADIENT,
    defaultColor: DEFAULT_COLOR,
    selectionPrimaryColorKey: 'fillColor',
    selectionSecondaryColorKey: 'fillColor2',
    selectionGradientTypeKey: 'fillGradientType'
});

// Action creators ==================================
var changeFillColor = function changeFillColor(fillColor) {
    return {
        type: CHANGE_FILL_COLOR,
        color: fillColor
    };
};

var changeFillColor2 = function changeFillColor2(fillColor) {
    return {
        type: CHANGE_FILL_COLOR_2,
        color: fillColor
    };
};

var changeFillGradientType = function changeFillGradientType(gradientType) {
    return {
        type: CHANGE_FILL_GRADIENT_TYPE,
        gradientType: gradientType
    };
};

var clearFillGradient = function clearFillGradient() {
    return {
        type: CLEAR_FILL_GRADIENT
    };
};

exports.default = reducer;
exports.changeFillColor = changeFillColor;
exports.changeFillColor2 = changeFillColor2;
exports.changeFillGradientType = changeFillGradientType;
exports.clearFillGradient = clearFillGradient;
exports.DEFAULT_COLOR = DEFAULT_COLOR;
exports.CHANGE_FILL_GRADIENT_TYPE = CHANGE_FILL_GRADIENT_TYPE;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sortItemsByZIndex = exports.snapDeltaToAngle = exports.scaleWithStrokes = exports.getSquareDimensions = exports.getRandomBoolean = exports.getRandomInt = exports.expandBy = exports.ensureClockwise = exports.checkPointsClose = exports.HANDLE_RATIO = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** The ratio of the curve length to use for the handle length to convert squares into approximately circles. */
var HANDLE_RATIO = 0.3902628565;

var checkPointsClose = function checkPointsClose(startPos, eventPoint, threshold) {
    var xOff = Math.abs(startPos.x - eventPoint.x);
    var yOff = Math.abs(startPos.y - eventPoint.y);
    if (xOff < threshold && yOff < threshold) {
        return true;
    }
    return false;
};

var getRandomInt = function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
};

var getRandomBoolean = function getRandomBoolean() {
    return getRandomInt(0, 2) === 1;
};

// Thanks Mikko Mononen! https://github.com/memononen/stylii
var snapDeltaToAngle = function snapDeltaToAngle(delta, snapAngle) {
    var angle = Math.atan2(delta.y, delta.x);
    angle = Math.round(angle / snapAngle) * snapAngle;
    var dirx = Math.cos(angle);
    var diry = Math.sin(angle);
    var d = dirx * delta.x + diry * delta.y;
    return new _paper2.default.Point(dirx * d, diry * d);
};

var _getDepth = function _getDepth(item) {
    var temp = item;
    var depth = 0;
    while (!(temp instanceof _paper2.default.Layer)) {
        depth++;
        if (temp.parent === null) {
            // This item isn't attached to a layer, so it's not on the canvas and can't be compared.
            return null;
        }
        temp = temp.parent;
    }
    return depth;
};

var sortItemsByZIndex = function sortItemsByZIndex(a, b) {
    if (a === null || b === null) {
        return null;
    }

    // Get to the same depth in the project tree
    var tempA = a;
    var tempB = b;
    var aDepth = _getDepth(a);
    var bDepth = _getDepth(b);
    while (bDepth > aDepth) {
        tempB = tempB.parent;
        bDepth--;
    }
    while (aDepth > bDepth) {
        tempA = tempA.parent;
        aDepth--;
    }

    // Step up until they share parents. When they share parents, compare indices.
    while (tempA && tempB) {
        if (tempB === tempA) {
            return 0;
        } else if (tempB.parent === tempA.parent) {
            if (tempB.parent instanceof _paper2.default.CompoundPath) {
                // Neither is on top of the other in a compound path. Return in order of decreasing size.
                return Math.abs(tempB.area) - Math.abs(tempA.area);
            }
            return parseFloat(tempA.index) - parseFloat(tempB.index);
        }
        tempB = tempB.parent;
        tempA = tempA.parent;
    }

    // No shared hierarchy
    return null;
};

// Expand the size of the path by amount all around
var expandBy = function expandBy(path, amount) {
    var center = path.position;
    var pathArea = path.area;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = path.segments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var seg = _step.value;

            var delta = seg.point.subtract(center).normalize().multiply(amount);
            seg.point = seg.point.add(delta);
            // If that made the path area smaller, go the other way.
            if (path.area < pathArea) seg.point = seg.point.subtract(delta.multiply(2));
            pathArea = path.area;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
};

// Do for all nested items in groups
var _doRecursively = function _doRecursively(item, func) {
    if (item instanceof _paper2.default.Group) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = item.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var child = _step2.value;

                _doRecursively(child, func);
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }
    } else {
        func(item);
    }
};

// Make item clockwise. Drill down into groups.
var ensureClockwise = function ensureClockwise(root) {
    _doRecursively(root, function (item) {
        if (item instanceof _paper2.default.PathItem) {
            item.clockwise = true;
        }
    });
};

// Scale item and its strokes by factor
var scaleWithStrokes = function scaleWithStrokes(root, factor, pivot) {
    _doRecursively(root, function (item) {
        if (item instanceof _paper2.default.PointText) {
            // Text outline size is controlled by text transform matrix, thus it's already scaled.
            return;
        }
        if (item.strokeWidth) {
            item.strokeWidth = item.strokeWidth * factor;
        }
    });
    root.scale(factor, pivot);
};

/**
 * Get the size and position of a square, as in if the user were holding the shift key down while drawing the shape,
 * from the point where the drag started and the point where the mouse is currently positioned. (Note: This also works
 * for shapes like circles ("square ovals"), which fill the same dimensions.)
 * @param {!paper.Point} startPos The point where the user started dragging
 * @param {!paper.Point} eventPoint The point where the user has currently dragged to
 * @return {object} Information about the size and position of how the square should be drawn
 */
var getSquareDimensions = function getSquareDimensions(startPos, eventPoint) {
    // These variables are used for determining the relative quadrant that the shape will appear in.
    // So if you drag up and right, it'll show up above and to the right of where you started dragging, etc.
    var offsetX = eventPoint.x - startPos.x;
    var offsetY = eventPoint.y - startPos.y;

    // If the offset variables are zero, the shape ends up having zero width or height, which is bad.
    // Deal with this by forcing them to be non-zero (we arbitrarily choose 1; any non-zero value would work).
    offsetX = offsetX ? offsetX : 1;
    offsetY = offsetY ? offsetY : 1;

    // The length of the shape is the greater of the X and Y offsets.
    var offsetDistance = eventPoint.subtract(startPos).abs();
    var length = Math.max(offsetDistance.x, offsetDistance.y);

    var size = new _paper2.default.Point(length * offsetX / Math.abs(offsetX), length * offsetY / Math.abs(offsetY));

    var position = startPos.add(size.multiply(0.5));

    return { size: size, position: position };
};

exports.HANDLE_RATIO = HANDLE_RATIO;
exports.checkPointsClose = checkPointsClose;
exports.ensureClockwise = ensureClockwise;
exports.expandBy = expandBy;
exports.getRandomInt = getRandomInt;
exports.getRandomBoolean = getRandomBoolean;
exports.getSquareDimensions = getSquareDimensions;
exports.scaleWithStrokes = scaleWithStrokes;
exports.snapDeltaToAngle = snapDeltaToAngle;
exports.sortItemsByZIndex = sortItemsByZIndex;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.selectAllBitmap = exports.scaleBitmap = exports.flipBitmapVertical = exports.flipBitmapHorizontal = exports.forEachLinePoint = exports.drawEllipse = exports.getTrimmedRaster = exports.getHitBounds = exports.getBrushMark = exports.floodFillAll = exports.floodFill = exports.outlineRect = exports.fillRect = exports.convertToVector = exports.convertToBitmap = exports.commitRectToBitmap = exports.commitOvalToBitmap = exports.commitSelectionToBitmap = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _layer = __webpack_require__(12);

var _guides = __webpack_require__(27);

var _selection = __webpack_require__(3);

var _view = __webpack_require__(22);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var forEachLinePoint = function forEachLinePoint(point1, point2, callback) {
    // Bresenham line algorithm
    var x1 = ~~point1.x;
    var x2 = ~~point2.x;
    var y1 = ~~point1.y;
    var y2 = ~~point2.y;

    var dx = Math.abs(x2 - x1);
    var dy = Math.abs(y2 - y1);
    var sx = x1 < x2 ? 1 : -1;
    var sy = y1 < y2 ? 1 : -1;
    var err = dx - dy;

    callback(x1, y1);
    while (x1 !== x2 || y1 !== y2) {
        var e2 = err * 2;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
        callback(x1, y1);
    }
};

/**
 * @param {!number} a Coefficient in ax^2 + bx + c = 0
 * @param {!number} b Coefficient in ax^2 + bx + c = 0
 * @param {!number} c Coefficient in ax^2 + bx + c = 0
 * @return {Array<number>} Array of 2 solutions, with the larger solution first
 */
var solveQuadratic_ = function solveQuadratic_(a, b, c) {
    var soln1 = (-b + Math.sqrt(b * b - 4 * a * c)) / 2 / a;
    var soln2 = (-b - Math.sqrt(b * b - 4 * a * c)) / 2 / a;
    return soln1 > soln2 ? [soln1, soln2] : [soln2, soln1];
};

/**
 * @param {!object} options drawing options
 * @param {!number} options.centerX center of ellipse, x
 * @param {!number} options.centerY center of ellipse, y
 * @param {!number} options.radiusX major radius of ellipse
 * @param {!number} options.radiusY minor radius of ellipse
 * @param {!number} options.shearSlope slope of the sheared x axis
 * @param {?boolean} options.isFilled true if isFilled
 * @param {?function} options.drawFn The function called on each point in the outline, used only
 *     if isFilled is false.
 * @param {!CanvasRenderingContext2D} context for drawing
 * @return {boolean} true if anything was drawn, false if not
 */
var drawShearedEllipse_ = function drawShearedEllipse_(options, context) {
    var centerX = ~~options.centerX;
    var centerY = ~~options.centerY;
    var radiusX = ~~Math.abs(options.radiusX) - .5;
    var radiusY = ~~Math.abs(options.radiusY) - .5;
    var shearSlope = options.shearSlope;
    var isFilled = options.isFilled;
    var drawFn = options.drawFn;
    if (shearSlope === Infinity || radiusX < 1 || radiusY < 1) {
        return false;
    }
    // A, B, and C represent Ax^2 + Bxy + Cy^2 = 1 coefficients in a skewed ellipse formula
    var A = 1 / radiusX / radiusX + shearSlope * shearSlope / radiusY / radiusY;
    var B = -2 * shearSlope / radiusY / radiusY;
    var C = 1 / radiusY / radiusY;
    // Line with slope1 intersects the ellipse where its derivative is 1
    var slope1 = (-2 * A - B) / (2 * C + B);
    // Line with slope2 intersects the ellipse where its derivative is -1
    var slope2 = (-(2 * A) + B) / (-(2 * C) + B);
    var verticalStepsFirst = slope1 > slope2;

    /**
     * Vertical stepping portion of ellipse drawing algorithm
     * @param {!number} startY y to start drawing from
     * @param {!function} conditionFn function which should become true when we should stop stepping
     * @return {object} last point drawn to the canvas, or null if no points drawn
     */
    var drawEllipseStepVertical_ = function drawEllipseStepVertical_(startY, conditionFn) {
        // Points on the ellipse
        var y = startY;
        var x = solveQuadratic_(A, B * y, C * y * y - 1);
        // last pixel position at which a draw was performed
        var pY = void 0;
        var pX1 = void 0;
        var pX2 = void 0;
        while (conditionFn(x[0], y)) {
            pY = Math.floor(y);
            pX1 = Math.floor(x[0]);
            pX2 = Math.floor(x[1]);
            if (isFilled) {
                context.fillRect(centerX - pX1 - 1, centerY + pY, pX1 - pX2 + 1, 1);
                context.fillRect(centerX + pX2, centerY - pY - 1, pX1 - pX2 + 1, 1);
            } else {
                drawFn(centerX - pX1 - 1, centerY + pY);
                drawFn(centerX + pX1, centerY - pY - 1);
            }
            y--;
            x = solveQuadratic_(A, B * y, C * y * y - 1);
        }
        return pX1 || pY ? { x: pX1, y: pY } : null;
    };

    /**
     * Horizontal stepping portion of ellipse drawing algorithm
     * @param {!number} startX x to start drawing from
     * @param {!function} conditionFn function which should become false when we should stop stepping
     * @return {object} last point drawn to the canvas, or null if no points drawn
     */
    var drawEllipseStepHorizontal_ = function drawEllipseStepHorizontal_(startX, conditionFn) {
        // Points on the ellipse
        var x = startX;
        var y = solveQuadratic_(C, B * x, A * x * x - 1);
        // last pixel position at which a draw was performed
        var pX = void 0;
        var pY1 = void 0;
        var pY2 = void 0;
        while (conditionFn(x, y[0])) {
            pX = Math.floor(x);
            pY1 = Math.floor(y[0]);
            pY2 = Math.floor(y[1]);
            if (isFilled) {
                context.fillRect(centerX - pX - 1, centerY + pY2, 1, pY1 - pY2 + 1);
                context.fillRect(centerX + pX, centerY - pY1 - 1, 1, pY1 - pY2 + 1);
            } else {
                drawFn(centerX - pX - 1, centerY + pY1);
                drawFn(centerX + pX, centerY - pY1 - 1);
            }
            x++;
            y = solveQuadratic_(C, B * x, A * x * x - 1);
        }
        return pX || pY1 ? { x: pX, y: pY1 } : null;
    };

    // Last point drawn
    var lastPoint = void 0;
    if (verticalStepsFirst) {
        var forwardLeaning = false;
        if (slope1 > 0) forwardLeaning = true;

        // step vertically
        lastPoint = drawEllipseStepVertical_(forwardLeaning ? -radiusY : radiusY, function (x, y) {
            if (x === 0 && y > 0) return true;
            if (x === 0 && y < 0) return false;
            return y / x > slope1;
        });
        // step horizontally while slope is flat
        lastPoint = drawEllipseStepHorizontal_(lastPoint ? -lastPoint.x + .5 : .5, function (x, y) {
            return y / x > slope2;
        }) || { x: -lastPoint.x - .5, y: -lastPoint.y - .5 };
        // step vertically until back to start
        drawEllipseStepVertical_(lastPoint.y - .5, function (x, y) {
            if (forwardLeaning) return y > -radiusY;
            return y > radiusY;
        });
    } else {
        // step horizontally forward
        lastPoint = drawEllipseStepHorizontal_(.5, function (x, y) {
            return y / x > slope2;
        });
        // step vertically while slope is steep
        lastPoint = drawEllipseStepVertical_(lastPoint ? lastPoint.y - .5 : radiusY, function (x, y) {
            if (x === 0 && y > 0) return true;
            if (x === 0 && y < 0) return false;
            return y / x > slope1;
        }) || lastPoint;
        // step horizontally until back to start
        drawEllipseStepHorizontal_(-lastPoint.x + .5, function (x) {
            return x < 0;
        });
    }
    return true;
};

/**
 * @param {!number} size The diameter of the brush
 * @param {!string} color The css color of the brush
 * @param {?boolean} isEraser True if we want the brush mark for the eraser
 * @return {HTMLCanvasElement} a canvas with the brush mark printed on it
 */
var getBrushMark = function getBrushMark(size, color, isEraser) {
    size = ~~size;
    var canvas = document.createElement('canvas');
    var roundedUpRadius = Math.ceil(size / 2);
    canvas.width = roundedUpRadius * 2;
    canvas.height = roundedUpRadius * 2;
    var context = canvas.getContext('2d');
    context.imageSmoothingEnabled = false;
    context.fillStyle = isEraser ? 'white' : color;
    // Small squares for pixel artists
    if (size <= 5) {
        var offset = 0;
        if (size % 2) offset = 1;
        if (isEraser) {
            context.fillStyle = (0, _guides.getGuideColor)();
            context.fillRect(offset, offset, size, size);
            context.fillStyle = 'white';
            context.fillRect(offset + 1, offset + 1, size - 2, size - 2);
        } else {
            context.fillRect(offset, offset, size, size);
        }
    } else {
        drawShearedEllipse_({
            centerX: size / 2,
            centerY: size / 2,
            radiusX: size / 2,
            radiusY: size / 2,
            shearSlope: 0,
            isFilled: true
        }, context);
        if (isEraser) {
            // Add outline
            context.fillStyle = (0, _guides.getGuideColor)();
            drawShearedEllipse_({
                centerX: size / 2,
                centerY: size / 2,
                radiusX: size / 2,
                radiusY: size / 2,
                shearSlope: 0,
                isFilled: false,
                drawFn: function drawFn(x, y) {
                    return context.fillRect(x, y, 1, 1);
                }
            }, context);
        }
    }
    return canvas;
};

/**
 * Draw an ellipse, given the original axis-aligned radii and
 * an affine transformation. Returns false if the ellipse could
 * not be drawn; for instance, the matrix is non-invertible.
 *
 * @param {!options} options Parameters for the ellipse
 * @param {!paper.Point} options.position Center of ellipse
 * @param {!number} options.radiusX x-aligned radius of ellipse
 * @param {!number} options.radiusY y-aligned radius of ellipse
 * @param {!paper.Matrix} options.matrix affine transformation matrix
 * @param {?boolean} options.isFilled true if isFilled
 * @param {?number} options.thickness Thickness of outline, used only if isFilled is false.
 * @param {!CanvasRenderingContext2D} context for drawing
 * @return {boolean} true if anything was drawn, false if not
 */
var drawEllipse = function drawEllipse(options, context) {
    var positionX = options.position.x;
    var positionY = options.position.y;
    var radiusX = options.radiusX;
    var radiusY = options.radiusY;
    var matrix = options.matrix;
    var isFilled = options.isFilled;
    var thickness = options.thickness;
    var drawFn = null;

    if (!matrix.isInvertible()) return false;
    var inverse = matrix.clone().invert();

    var isGradient = context.fillStyle instanceof CanvasGradient;

    // If drawing a gradient, we need to draw the shape onto a temporary canvas, then draw the gradient atop that canvas
    // only where the shape appears. drawShearedEllipse draws some pixels twice, which would be a problem if the
    // gradient fades to transparent as those pixels would end up looking more opaque. Instead, mask in the gradient.
    // https://github.com/LLK/scratch-paint/issues/1152
    // Outlines are drawn as a series of brush mark images and as such can't be drawn as gradients in the first place.
    var origContext = void 0;
    var tmpCanvas = void 0;
    var _context$canvas = context.canvas,
        canvasWidth = _context$canvas.width,
        canvasHeight = _context$canvas.height;

    if (isGradient) {
        tmpCanvas = (0, _layer.createCanvas)(canvasWidth, canvasHeight);
        origContext = context;
        context = tmpCanvas.getContext('2d');
    }

    if (!isFilled) {
        var brushMark = getBrushMark(thickness, isGradient ? 'black' : context.fillStyle);
        var roundedUpRadius = Math.ceil(thickness / 2);
        drawFn = function drawFn(x, y) {
            context.drawImage(brushMark, ~~x - roundedUpRadius, ~~y - roundedUpRadius);
        };
    }

    // Calculate the ellipse formula
    // A, B, and C represent Ax^2 + Bxy + Cy^2 = 1 coefficients in a transformed ellipse formula
    var A = inverse.a * inverse.a / radiusX / radiusX + inverse.b * inverse.b / radiusY / radiusY;
    var B = 2 * inverse.a * inverse.c / radiusX / radiusX + 2 * inverse.b * inverse.d / radiusY / radiusY;
    var C = inverse.c * inverse.c / radiusX / radiusX + inverse.d * inverse.d / radiusY / radiusY;

    // Convert to a sheared ellipse formula. All ellipses are equivalent to some sheared axis-aligned ellipse.
    // radiusA, radiusB, and slope are parameters of a skewed ellipse with the above formula
    var radiusB = 1 / Math.sqrt(C);
    var radiusA = Math.sqrt(-4 * C / (B * B - 4 * A * C));
    var slope = B / 2 / C;

    var wasDrawn = drawShearedEllipse_({
        centerX: positionX,
        centerY: positionY,
        radiusX: radiusA,
        radiusY: radiusB,
        shearSlope: slope,
        isFilled: isFilled,
        drawFn: drawFn
    }, context);

    // Mask in the gradient only where the shape was drawn, and draw it. Then draw the gradientified shape onto the
    // original canvas normally.
    if (isGradient && wasDrawn) {
        context.globalCompositeOperation = 'source-in';
        context.fillStyle = origContext.fillStyle;
        context.fillRect(0, 0, canvasWidth, canvasHeight);
        origContext.drawImage(tmpCanvas, 0, 0);
    }

    return wasDrawn;
};

var rowBlank_ = function rowBlank_(imageData, width, y) {
    for (var x = 0; x < width; ++x) {
        if (imageData.data[(y * width << 2) + (x << 2) + 3] !== 0) return false;
    }
    return true;
};

var columnBlank_ = function columnBlank_(imageData, width, x, top, bottom) {
    for (var y = top; y < bottom; ++y) {
        if (imageData.data[(y * width << 2) + (x << 2) + 3] !== 0) return false;
    }
    return true;
};

/**
 * Get bounds around the contents of a raster, trimming transparent pixels from edges.
 * Adapted from Tim Down's https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf
 * @param {paper.Raster} raster The raster to get the bounds around
 * @param {paper.Rectangle} [rect] Optionally, an alternative bounding rectangle to limit the check to.
 * @returns {paper.Rectangle} The bounds around the opaque area of the passed raster
 * (or opaque within the passed rectangle)
 */
var getHitBounds = function getHitBounds(raster, rect) {
    var bounds = rect || raster.bounds;
    var width = bounds.width;
    var imageData = raster.getImageData(bounds);
    var top = 0;
    var bottom = imageData.height;
    var left = 0;
    var right = imageData.width;

    while (top < bottom && rowBlank_(imageData, width, top)) {
        ++top;
    }while (bottom - 1 > top && rowBlank_(imageData, width, bottom - 1)) {
        --bottom;
    }while (left < right && columnBlank_(imageData, width, left, top, bottom)) {
        ++left;
    }while (right - 1 > left && columnBlank_(imageData, width, right - 1, top, bottom)) {
        --right;
    } // Center an empty bitmap
    if (top === bottom) {
        top = bottom = imageData.height / 2;
    }
    if (left === right) {
        left = right = imageData.width / 2;
    }

    return new _paper2.default.Rectangle(left + bounds.left, top + bounds.top, right - left, bottom - top);
};

var trim_ = function trim_(raster) {
    var hitBounds = getHitBounds(raster);
    if (hitBounds.width && hitBounds.height) {
        return raster.getSubRaster(getHitBounds(raster));
    }
    return null;
};

/**
 * @param {boolean} shouldInsert True if the trimmed raster should be added to the active layer.
 * @returns {paper.Raster} raster layer with whitespace trimmed from ends, or null if there is
 * nothing on the raster layer.
 */
var getTrimmedRaster = function getTrimmedRaster(shouldInsert) {
    var trimmedRaster = trim_((0, _layer.getRaster)());
    if (!trimmedRaster) return null;
    if (shouldInsert) {
        _paper2.default.project.activeLayer.addChild(trimmedRaster);
    } else {
        trimmedRaster.remove();
    }
    return trimmedRaster;
};

var convertToBitmap = function convertToBitmap(clearSelectedItems, onUpdateImage, optFontInlineFn) {
    // @todo if the active layer contains only rasters, drawing them directly to the raster layer
    // would be more efficient.

    (0, _selection.clearSelection)(clearSelectedItems);

    // Export svg
    var guideLayers = (0, _layer.hideGuideLayers)(true /* includeRaster */);
    var bounds = _paper2.default.project.activeLayer.drawnBounds;
    var svg = _paper2.default.project.exportSVG({
        bounds: 'content',
        matrix: new _paper2.default.Matrix().translate(-bounds.x, -bounds.y)
    });
    (0, _layer.showGuideLayers)(guideLayers);

    // Get rid of anti-aliasing
    // @todo get crisp text https://github.com/LLK/scratch-paint/issues/508
    svg.setAttribute('shape-rendering', 'crispEdges');

    var svgString = new XMLSerializer().serializeToString(svg);
    if (optFontInlineFn) {
        svgString = optFontInlineFn(svgString);
    } else {
        _log2.default.error('Fonts may be converted to bitmap incorrectly if fontInlineFn prop is not set on PaintEditor.');
    }

    // Put anti-aliased SVG into image, and dump image back into canvas
    var img = new Image();
    img.onload = function () {
        if (img.width && img.height) {
            (0, _layer.getRaster)().drawImage(img, new _paper2.default.Point(Math.floor(bounds.topLeft.x), Math.floor(bounds.topLeft.y)));
        }
        for (var i = _paper2.default.project.activeLayer.children.length - 1; i >= 0; i--) {
            var item = _paper2.default.project.activeLayer.children[i];
            if (item.clipMask === false) {
                item.remove();
            } else {
                // Resize mask for bitmap bounds
                item.size.height = _view.ART_BOARD_HEIGHT;
                item.size.width = _view.ART_BOARD_WIDTH;
                item.setPosition(_view.CENTER);
            }
        }
        onUpdateImage(false /* skipSnapshot */, _format2.default.BITMAP /* formatOverride */);
    };
    img.onerror = function () {
        // Fallback if browser does not support SVG data URIs in images.
        // The problem with rasterize is that it will anti-alias.
        var raster = _paper2.default.project.activeLayer.rasterize(72, false /* insert */);
        raster.onLoad = function () {
            if (raster.canvas.width && raster.canvas.height) {
                (0, _layer.getRaster)().drawImage(raster.canvas, raster.bounds.topLeft);
            }
            _paper2.default.project.activeLayer.removeChildren();
            onUpdateImage(false /* skipSnapshot */, _format2.default.BITMAP /* formatOverride */);
        };
    };
    // Hash tags will break image loading without being encoded first
    img.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(svgString);
};

var convertToVector = function convertToVector(clearSelectedItems, onUpdateImage) {
    (0, _selection.clearSelection)(clearSelectedItems);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = _paper2.default.project.activeLayer.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            if (item.clipMask === true) {
                // Resize mask for vector bounds
                item.size.height = _view.MAX_WORKSPACE_BOUNDS.height;
                item.size.width = _view.MAX_WORKSPACE_BOUNDS.width;
                item.setPosition(_view.CENTER);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    getTrimmedRaster(true /* shouldInsert */);

    (0, _layer.clearRaster)();
    onUpdateImage(false /* skipSnapshot */, _format2.default.VECTOR /* formatOverride */);
};

var getColor_ = function getColor_(x, y, context) {
    return context.getImageData(x, y, 1, 1).data;
};

var matchesColor_ = function matchesColor_(x, y, imageData, oldColor) {
    var index = (y * imageData.width + x) * 4;
    return imageData.data[index + 0] === oldColor[0] && imageData.data[index + 1] === oldColor[1] && imageData.data[index + 2] === oldColor[2] && imageData.data[index + 3] === oldColor[3];
};

var colorPixel_ = function colorPixel_(x, y, imageData, newColor) {
    var index = (y * imageData.width + x) * 4;
    imageData.data[index + 0] = newColor[0];
    imageData.data[index + 1] = newColor[1];
    imageData.data[index + 2] = newColor[2];
    imageData.data[index + 3] = newColor[3];
};

/**
 * Flood fill beginning at the given point.
 * Based on http://www.williammalone.com/articles/html5-canvas-javascript-paint-bucket-tool/
 *
 * @param {!int} x The x coordinate on the context at which to begin
 * @param {!int} y The y coordinate on the context at which to begin
 * @param {!ImageData} sourceImageData The image data to sample from. This is edited by the function.
 * @param {!ImageData} destImageData The image data to edit. May match sourceImageData. Should match
 *     size of sourceImageData.
 * @param {!Array<number>} newColor The color to replace with. A length 4 array [r, g, b, a].
 * @param {!Array<number>} oldColor The color to replace. A length 4 array [r, g, b, a].
 *     This must be different from newColor.
 * @param {!Array<Array<int>>} stack The stack of pixels we need to look at
 */
var floodFillInternal_ = function floodFillInternal_(x, y, sourceImageData, destImageData, newColor, oldColor, stack) {
    while (y > 0 && matchesColor_(x, y - 1, sourceImageData, oldColor)) {
        y--;
    }
    var lastLeftMatchedColor = false;
    var lastRightMatchedColor = false;
    for (; y < sourceImageData.height; y++) {
        if (!matchesColor_(x, y, sourceImageData, oldColor)) break;
        colorPixel_(x, y, sourceImageData, newColor);
        colorPixel_(x, y, destImageData, newColor);
        if (x > 0) {
            if (matchesColor_(x - 1, y, sourceImageData, oldColor)) {
                if (!lastLeftMatchedColor) {
                    stack.push([x - 1, y]);
                    lastLeftMatchedColor = true;
                }
            } else {
                lastLeftMatchedColor = false;
            }
        }
        if (x < sourceImageData.width - 1) {
            if (matchesColor_(x + 1, y, sourceImageData, oldColor)) {
                if (!lastRightMatchedColor) {
                    stack.push([x + 1, y]);
                    lastRightMatchedColor = true;
                }
            } else {
                lastRightMatchedColor = false;
            }
        }
    }
};

/**
 * Given a fill style string, get the color
 * @param {string} fillStyleString the fill style
 * @return {Array<int>} Color, a length 4 array
 */
var fillStyleToColor_ = function fillStyleToColor_(fillStyleString) {
    var tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = 1;
    tmpCanvas.height = 1;
    var context = tmpCanvas.getContext('2d');
    context.fillStyle = fillStyleString;
    context.fillRect(0, 0, 1, 1);
    return context.getImageData(0, 0, 1, 1).data;
};

/**
 * Flood fill beginning at the given point
 * @param {!number} x The x coordinate on the context at which to begin
 * @param {!number} y The y coordinate on the context at which to begin
 * @param {!string} color A color string, which would go into context.fillStyle
 * @param {!HTMLCanvas2DContext} sourceContext The context from which to sample to determine where to flood fill
 * @param {!HTMLCanvas2DContext} destContext The context to which to draw. May match sourceContext. Should match
 *     the size of sourceContext.
 * @return {boolean} True if image changed, false otherwise
 */
var floodFill = function floodFill(x, y, color, sourceContext, destContext) {
    x = ~~x;
    y = ~~y;
    var newColor = fillStyleToColor_(color);
    var oldColor = getColor_(x, y, sourceContext);
    var sourceImageData = sourceContext.getImageData(0, 0, sourceContext.canvas.width, sourceContext.canvas.height);
    var destImageData = sourceImageData;
    if (destContext !== sourceContext) {
        destImageData = new ImageData(sourceContext.canvas.width, sourceContext.canvas.height);
    }
    if (oldColor[0] === newColor[0] && oldColor[1] === newColor[1] && oldColor[2] === newColor[2] && oldColor[3] === newColor[3]) {
        // no-op
        return false;
    }
    var stack = [[x, y]];
    while (stack.length) {
        var pop = stack.pop();
        floodFillInternal_(pop[0], pop[1], sourceImageData, destImageData, newColor, oldColor, stack);
    }
    destContext.putImageData(destImageData, 0, 0);
    return true;
};

/**
 * Replace all instances of the color at the given point
 * @param {!number} x The x coordinate on the context of the start color
 * @param {!number} y The y coordinate on the context of the start color
 * @param {!string} color A color string, which would go into context.fillStyle
 * @param {!HTMLCanvas2DContext} sourceContext The context from which to sample to determine where to flood fill
 * @param {!HTMLCanvas2DContext} destContext The context to which to draw. May match sourceContext. Should match
 * @return {boolean} True if image changed, false otherwise
 */
var floodFillAll = function floodFillAll(x, y, color, sourceContext, destContext) {
    x = ~~x;
    y = ~~y;
    var newColor = fillStyleToColor_(color);
    var oldColor = getColor_(x, y, sourceContext);
    var sourceImageData = sourceContext.getImageData(0, 0, sourceContext.canvas.width, sourceContext.canvas.height);
    var destImageData = sourceImageData;
    if (destContext !== sourceContext) {
        destImageData = new ImageData(sourceContext.canvas.width, sourceContext.canvas.height);
    }
    if (oldColor[0] === newColor[0] && oldColor[1] === newColor[1] && oldColor[2] === newColor[2] && oldColor[3] === newColor[3]) {
        // no-op
        return false;
    }
    for (var i = 0; i < sourceImageData.width; i++) {
        for (var j = 0; j < sourceImageData.height; j++) {
            if (matchesColor_(i, j, sourceImageData, oldColor)) {
                colorPixel_(i, j, destImageData, newColor);
            }
        }
    }
    destContext.putImageData(destImageData, 0, 0);
    return true;
};

/**
 * @param {!paper.Shape.Rectangle} rect The rectangle to draw to the canvas
 * @param {!HTMLCanvas2DContext} context The context in which to draw
 */
var fillRect = function fillRect(rect, context) {
    // No rotation component to matrix
    if (rect.matrix.b === 0 && rect.matrix.c === 0) {
        var width = rect.size.width * rect.matrix.a;
        var height = rect.size.height * rect.matrix.d;
        context.fillRect(Math.round(rect.matrix.tx - width / 2), Math.round(rect.matrix.ty - height / 2), Math.round(width), Math.round(height));
        return;
    }
    var startPoint = rect.matrix.transform(new _paper2.default.Point(-rect.size.width / 2, -rect.size.height / 2));
    var widthPoint = rect.matrix.transform(new _paper2.default.Point(rect.size.width / 2, -rect.size.height / 2));
    var heightPoint = rect.matrix.transform(new _paper2.default.Point(-rect.size.width / 2, rect.size.height / 2));
    var endPoint = rect.matrix.transform(new _paper2.default.Point(rect.size.width / 2, rect.size.height / 2));
    var center = rect.matrix.transform(new _paper2.default.Point());
    var points = [startPoint, widthPoint, heightPoint, endPoint].sort(function (a, b) {
        return a.x - b.x;
    });

    var solveY = function solveY(point1, point2, x) {
        if (point2.x === point1.x) return center.x > point1.x ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        return (point2.y - point1.y) / (point2.x - point1.x) * (x - point1.x) + point1.y;
    };
    for (var x = Math.round(points[0].x); x < Math.round(points[3].x); x++) {
        var ys = [solveY(startPoint, widthPoint, x + .5), solveY(startPoint, heightPoint, x + .5), solveY(endPoint, widthPoint, x + .5), solveY(endPoint, heightPoint, x + .5)].sort(function (a, b) {
            return a - b;
        });
        context.fillRect(x, Math.round(ys[1]), 1, Math.max(1, Math.round(ys[2]) - Math.round(ys[1])));
    }
};

/**
 * @param {!paper.Shape.Rectangle} rect The rectangle to draw to the canvas
 * @param {!number} thickness The thickness of the outline
 * @param {!HTMLCanvas2DContext} context The context in which to draw
 */
var outlineRect = function outlineRect(rect, thickness, context) {
    var brushMark = getBrushMark(thickness, context.fillStyle);
    var roundedUpRadius = Math.ceil(thickness / 2);
    var drawFn = function drawFn(x, y) {
        context.drawImage(brushMark, ~~x - roundedUpRadius, ~~y - roundedUpRadius);
    };

    var isGradient = context.fillStyle instanceof CanvasGradient;

    // If drawing a gradient, we need to draw the shape onto a temporary canvas, then draw the gradient atop that canvas
    // only where the shape appears. Outlines are drawn as a series of brush mark images and as such can't be drawn as
    // gradients.
    var origContext = void 0;
    var tmpCanvas = void 0;
    var _context$canvas2 = context.canvas,
        canvasWidth = _context$canvas2.width,
        canvasHeight = _context$canvas2.height;

    if (isGradient) {
        tmpCanvas = (0, _layer.createCanvas)(canvasWidth, canvasHeight);
        origContext = context;
        context = tmpCanvas.getContext('2d');
    }

    var startPoint = rect.matrix.transform(new _paper2.default.Point(-rect.size.width / 2, -rect.size.height / 2));
    var widthPoint = rect.matrix.transform(new _paper2.default.Point(rect.size.width / 2, -rect.size.height / 2));
    var heightPoint = rect.matrix.transform(new _paper2.default.Point(-rect.size.width / 2, rect.size.height / 2));
    var endPoint = rect.matrix.transform(new _paper2.default.Point(rect.size.width / 2, rect.size.height / 2));

    forEachLinePoint(startPoint, widthPoint, drawFn);
    forEachLinePoint(startPoint, heightPoint, drawFn);
    forEachLinePoint(endPoint, widthPoint, drawFn);
    forEachLinePoint(endPoint, heightPoint, drawFn);

    // Mask in the gradient only where the shape was drawn, and draw it. Then draw the gradientified shape onto the
    // original canvas normally.
    if (isGradient) {
        context.globalCompositeOperation = 'source-in';
        context.fillStyle = origContext.fillStyle;
        context.fillRect(0, 0, canvasWidth, canvasHeight);
        origContext.drawImage(tmpCanvas, 0, 0);
    }
};

var flipBitmapHorizontal = function flipBitmapHorizontal(canvas) {
    var tmpCanvas = (0, _layer.createCanvas)(canvas.width, canvas.height);
    var context = tmpCanvas.getContext('2d');
    context.save();
    context.scale(-1, 1);
    context.drawImage(canvas, 0, 0, -tmpCanvas.width, tmpCanvas.height);
    context.restore();
    return tmpCanvas;
};

var flipBitmapVertical = function flipBitmapVertical(canvas) {
    var tmpCanvas = (0, _layer.createCanvas)(canvas.width, canvas.height);
    var context = tmpCanvas.getContext('2d');
    context.save();
    context.scale(1, -1);
    context.drawImage(canvas, 0, 0, tmpCanvas.width, -tmpCanvas.height);
    context.restore();
    return tmpCanvas;
};

var scaleBitmap = function scaleBitmap(canvas, scale) {
    var tmpCanvas = (0, _layer.createCanvas)(Math.round(canvas.width * Math.abs(scale.x)), canvas.height);
    if (scale.x < 0) {
        canvas = flipBitmapHorizontal(canvas);
    }
    tmpCanvas.getContext('2d').drawImage(canvas, 0, 0, tmpCanvas.width, tmpCanvas.height);
    canvas = tmpCanvas;
    tmpCanvas = (0, _layer.createCanvas)(canvas.width, Math.round(canvas.height * Math.abs(scale.y)));
    if (scale.y < 0) {
        canvas = flipBitmapVertical(canvas);
    }
    tmpCanvas.getContext('2d').drawImage(canvas, 0, 0, tmpCanvas.width, tmpCanvas.height);
    return tmpCanvas;
};

/**
 * Given a raster, take the scale on the transform and apply it to the raster's canvas, then remove
 * the scale from the item's transform matrix. Do this only if scale.x or scale.y is less than 1.
 * @param {paper.Raster} item raster to change
 */
var maybeApplyScaleToCanvas_ = function maybeApplyScaleToCanvas_(item) {
    // context.drawImage will anti-alias the image if both width and height are reduced.
    // However, it will preserve pixel colors if only one or the other is reduced, and
    // imageSmoothingEnabled is set to false. Therefore, we can avoid aliasing by scaling
    // down images in a 2 step process.
    var decomposed = item.matrix.decompose(); // Decomposition order: translate, rotate, scale, skew
    if (Math.abs(decomposed.scaling.x) < 1 && Math.abs(decomposed.scaling.y) < 1 && decomposed.scaling.x !== 0 && decomposed.scaling.y !== 0) {
        item.canvas = scaleBitmap(item.canvas, decomposed.scaling);
        if (item.data && item.data.expanded) {
            item.data.expanded.canvas = scaleBitmap(item.data.expanded.canvas, decomposed.scaling);
        }
        // Remove the scale from the item's matrix
        item.matrix.append(new _paper2.default.Matrix().scale(new _paper2.default.Point(1 / decomposed.scaling.x, 1 / decomposed.scaling.y)));
    }
};

/**
 * Given a raster, apply its transformation matrix to its canvas. Call maybeApplyScaleToCanvas_ first
 * to avoid introducing anti-aliasing to scaled-down rasters.
 * @param {paper.Raster} item raster to resolve transform of
 * @param {paper.Raster} destination raster to draw selection to
 */
var commitArbitraryTransformation_ = function commitArbitraryTransformation_(item, destination) {
    // Create a canvas to perform masking
    var tmpCanvas = (0, _layer.createCanvas)();
    var context = tmpCanvas.getContext('2d');
    // Draw mask
    var rect = new _paper2.default.Shape.Rectangle(new _paper2.default.Point(), item.size);
    rect.matrix = item.matrix;
    fillRect(rect, context);
    rect.remove();
    context.globalCompositeOperation = 'source-in';

    // Draw image onto mask
    var m = item.matrix;
    context.transform(m.a, m.b, m.c, m.d, m.tx, m.ty);
    var canvas = item.canvas;
    if (item.data && item.data.expanded) {
        canvas = item.data.expanded.canvas;
    }
    context.transform(1, 0, 0, 1, -canvas.width / 2, -canvas.height / 2);
    context.drawImage(canvas, 0, 0);

    // Draw temp canvas onto raster layer
    destination.drawImage(tmpCanvas, new _paper2.default.Point());
};

/**
 * Given a raster item, take its transform matrix and apply it to its canvas. Try to avoid
 * introducing anti-aliasing.
 * @param {paper.Raster} selection raster to resolve transform of
 * @param {paper.Raster} bitmap raster to draw selection to
 */
var commitSelectionToBitmap = function commitSelectionToBitmap(selection, bitmap) {
    if (!selection.matrix.isInvertible()) {
        return;
    }

    maybeApplyScaleToCanvas_(selection);
    commitArbitraryTransformation_(selection, bitmap);
};

/**
 * Converts a Paper.js color style (an item's fillColor or strokeColor) into a canvas-applicable color style.
 * Note that a "color style" as applied to an item is different from a plain paper.Color or paper.Gradient.
 * For instance, a gradient "color style" has origin and destination points whereas an unattached paper.Gradient
 * does not.
 * @param {paper.Color} color The color to convert to a canvas color/gradient
 * @param {CanvasRenderingContext2D} context The rendering context on which the style will be used
 * @returns {string|CanvasGradient} The canvas fill/stroke style.
 */
var _paperColorToCanvasStyle = function _paperColorToCanvasStyle(color, context) {
    if (!color) return null;
    if (color.type === 'gradient') {
        var canvasGradient = void 0;
        var origin = color.origin,
            destination = color.destination;

        if (color.gradient.radial) {
            // Adapted from:
            // https://github.com/paperjs/paper.js/blob/b081fd72c72cd61331313c3961edb48f3dfaffbd/src/style/Color.js#L926-L935
            var highlight = color.highlight;

            var start = highlight || origin;
            var radius = destination.getDistance(origin);
            if (highlight) {
                var vector = highlight.subtract(origin);
                if (vector.getLength() > radius) {
                    // Paper ¯\_(ツ)_/¯
                    highlight = origin.add(vector.normalize(radius - 0.1));
                }
            }
            canvasGradient = context.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius);
        } else {
            canvasGradient = context.createLinearGradient(origin.x, origin.y, destination.x, destination.y);
        }

        var stops = color.gradient.stops;
        // Adapted from:
        // https://github.com/paperjs/paper.js/blob/b081fd72c72cd61331313c3961edb48f3dfaffbd/src/style/Color.js#L940-L950

        for (var i = 0, len = stops.length; i < len; i++) {
            var stop = stops[i];
            var offset = stop.offset;
            canvasGradient.addColorStop(offset || i / (len - 1), stop.color.toCSS());
        }
        return canvasGradient;
    }
    return color.toCSS();
};

/**
 * @param {paper.Shape.Ellipse} oval Vector oval to convert
 * @param {paper.Raster} bitmap raster to draw selection
 * @return {bool} true if the oval was drawn
 */
var commitOvalToBitmap = function commitOvalToBitmap(oval, bitmap) {
    var radiusX = Math.abs(oval.size.width / 2);
    var radiusY = Math.abs(oval.size.height / 2);
    var context = bitmap.getContext('2d');
    var filled = oval.strokeWidth === 0;

    var canvasColor = _paperColorToCanvasStyle(filled ? oval.fillColor : oval.strokeColor, context);
    // If the color is null (e.g. fully transparent/"no fill"), don't bother drawing anything
    if (!canvasColor) return;

    context.fillStyle = canvasColor;

    var drew = drawEllipse({
        position: oval.position,
        radiusX: radiusX,
        radiusY: radiusY,
        matrix: oval.matrix,
        isFilled: filled,
        thickness: oval.strokeWidth / _paper2.default.view.zoom
    }, context);

    return drew;
};

/**
 * @param {paper.Rectangle} rect Vector rectangle to convert
 * @param {paper.Raster} bitmap raster to draw selection to
 */
var commitRectToBitmap = function commitRectToBitmap(rect, bitmap) {
    var tmpCanvas = (0, _layer.createCanvas)();
    var context = tmpCanvas.getContext('2d');
    var filled = rect.strokeWidth === 0;

    var canvasColor = _paperColorToCanvasStyle(filled ? rect.fillColor : rect.strokeColor, context);
    // If the color is null (e.g. fully transparent/"no fill"), don't bother drawing anything
    if (!canvasColor) return;

    context.fillStyle = canvasColor;

    if (filled) {
        fillRect(rect, context);
    } else {
        outlineRect(rect, rect.strokeWidth / _paper2.default.view.zoom, context);
    }
    bitmap.drawImage(tmpCanvas, new _paper2.default.Point());
};

var selectAllBitmap = function selectAllBitmap(clearSelectedItems) {
    (0, _selection.clearSelection)(clearSelectedItems);

    // Copy trimmed raster to active layer. If the raster layer was empty, nothing is selected.
    var trimmedRaster = getTrimmedRaster(true /* shouldInsert */);
    if (trimmedRaster) {
        trimmedRaster.selected = true;
    }

    // Clear raster layer
    (0, _layer.clearRaster)();
};

exports.commitSelectionToBitmap = commitSelectionToBitmap;
exports.commitOvalToBitmap = commitOvalToBitmap;
exports.commitRectToBitmap = commitRectToBitmap;
exports.convertToBitmap = convertToBitmap;
exports.convertToVector = convertToVector;
exports.fillRect = fillRect;
exports.outlineRect = outlineRect;
exports.floodFill = floodFill;
exports.floodFillAll = floodFillAll;
exports.getBrushMark = getBrushMark;
exports.getHitBounds = getHitBounds;
exports.getTrimmedRaster = getTrimmedRaster;
exports.drawEllipse = drawEllipse;
exports.forEachLinePoint = forEachLinePoint;
exports.flipBitmapHorizontal = flipBitmapHorizontal;
exports.flipBitmapVertical = flipBitmapVertical;
exports.scaleBitmap = scaleBitmap;
exports.selectAllBitmap = selectAllBitmap;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.zoomToFit = exports.zoomOnFixedPoint = exports.zoomOnSelection = exports.resizeCrosshair = exports.getWorkspaceBounds = exports.setWorkspaceBounds = exports.resetZoom = exports.pan = exports.getActionBounds = exports.clampViewBounds = exports.MAX_WORKSPACE_BOUNDS = exports.SVG_ART_BOARD_HEIGHT = exports.SVG_ART_BOARD_WIDTH = exports.OUTERMOST_ZOOM_LEVEL = exports.CENTER = exports.ART_BOARD_WIDTH = exports.ART_BOARD_HEIGHT = exports.ART_BOARD_BOUNDS = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _layer = __webpack_require__(12);

var _selection = __webpack_require__(3);

var _bitmap = __webpack_require__(21);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Vectors are imported and exported at SVG_ART_BOARD size.
// Once they are imported however, both SVGs and bitmaps are on
// canvases of ART_BOARD size.
// (This is for backwards compatibility, to handle both assets
// designed for 480 x 360, and bitmap resolution 2 bitmaps)
var SVG_ART_BOARD_WIDTH = 480;
var SVG_ART_BOARD_HEIGHT = 360;
var ART_BOARD_WIDTH = SVG_ART_BOARD_WIDTH * 2;
var ART_BOARD_HEIGHT = SVG_ART_BOARD_HEIGHT * 2;
var CENTER = new _paper2.default.Point(ART_BOARD_WIDTH / 2, ART_BOARD_HEIGHT / 2);
var PADDING_PERCENT = 25; // Padding as a percent of the max of width/height of the sprite
var BUFFER = 50; // Number of pixels of allowance around objects at the edges of the workspace
var MIN_RATIO = .125; // Zoom in to at least 1/8 of the screen. This way you don't end up incredibly
//                         zoomed in for tiny costumes.
var OUTERMOST_ZOOM_LEVEL = 0.333;
var ART_BOARD_BOUNDS = new _paper2.default.Rectangle(0, 0, ART_BOARD_WIDTH, ART_BOARD_HEIGHT);
var MAX_WORKSPACE_BOUNDS = new _paper2.default.Rectangle(-ART_BOARD_WIDTH / 4, -ART_BOARD_HEIGHT / 4, ART_BOARD_WIDTH * 1.5, ART_BOARD_HEIGHT * 1.5);

var _workspaceBounds = ART_BOARD_BOUNDS;

var getWorkspaceBounds = function getWorkspaceBounds() {
    return _workspaceBounds;
};

/**
* The workspace bounds define the areas that the scroll bars can access.
* They include at minimum the artboard, and extend to a bit beyond the
* farthest item off tne edge in any given direction (so items can't be
* "lost" off the edge)
*
* @param {boolean} clipEmpty Clip empty space from bounds, even if it
* means discontinuously jumping the viewport. This should probably be
* false unless the viewport is going to move discontinuously anyway
* (such as in a zoom button click)
*/
var setWorkspaceBounds = function setWorkspaceBounds(clipEmpty) {
    var items = (0, _selection.getAllRootItems)();
    // Include the artboard and what's visible in the viewport
    var bounds = ART_BOARD_BOUNDS;
    if (!clipEmpty) {
        bounds = bounds.unite(_paper2.default.view.bounds);
    }
    // Include everything the user has drawn and a buffer around it
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            bounds = bounds.unite(item.bounds.expand(BUFFER));
        }
        // Limit to max workspace bounds
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    bounds = bounds.intersect(MAX_WORKSPACE_BOUNDS.expand(BUFFER));
    var top = bounds.top;
    var left = bounds.left;
    var bottom = bounds.bottom;
    var right = bounds.right;

    // Center in view if viewport is larger than workspace
    var hDiff = 0;
    var vDiff = 0;
    if (bounds.width < _paper2.default.view.bounds.width) {
        hDiff = (_paper2.default.view.bounds.width - bounds.width) / 2;
        left -= hDiff;
        right += hDiff;
    }
    if (bounds.height < _paper2.default.view.bounds.height) {
        vDiff = (_paper2.default.view.bounds.height - bounds.height) / 2;
        top -= vDiff;
        bottom += vDiff;
    }

    _workspaceBounds = new _paper2.default.Rectangle(left, top, right - left, bottom - top);
};

var clampViewBounds = function clampViewBounds() {
    var _paper$project$view$b = _paper2.default.project.view.bounds,
        left = _paper$project$view$b.left,
        right = _paper$project$view$b.right,
        top = _paper$project$view$b.top,
        bottom = _paper$project$view$b.bottom;

    if (left < _workspaceBounds.left) {
        _paper2.default.project.view.scrollBy(new _paper2.default.Point(_workspaceBounds.left - left, 0));
    }
    if (top < _workspaceBounds.top) {
        _paper2.default.project.view.scrollBy(new _paper2.default.Point(0, _workspaceBounds.top - top));
    }
    if (bottom > _workspaceBounds.bottom) {
        _paper2.default.project.view.scrollBy(new _paper2.default.Point(0, _workspaceBounds.bottom - bottom));
    }
    if (right > _workspaceBounds.right) {
        _paper2.default.project.view.scrollBy(new _paper2.default.Point(_workspaceBounds.right - right, 0));
    }
    setWorkspaceBounds();
};

var resizeCrosshair = function resizeCrosshair() {
    if ((0, _layer.getDragCrosshairLayer)() && (0, _layer.getDragCrosshairLayer)().dragCrosshair) {
        (0, _layer.getDragCrosshairLayer)().dragCrosshair.scale(_layer.CROSSHAIR_SIZE / (0, _layer.getDragCrosshairLayer)().dragCrosshair.bounds.width / _paper2.default.view.zoom);
    }
    if ((0, _layer.getBackgroundGuideLayer)() && (0, _layer.getBackgroundGuideLayer)().dragCrosshair) {
        (0, _layer.getBackgroundGuideLayer)().dragCrosshair.scale(_layer.CROSSHAIR_SIZE / (0, _layer.getBackgroundGuideLayer)().dragCrosshair.bounds.width / _paper2.default.view.zoom);
    }
};

// Zoom keeping a project-space point fixed.
// This article was helpful http://matthiasberth.com/tech/stable-zoom-and-pan-in-paperjs
var zoomOnFixedPoint = function zoomOnFixedPoint(deltaZoom, fixedPoint) {
    var view = _paper2.default.view;
    var preZoomCenter = view.center;
    var newZoom = Math.max(OUTERMOST_ZOOM_LEVEL, view.zoom + deltaZoom);
    var scaling = view.zoom / newZoom;
    var preZoomOffset = fixedPoint.subtract(preZoomCenter);
    var postZoomOffset = fixedPoint.subtract(preZoomOffset.multiply(scaling)).subtract(preZoomCenter);
    view.zoom = newZoom;
    view.translate(postZoomOffset.multiply(-1));

    setWorkspaceBounds(true /* clipEmpty */);
    clampViewBounds();
    resizeCrosshair();
};

// Zoom keeping the selection center (if any) fixed.
var zoomOnSelection = function zoomOnSelection(deltaZoom) {
    var fixedPoint = void 0;
    var items = (0, _selection.getSelectedRootItems)();
    if (items.length > 0) {
        var rect = null;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var item = _step2.value;

                if (rect) {
                    rect = rect.unite(item.bounds);
                } else {
                    rect = item.bounds;
                }
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        fixedPoint = rect.center;
    } else {
        fixedPoint = _paper2.default.project.view.center;
    }
    zoomOnFixedPoint(deltaZoom, fixedPoint);
};

var resetZoom = function resetZoom() {
    _paper2.default.project.view.zoom = .5;
    setWorkspaceBounds(true /* clipEmpty */);
    resizeCrosshair();
    clampViewBounds();
};

var pan = function pan(dx, dy) {
    _paper2.default.project.view.scrollBy(new _paper2.default.Point(dx, dy));
    clampViewBounds();
};

/**
 * Mouse actions are clamped to action bounds
 * @param {boolean} isBitmap True if the editor is in bitmap mode, false if it is in vector mode
 * @returns {paper.Rectangle} the bounds within which mouse events should work in the paint editor
 */
var getActionBounds = function getActionBounds(isBitmap) {
    if (isBitmap) {
        return ART_BOARD_BOUNDS;
    }
    return _paper2.default.view.bounds.unite(ART_BOARD_BOUNDS).intersect(MAX_WORKSPACE_BOUNDS);
};

var zoomToFit = function zoomToFit(isBitmap) {
    resetZoom();
    var bounds = void 0;
    if (isBitmap) {
        bounds = (0, _bitmap.getHitBounds)((0, _layer.getRaster)()).expand(BUFFER);
    } else {
        var items = (0, _selection.getAllRootItems)();
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var item = _step3.value;

                if (bounds) {
                    bounds = bounds.unite(item.bounds);
                } else {
                    bounds = item.bounds;
                }
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }
    }
    if (bounds && bounds.width && bounds.height) {
        var canvas = _paper2.default.view.element;
        // Ratio of (sprite length plus padding on all sides) to viewport length.
        var ratio = _paper2.default.view.zoom * Math.max(bounds.width * (1 + 2 * PADDING_PERCENT / 100) / canvas.clientWidth, bounds.height * (1 + 2 * PADDING_PERCENT / 100) / canvas.clientHeight);
        // Clamp ratio
        ratio = Math.max(Math.min(1, ratio), MIN_RATIO);
        if (ratio < 1) {
            _paper2.default.view.center = bounds.center;
            _paper2.default.view.zoom = _paper2.default.view.zoom / ratio;
            resizeCrosshair();
            clampViewBounds();
        }
    } else {
        _log2.default.warn('No bounds!');
    }
};

exports.ART_BOARD_BOUNDS = ART_BOARD_BOUNDS;
exports.ART_BOARD_HEIGHT = ART_BOARD_HEIGHT;
exports.ART_BOARD_WIDTH = ART_BOARD_WIDTH;
exports.CENTER = CENTER;
exports.OUTERMOST_ZOOM_LEVEL = OUTERMOST_ZOOM_LEVEL;
exports.SVG_ART_BOARD_WIDTH = SVG_ART_BOARD_WIDTH;
exports.SVG_ART_BOARD_HEIGHT = SVG_ART_BOARD_HEIGHT;
exports.MAX_WORKSPACE_BOUNDS = MAX_WORKSPACE_BOUNDS;
exports.clampViewBounds = clampViewBounds;
exports.getActionBounds = getActionBounds;
exports.pan = pan;
exports.resetZoom = resetZoom;
exports.setWorkspaceBounds = setWorkspaceBounds;
exports.getWorkspaceBounds = getWorkspaceBounds;
exports.resizeCrosshair = resizeCrosshair;
exports.zoomOnSelection = zoomOnSelection;
exports.zoomOnFixedPoint = zoomOnFixedPoint;
exports.zoomToFit = zoomToFit;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("react-intl");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shouldShowUngroup = exports.shouldShowGroup = exports.isGroupChild = exports.isGroup = exports.getItemsGroup = exports.ungroupItems = exports.groupItems = exports.ungroupSelection = exports.groupSelection = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _item = __webpack_require__(26);

var _selection = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isGroup = function isGroup(item) {
    return (0, _item.isGroupItem)(item);
};

/**
 * Groups the given items. Other things are then deselected and the new group is selected.
 * @param {!Array<paper.Item>} items Root level items to group
 * @param {!function} clearSelectedItems Function to clear Redux state's selected items
 * @param {!function} setSelectedItems Function to set Redux state with new list of selected items
 * @param {!function} onUpdateImage Function to let listeners know that SVG has changed.
 * @return {paper.Group} the group if one is created, otherwise false.
 */
var groupItems = function groupItems(items, clearSelectedItems, setSelectedItems, onUpdateImage) {
    if (items.length > 0) {
        var group = new _paper2.default.Group(items);
        (0, _selection.clearSelection)(clearSelectedItems);
        (0, _selection.setItemSelection)(group, true);
        for (var i = 0; i < group.children.length; i++) {
            group.children[i].selected = true;
        }
        setSelectedItems();
        onUpdateImage();
        return group;
    }
    return false;
};

/**
 * Groups the selected items. Other things are then deselected and the new group is selected.
 * @param {!function} clearSelectedItems Function to clear Redux state's selected items
 * @param {!function} setSelectedItems Function to set Redux state with new list of selected items
 * @param {!function} onUpdateImage Function to let listeners know that SVG has changed.
 * @return {paper.Group} the group if one is created, otherwise false.
 */
var groupSelection = function groupSelection(clearSelectedItems, setSelectedItems, onUpdateImage) {
    var items = (0, _selection.getSelectedRootItems)();
    return groupItems(items, clearSelectedItems, setSelectedItems, onUpdateImage);
};

var _ungroupLoop = function _ungroupLoop(group, recursive, setSelectedItems) {
    // Can't ungroup items that are not groups
    if (!group || !group.children || !isGroup(group)) return;

    group.applyMatrix = true;
    // iterate over group children recursively
    for (var i = 0; i < group.children.length; i++) {
        var groupChild = group.children[i];
        if (groupChild instanceof _paper2.default.Group && groupChild.hasChildren()) {
            // recursion (groups can contain groups, ie. from SVG import)
            if (recursive) {
                _ungroupLoop(groupChild, recursive, setSelectedItems);
                continue;
            }
            if (groupChild.children.length === 1) {
                groupChild = groupChild.reduce();
            }
        }
        groupChild.applyMatrix = true;
        // move items from the group to the activeLayer (ungrouping)
        groupChild.insertBelow(group);
        if (setSelectedItems) {
            groupChild.selected = true;
        }
        i--;
    }
};

/**
 * Ungroups the given items. The new group is selected only if setSelectedItems is passed in.
 * onUpdateImage is called to notify listeners of a change on the SVG only if onUpdateImage is passed in.
 * The reason these arguments are optional on ungroupItems is because ungroupItems is used for parts of
 * SVG import, which shouldn't change the selection or undo state.
 *
 * @param {!Array<paper.Item>} items Items to ungroup if they are groups
 * @param {?function} setSelectedItems Function to set Redux state with new list of selected items
 * @param {?function} onUpdateImage Function to let listeners know that SVG has changed.
 */
var ungroupItems = function ungroupItems(items, setSelectedItems, onUpdateImage) {
    if (items.length === 0) {
        return;
    }
    var emptyGroups = [];
    for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (isGroup(item) && !item.data.isPGTextItem) {
            _ungroupLoop(item, false /* recursive */, setSelectedItems);

            if (!item.hasChildren()) {
                emptyGroups.push(item);
            }
        } else if (setSelectedItems) {
            item.selected = true;
        }
    }
    if (setSelectedItems) {
        setSelectedItems();
    }
    // remove all empty groups after ungrouping
    for (var j = 0; j < emptyGroups.length; j++) {
        emptyGroups[j].remove();
    }
    // @todo: enable/disable grouping icons
    if (onUpdateImage) {
        onUpdateImage();
    }
};

/**
 * Ungroups the selected items. Other items are deselected and the ungrouped items are selected.
 *
 * @param {!function} clearSelectedItems Function to clear Redux state's selected items
 * @param {!function} setSelectedItems Function to set Redux state with new list of selected items
 * @param {!function} onUpdateImage Function to let listeners know that SVG has changed.
 */
var ungroupSelection = function ungroupSelection(clearSelectedItems, setSelectedItems, onUpdateImage) {
    var items = (0, _selection.getSelectedRootItems)();
    (0, _selection.clearSelection)(clearSelectedItems);
    ungroupItems(items, setSelectedItems, onUpdateImage);
};

var getItemsGroup = function getItemsGroup(item) {
    var itemParent = item.parent;

    if (isGroup(itemParent)) {
        return itemParent;
    }
    return null;
};

var isGroupChild = function isGroupChild(item) {
    var rootItem = (0, _item.getRootItem)(item);
    return isGroup(rootItem);
};

var shouldShowGroup = function shouldShowGroup() {
    var items = (0, _selection.getSelectedRootItems)();
    return items.length > 1;
};

var shouldShowUngroup = function shouldShowUngroup() {
    var items = (0, _selection.getSelectedRootItems)();
    for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (isGroup(item) && !item.data.isPGTextItem && item.children && item.children.length > 0) {
            return true;
        }
    }
    return false;
};

exports.groupSelection = groupSelection;
exports.ungroupSelection = ungroupSelection;
exports.groupItems = groupItems;
exports.ungroupItems = ungroupItems;
exports.getItemsGroup = getItemsGroup;
exports.isGroup = isGroup;
exports.isGroupChild = isGroupChild;
exports.shouldShowGroup = shouldShowGroup;
exports.shouldShowUngroup = shouldShowUngroup;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setCursor = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _cursors = __webpack_require__(66);

var _cursors2 = _interopRequireDefault(_cursors);

var _eyeDropper = __webpack_require__(39);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_CURSOR = 'scratch-paint/cursor/CHANGE_CURSOR';
var initialState = _cursors2.default.DEFAULT;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_CURSOR:
            if (typeof action.cursorString === 'undefined') {
                _log2.default.warn('Cursor should not be set to undefined. Use \'default\'.');
                return state;
            } else if (!Object.values(_cursors2.default).includes(action.cursorString)) {
                _log2.default.warn('Cursor should be a valid cursor string. Got: ' + action.cursorString);
            }
            return action.cursorString;
        case _eyeDropper.ACTIVATE_EYE_DROPPER:
            return _cursors2.default.NONE;
        case _eyeDropper.DEACTIVATE_EYE_DROPPER:
            return _cursors2.default.DEFAULT;
        default:
            return state;
    }
};

// Action creators ==================================
/**
 * Set the mouse cursor state to the given string
 * @param {string} cursorString The CSS cursor string.
 * @return {object} Redux action to change the cursor.
 */
var setCursor = function setCursor(cursorString) {
    return {
        type: CHANGE_CURSOR,
        cursorString: cursorString
    };
};

exports.default = reducer;
exports.setCursor = setCursor;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getRootItem = exports.setPositionInView = exports.getPositionInView = exports.setPivot = exports.isPGTextItem = exports.isPointTextItem = exports.isGroupItem = exports.isCompoundPathItem = exports.isPathItem = exports.isBoundsItem = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getRootItem = function getRootItem(item) {
    if (item.parent.className === 'Layer') {
        return item;
    }
    return getRootItem(item.parent);
};

var isBoundsItem = function isBoundsItem(item) {
    if (item.className === 'PointText' || item.className === 'Shape' || item.className === 'PlacedSymbol' || item.className === 'Raster') {
        return true;
    }
    return false;
};

var isPathItem = function isPathItem(item) {
    return item.className === 'Path';
};

var isCompoundPathItem = function isCompoundPathItem(item) {
    return item.className === 'CompoundPath';
};

var isGroupItem = function isGroupItem(item) {
    return item && item.className && item.className === 'Group';
};

var isPointTextItem = function isPointTextItem(item) {
    return item.className === 'PointText';
};

var isPGTextItem = function isPGTextItem(item) {
    return getRootItem(item).data.isPGTextItem;
};

var setPivot = function setPivot(item, point) {
    if (isBoundsItem(item)) {
        item.pivot = item.globalToLocal(point);
    } else {
        item.pivot = point;
    }
};

var getPositionInView = function getPositionInView(item) {
    var itemPos = new _paper2.default.Point();
    itemPos.x = item.position.x - _paper2.default.view.bounds.x;
    itemPos.y = item.position.y - _paper2.default.view.bounds.y;
    return itemPos;
};

var setPositionInView = function setPositionInView(item, pos) {
    item.position.x = _paper2.default.view.bounds.x + pos.x;
    item.position.y = _paper2.default.view.bounds.y + pos.y;
};

exports.isBoundsItem = isBoundsItem;
exports.isPathItem = isPathItem;
exports.isCompoundPathItem = isCompoundPathItem;
exports.isGroupItem = isGroupItem;
exports.isPointTextItem = isPointTextItem;
exports.isPGTextItem = isPGTextItem;
exports.setPivot = setPivot;
exports.getPositionInView = getPositionInView;
exports.setPositionInView = setPositionInView;
exports.getRootItem = getRootItem;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setDefaultGuideStyle = exports.getGuideColor = exports.removeHitPoint = exports.drawHitPoint = exports.removeBoundsPath = exports.removeBoundsHandles = exports.removeAllGuides = exports.rectSelect = exports.hoverBounds = exports.hoverItem = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _layer = __webpack_require__(12);

var _selection = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GUIDE_BLUE = '#009dec';
var GUIDE_GREY = '#aaaaaa';

var setDefaultGuideStyle = function setDefaultGuideStyle(item) {
    item.strokeWidth = 1 / _paper2.default.view.zoom;
    item.opacity = 1;
    item.blendMode = 'normal';
    item.guide = true;
};

var hoverItem = function hoverItem(item) {
    var segments = item.segments;
    var clone = new _paper2.default.Path(segments);
    setDefaultGuideStyle(clone);
    if (item.closed) {
        clone.closed = true;
    }
    clone.parent = (0, _layer.getGuideLayer)();
    clone.position = item.position;
    clone.strokeColor = GUIDE_BLUE;
    clone.fillColor = null;
    clone.data.isHelperItem = true;
    clone.data.origItem = item;
    clone.bringToFront();

    return clone;
};

var hoverBounds = function hoverBounds(item, expandBy) {
    var bounds = item.internalBounds;
    if (expandBy) {
        bounds = bounds.expand(expandBy);
    }
    var rect = new _paper2.default.Path.Rectangle(bounds);
    rect.matrix = item.matrix;
    setDefaultGuideStyle(rect);
    rect.parent = (0, _layer.getGuideLayer)();
    rect.strokeColor = GUIDE_BLUE;
    rect.fillColor = null;
    rect.data.isHelperItem = true;
    rect.data.origItem = item;
    rect.bringToFront();

    return rect;
};

var rectSelect = function rectSelect(event, color) {
    var half = new _paper2.default.Point(0.5 / _paper2.default.view.zoom, 0.5 / _paper2.default.view.zoom);
    var start = event.downPoint.add(half);
    var end = event.point.add(half);
    var rect = new _paper2.default.Path.Rectangle(start, end);
    var zoom = 1.0 / _paper2.default.view.zoom;
    setDefaultGuideStyle(rect);
    if (!color) color = GUIDE_GREY;
    rect.parent = (0, _layer.getGuideLayer)();
    rect.strokeColor = color;
    rect.data.isRectSelect = true;
    rect.data.isHelperItem = true;
    rect.dashArray = [3.0 * zoom, 3.0 * zoom];
    return rect;
};

var getGuideColor = function getGuideColor() {
    return GUIDE_BLUE;
};

var _removePaperItemsByDataTags = function _removePaperItemsByDataTags(tags) {
    var allItems = (0, _selection.getAllRootItems)(true);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = allItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = tags[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var tag = _step2.value;

                    if (item.data && item.data[tag]) {
                        item.remove();
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
};

var _removePaperItemsByTags = function _removePaperItemsByTags(tags) {
    var allItems = (0, _selection.getAllRootItems)(true);
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = allItems[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var item = _step3.value;
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = tags[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var tag = _step4.value;

                    if (item[tag]) {
                        item.remove();
                    }
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }
};

var removeBoundsPath = function removeBoundsPath() {
    _removePaperItemsByDataTags(['isSelectionBound', 'isRotHandle', 'isScaleHandle']);
};

var removeBoundsHandles = function removeBoundsHandles() {
    _removePaperItemsByDataTags(['isRotHandle', 'isScaleHandle']);
};

var removeAllGuides = function removeAllGuides() {
    _removePaperItemsByTags(['guide']);
};

var removeHitPoint = function removeHitPoint() {
    _removePaperItemsByDataTags(['isHitPoint']);
};

var drawHitPoint = function drawHitPoint(point) {
    removeHitPoint();
    if (point) {
        var hitPoint = _paper2.default.Path.Circle(point, 4 / _paper2.default.view.zoom /* radius */);
        hitPoint.strokeWidth = 1 / _paper2.default.view.zoom;
        hitPoint.strokeColor = GUIDE_BLUE;
        hitPoint.fillColor = new _paper2.default.Color(1, 1, 1, 0.5);
        hitPoint.parent = (0, _layer.getGuideLayer)();
        hitPoint.data.isHitPoint = true;
        hitPoint.data.isHelperItem = true;
    }
};

exports.hoverItem = hoverItem;
exports.hoverBounds = hoverBounds;
exports.rectSelect = rectSelect;
exports.removeAllGuides = removeAllGuides;
exports.removeBoundsHandles = removeBoundsHandles;
exports.removeBoundsPath = removeBoundsPath;
exports.drawHitPoint = drawHitPoint;
exports.removeHitPoint = removeHitPoint;
exports.getGuideColor = getGuideColor;
exports.setDefaultGuideStyle = setDefaultGuideStyle;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _propTypes = __webpack_require__(0);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _propTypes.PropTypes.shape({
    primary: _propTypes.PropTypes.string,
    secondary: _propTypes.PropTypes.string,
    gradientType: _propTypes.PropTypes.oneOf(Object.keys(_gradientTypes2.default)).isRequired
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _keymirror = __webpack_require__(34);

var _keymirror2 = _interopRequireDefault(_keymirror);

var _selection = __webpack_require__(3);

var _guides = __webpack_require__(27);

var _layer = __webpack_require__(12);

var _cursors = __webpack_require__(66);

var _cursors2 = _interopRequireDefault(_cursors);

var _scaleTool = __webpack_require__(117);

var _scaleTool2 = _interopRequireDefault(_scaleTool);

var _rotateTool = __webpack_require__(118);

var _rotateTool2 = _interopRequireDefault(_rotateTool);

var _moveTool = __webpack_require__(67);

var _moveTool2 = _interopRequireDefault(_moveTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SELECTION_ANCHOR_SIZE = 12;
/** SVG for the rotation icon on the bounding box */
var ARROW_PATH = 'M19.28,1.09C19.28.28,19,0,18.2,0c-1.67,0-3.34,0-5,0-.34,0-.88.24-1,.47a1.4,1.4,' + '0,0,0,.36,1.08,15.27,15.27,0,0,0,1.46,1.36A6.4,6.4,0,0,1,6.52,4,5.85,5.85,0,0,1,5.24,3,15.27,15.27,' + '0,0,0,6.7,1.61,1.4,1.4,0,0,0,7.06.54C7,.3,6.44.07,6.1.06c-1.67,0-3.34,0-5,0C.28,0,0,.31,0,1.12c0,1.67,' + '0,3.34,0,5a1.23,1.23,0,0,0,.49,1,1.22,1.22,0,0,0,1-.31A14.38,14.38,0,0,0,2.84,5.26l.73.62a9.45,9.45,' + '0,0,0,7.34,2,9.45,9.45,0,0,0,4.82-2.05l.73-.62a14.38,14.38,0,0,0,1.29,1.51,1.22,1.22,' + '0,0,0,1,.31,1.23,1.23,0,0,0,.49-1C19.31,4.43,19.29,2.76,19.28,1.09Z';
/** Modes of the bounding box tool, which can do many things depending on how it's used. */
var BoundingBoxModes = (0, _keymirror2.default)({
    SCALE: null,
    ROTATE: null,
    MOVE: null
});

/**
 * Tool that handles transforming the selection and drawing a bounding box with handles.
 * On mouse down, the type of function (move, scale, rotate) is determined based on what is clicked
 * (scale handle, rotate handle, the object itself). This determines the mode of the tool, which then
 * delegates actions to the MoveTool, RotateTool or ScaleTool accordingly.
 * @param {!function} onUpdateImage A callback to call when the image visibly changes
 */

var BoundingBoxTool = function () {
    /**
     * @param {Modes} mode Paint editor mode
     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
     * @param {function} setCursor Callback to set the visible mouse cursor
     * @param {!function} onUpdateImage A callback to call when the image visibly changes
     * @param {?function} switchToTextTool A callback to call to switch to the text tool
     */
    function BoundingBoxTool(mode, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage, switchToTextTool) {
        _classCallCheck(this, BoundingBoxTool);

        this.dispatchSetCursor = setCursor;
        this.onUpdateImage = onUpdateImage;
        this.mode = null;
        this.boundsPath = null;
        this.boundsScaleHandles = [];
        this.boundsRotHandles = [];
        this._modeMap = {};
        this._modeMap[BoundingBoxModes.SCALE] = new _scaleTool2.default(mode, onUpdateImage);
        this._modeMap[BoundingBoxModes.ROTATE] = new _rotateTool2.default(onUpdateImage);
        this._modeMap[BoundingBoxModes.MOVE] = new _moveTool2.default(mode, setSelectedItems, clearSelectedItems, onUpdateImage, switchToTextTool);
        this._currentCursor = null;
    }

    /**
     * Should be called if the selection changes to update the bounds of the bounding box.
     * @param {?Array<paper.Item>} selectedItems Array of selected items.
     */


    _createClass(BoundingBoxTool, [{
        key: 'onSelectionChanged',
        value: function onSelectionChanged(selectedItems) {
            if (selectedItems && selectedItems.length) {
                this.setSelectionBounds();
            } else {
                this.removeBoundsPath();
            }
        }

        /**
         * @param {!MouseEvent} event The mouse event
         * @param {boolean} clone Whether to clone on mouse down (e.g. alt key held)
         * @param {boolean} multiselect Whether to multiselect on mouse down (e.g. shift key held)
         * @param {?boolean} doubleClicked True if this is the second click in a short amout of time
         * @param {paper.hitOptions} hitOptions The options with which to detect whether mouse down has hit
         *     anything editable
         * @return {boolean} True if there was a hit, false otherwise
         */

    }, {
        key: 'onMouseDown',
        value: function onMouseDown(event, clone, multiselect, doubleClicked, hitOptions) {
            if (event.event.button > 0) return; // only first mouse button

            var _determineMode2 = this._determineMode(event, multiselect, hitOptions),
                hitResult = _determineMode2.hitResult,
                mode = _determineMode2.mode;

            if (!hitResult) {
                if (!multiselect) {
                    this.removeBoundsPath();
                }
                return false;
            }
            this.mode = mode;

            var hitProperties = {
                hitResult: hitResult,
                clone: clone,
                multiselect: multiselect,
                doubleClicked: doubleClicked
            };
            if (this.mode === BoundingBoxModes.MOVE) {
                this._modeMap[this.mode].onMouseDown(hitProperties);
                this.removeBoundsHandles();
            } else if (this.mode === BoundingBoxModes.SCALE) {
                this._modeMap[this.mode].onMouseDown(hitResult, this.boundsPath, (0, _selection.getSelectedRootItems)());
                this.removeBoundsHandles();
            } else if (this.mode === BoundingBoxModes.ROTATE) {
                this.setCursor(_cursors2.default.GRABBING);
                this._modeMap[this.mode].onMouseDown(hitResult, this.boundsPath, (0, _selection.getSelectedRootItems)());
                // While transforming, don't show bounds
                this.removeBoundsPath();
            }

            return true;
        }
    }, {
        key: 'onMouseMove',
        value: function onMouseMove(event, hitOptions) {
            this._updateCursor(event, hitOptions);
        }
    }, {
        key: '_updateCursor',
        value: function _updateCursor(event, hitOptions) {
            var _determineMode3 = this._determineMode(event, false, hitOptions),
                mode = _determineMode3.mode,
                hitResult = _determineMode3.hitResult;

            if (hitResult) {
                if (mode === BoundingBoxModes.MOVE) {
                    this.setCursor(_cursors2.default.DEFAULT);
                } else if (mode === BoundingBoxModes.ROTATE) {
                    this.setCursor(_cursors2.default.GRAB);
                } else if (mode === BoundingBoxModes.SCALE) {
                    this.setSelectionBounds();
                    if (this._impreciseEqual(hitResult.item.position.x, this.boundsPath.position.x)) {
                        this.setCursor(_cursors2.default.RESIZE_NS);
                    } else if (this._impreciseEqual(hitResult.item.position.y, this.boundsPath.position.y)) {
                        this.setCursor(_cursors2.default.RESIZE_EW);
                    } else if (hitResult.item.position.equals(this.boundsPath.bounds.bottomLeft) || hitResult.item.position.equals(this.boundsPath.bounds.topRight)) {
                        this.setCursor(_cursors2.default.RESIZE_NESW);
                    } else {
                        this.setCursor(_cursors2.default.RESIZE_NWSE);
                    }
                }
            } else {
                this.setCursor(_cursors2.default.DEFAULT);
            }
        }
    }, {
        key: '_impreciseEqual',
        value: function _impreciseEqual(a, b) {
            // This is the same math paper.js uses to check if two numbers are "equal".
            return Math.abs(a - b) < 1e-8;
        }
    }, {
        key: '_determineMode',
        value: function _determineMode(event, multiselect, hitOptions) {
            var hitResults = _paper2.default.project.hitTestAll(event.point, hitOptions);

            var mode = void 0;

            // Prefer scale to trigger over rotate, and scale and rotate to trigger over other hits
            var hitResult = hitResults[0];
            for (var i = 0; i < hitResults.length; i++) {
                if (hitResults[i].item.data && hitResults[i].item.data.isScaleHandle) {
                    hitResult = hitResults[i];
                    mode = BoundingBoxModes.SCALE;
                    break;
                } else if (hitResults[i].item.data && hitResults[i].item.data.isRotHandle) {
                    hitResult = hitResults[i];
                    mode = BoundingBoxModes.ROTATE;
                }
            }
            if (!mode) {
                mode = BoundingBoxModes.MOVE;
            }

            return { mode: mode, hitResult: hitResult };
        }
    }, {
        key: 'onMouseDrag',
        value: function onMouseDrag(event) {
            if (event.event.button > 0 || !this.mode) return; // only first mouse button
            this._modeMap[this.mode].onMouseDrag(event);

            // Set the cursor for moving a sprite once the drag has actually started (i.e. the mouse has been moved while
            // pressed), so that the mouse doesn't "flash" to the grabbing cursor every time a sprite is clicked.
            if (this.mode === BoundingBoxModes.MOVE) {
                this.setCursor(_cursors2.default.GRABBING);
            }
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp(event, hitOptions) {
            if (event.event.button > 0 || !this.mode) return; // only first mouse button
            this._modeMap[this.mode].onMouseUp(event);

            // After transforming, show bounds again
            this.setSelectionBounds();
            this.mode = null;
            this._updateCursor(event, hitOptions);
        }
    }, {
        key: 'setSelectionBounds',
        value: function setSelectionBounds() {
            this.removeBoundsPath();

            var items = (0, _selection.getSelectedRootItems)();
            if (items.length <= 0) return;

            var rect = null;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var item = _step.value;

                    if (item instanceof _paper2.default.Raster && item.loaded === false) {
                        item.onLoad = this.setSelectionBounds.bind(this);
                        return;
                    }

                    if (rect) {
                        rect = rect.unite(item.bounds);
                    } else {
                        rect = item.bounds;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            if (!this.boundsPath) {
                this.boundsPath = new _paper2.default.Group();
                this.boundsRect = _paper2.default.Path.Rectangle(rect);
                this.boundsRect.curves[0].divideAtTime(0.5);
                this.boundsRect.curves[2].divideAtTime(0.5);
                this.boundsRect.curves[4].divideAtTime(0.5);
                this.boundsRect.curves[6].divideAtTime(0.5);
                this.boundsPath.addChild(this.boundsRect);

                var vRect = new _paper2.default.Path.Rectangle({
                    point: [-1, -6],
                    size: [2, 12],
                    radius: 1,
                    insert: false
                });
                var hRect = new _paper2.default.Path.Rectangle({
                    point: [-6, -1],
                    size: [12, 2],
                    radius: 1,
                    insert: false
                });
                var anchorIcon = vRect.unite(hRect);

                this.boundsPath.addChild(anchorIcon);
                this.boundsPath.selectionAnchor = anchorIcon;
                this._modeMap[BoundingBoxModes.MOVE].setBoundsPath(this.boundsPath);
            }
            (0, _layer.setGuideItem)(this.boundsPath);
            this.boundsPath.data.isSelectionBound = true;
            this.boundsPath.data.isHelperItem = true;
            this.boundsPath.fillColor = null;
            this.boundsPath.parent = (0, _layer.getGuideLayer)();
            this.boundsPath.strokeWidth = 1 / _paper2.default.view.zoom;
            this.boundsPath.strokeColor = (0, _guides.getGuideColor)();
            this.boundsPath.selectionAnchor.scale(SELECTION_ANCHOR_SIZE / _paper2.default.view.zoom / this.boundsPath.selectionAnchor.bounds.width);
            this.boundsPath.selectionAnchor.position = rect.center;

            // Make a template to copy
            var boundsScaleCircleShadow = new _paper2.default.Path.Circle({
                center: new _paper2.default.Point(0, 0),
                radius: 5.5 / _paper2.default.view.zoom,
                fillColor: 'black',
                opacity: .12,
                data: {
                    isHelperItem: true,
                    noSelect: true,
                    noHover: true
                }
            });
            var boundsScaleCircle = new _paper2.default.Path.Circle({
                center: new _paper2.default.Point(0, 0),
                radius: 4 / _paper2.default.view.zoom,
                fillColor: (0, _guides.getGuideColor)(),
                data: {
                    isScaleHandle: true,
                    isHelperItem: true,
                    noSelect: true,
                    noHover: true
                }
            });
            var boundsScaleHandle = new _paper2.default.Group([boundsScaleCircleShadow, boundsScaleCircle]);
            boundsScaleHandle.parent = (0, _layer.getGuideLayer)();

            for (var index = 0; index < this.boundsRect.segments.length; index++) {
                var segment = this.boundsRect.segments[index];

                if (index === 7) {
                    var offset = new _paper2.default.Point(0, 20);

                    var arrows = new _paper2.default.Path(ARROW_PATH);
                    arrows.translate(segment.point.add(offset).add(-10.5, -5));

                    var line = new _paper2.default.Path.Rectangle(segment.point.add(offset).subtract(1, 0), segment.point);

                    var rotHandle = arrows.unite(line);
                    line.remove();
                    arrows.remove();
                    rotHandle.scale(1 / _paper2.default.view.zoom, segment.point);
                    rotHandle.data = {
                        offset: offset,
                        isRotHandle: true,
                        isHelperItem: true,
                        noSelect: true,
                        noHover: true
                    };
                    rotHandle.fillColor = (0, _guides.getGuideColor)();
                    rotHandle.parent = (0, _layer.getGuideLayer)();
                    this.boundsRotHandles[index] = rotHandle;
                }

                this.boundsScaleHandles[index] = boundsScaleHandle.clone();
                this.boundsScaleHandles[index].position = segment.point;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = this.boundsScaleHandles[index].children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var child = _step2.value;

                        child.data.index = index;
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                this.boundsScaleHandles[index].data = {
                    index: index,
                    isScaleHandle: true,
                    isHelperItem: true,
                    noSelect: true,
                    noHover: true
                };
            }
            // Remove the template
            boundsScaleHandle.remove();
        }
    }, {
        key: 'removeBoundsPath',
        value: function removeBoundsPath() {
            (0, _guides.removeBoundsPath)();
            this.boundsPath = null;
            this.boundsRect = null;
            this.boundsScaleHandles.length = 0;
            this.boundsRotHandles.length = 0;
        }
    }, {
        key: 'removeBoundsHandles',
        value: function removeBoundsHandles() {
            (0, _guides.removeBoundsHandles)();
            this.boundsScaleHandles.length = 0;
            this.boundsRotHandles.length = 0;
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.removeBoundsPath();
            this.setCursor(_cursors2.default.DEFAULT);
        }
    }, {
        key: 'setCursor',
        value: function setCursor(cursorString) {
            if (this._currentCursor !== cursorString) {
                this.dispatchSetCursor(cursorString);
                this._currentCursor = cursorString;
            }
        }
    }]);

    return BoundingBoxTool;
}();

exports.default = BoundingBoxTool;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _selection = __webpack_require__(3);

var _view = __webpack_require__(22);

var _modes = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NUDGE_MORE_MULTIPLIER = 15;

/**
 * Tool containing handlers for arrow key events for nudging the selection.
 * Note that this tool is built for selection mode, not reshape mode.
 */

var NudgeTool = function () {
    /**
     * @param {Mode} mode Paint editor mode
     * @param {function} boundingBoxTool to control the bounding box
     * @param {!function} onUpdateImage A callback to call when the image visibly changes
     */
    function NudgeTool(mode, boundingBoxTool, onUpdateImage) {
        _classCallCheck(this, NudgeTool);

        this.boundingBoxTool = boundingBoxTool;
        this.onUpdateImage = onUpdateImage;
        this.boundingBoxTool.isBitmap = mode in _modes.BitmapModes;
    }

    _createClass(NudgeTool, [{
        key: 'onKeyDown',
        value: function onKeyDown(event) {
            if (event.event.target instanceof HTMLInputElement) {
                // Ignore nudge if a text input field is focused
                return;
            }

            var nudgeAmount = 1 / _paper2.default.view.zoom;
            if (event.modifiers.shift) nudgeAmount *= NUDGE_MORE_MULTIPLIER;

            var selected = (0, _selection.getSelectedRootItems)();
            if (selected.length === 0) return;

            // Get bounds. Don't let item bounds go out of bounds.
            var rect = void 0;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = selected[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var item = _step.value;

                    if (rect) {
                        rect = rect.unite(item.bounds);
                    } else {
                        rect = item.bounds;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            var bounds = (0, _view.getActionBounds)(this.boundingBoxTool.isBitmap);
            var bottom = bounds.bottom - rect.top - 1;
            var top = bounds.top - rect.bottom + 1;
            var left = bounds.left - rect.right + 1;
            var right = bounds.right - rect.left - 1;

            var translation = void 0;
            if (event.key === 'up') {
                translation = new _paper2.default.Point(0, Math.min(bottom, Math.max(-nudgeAmount, top)));
            } else if (event.key === 'down') {
                translation = new _paper2.default.Point(0, Math.max(top, Math.min(nudgeAmount, bottom)));
            } else if (event.key === 'left') {
                translation = new _paper2.default.Point(Math.min(right, Math.max(-nudgeAmount, left)), 0);
            } else if (event.key === 'right') {
                translation = new _paper2.default.Point(Math.max(left, Math.min(nudgeAmount, right)), 0);
            }

            if (translation) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = selected[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var _item = _step2.value;

                        _item.translate(translation);
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                this.boundingBoxTool.setSelectionBounds();
                event.preventDefault();
            }
        }
    }, {
        key: 'onKeyUp',
        value: function onKeyUp(event) {
            var selected = (0, _selection.getSelectedRootItems)();
            if (selected.length === 0) return;

            if (event.key === 'up' || event.key === 'down' || event.key === 'left' || event.key === 'right') {
                this.onUpdateImage();
            }
        }
    }]);

    return NudgeTool;
}();

exports.default = NudgeTool;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CHANGE_STROKE_GRADIENT_TYPE = exports.DEFAULT_COLOR = exports.clearStrokeGradient = exports.changeStrokeGradientType = exports.changeStrokeColor2 = exports.changeStrokeColor = exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _makeColorStyleReducer = __webpack_require__(62);

var _makeColorStyleReducer2 = _interopRequireDefault(_makeColorStyleReducer);

var _strokeWidth = __webpack_require__(32);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_STROKE_COLOR = 'scratch-paint/stroke-style/CHANGE_STROKE_COLOR';
var CHANGE_STROKE_COLOR_2 = 'scratch-paint/stroke-style/CHANGE_STROKE_COLOR_2';
var CHANGE_STROKE_GRADIENT_TYPE = 'scratch-paint/stroke-style/CHANGE_STROKE_GRADIENT_TYPE';
var CLEAR_STROKE_GRADIENT = 'scratch-paint/stroke-style/CLEAR_STROKE_GRADIENT';
var DEFAULT_COLOR = '#000000';

var reducer = (0, _makeColorStyleReducer2.default)({
    changePrimaryColorAction: CHANGE_STROKE_COLOR,
    changeSecondaryColorAction: CHANGE_STROKE_COLOR_2,
    changeGradientTypeAction: CHANGE_STROKE_GRADIENT_TYPE,
    clearGradientAction: CLEAR_STROKE_GRADIENT,
    defaultColor: DEFAULT_COLOR,
    selectionPrimaryColorKey: 'strokeColor',
    selectionSecondaryColorKey: 'strokeColor2',
    selectionGradientTypeKey: 'strokeGradientType'
});

// This is mostly the same as the generated reducer, but with one piece of extra logic to set the color to null when the
// stroke width is set to 0.
// https://redux.js.org/recipes/structuring-reducers/reusing-reducer-logic
var strokeReducer = function strokeReducer(state, action) {
    if (action.type === _strokeWidth.CHANGE_STROKE_WIDTH && Math.max(action.strokeWidth, 0) === 0) {
        // TODO: this preserves the gradient type when you change the stroke width to 0.
        // Alternatively, we could set gradientType to SOLID instead of setting secondary to null, but since
        // the stroke width is automatically set to 0 as soon as a "null" color is detected (including a gradient for
        // which both colors are null), that would change the gradient type back to solid if you selected null for both
        // gradient colors.
        return _extends({}, state, { primary: null, secondary: null });
    }

    return reducer(state, action);
};

// Action creators ==================================
var changeStrokeColor = function changeStrokeColor(strokeColor) {
    return {
        type: CHANGE_STROKE_COLOR,
        color: strokeColor
    };
};

var changeStrokeColor2 = function changeStrokeColor2(strokeColor) {
    return {
        type: CHANGE_STROKE_COLOR_2,
        color: strokeColor
    };
};

var changeStrokeGradientType = function changeStrokeGradientType(gradientType) {
    return {
        type: CHANGE_STROKE_GRADIENT_TYPE,
        gradientType: gradientType
    };
};

var clearStrokeGradient = function clearStrokeGradient() {
    return {
        type: CLEAR_STROKE_GRADIENT
    };
};

exports.default = strokeReducer;
exports.changeStrokeColor = changeStrokeColor;
exports.changeStrokeColor2 = changeStrokeColor2;
exports.changeStrokeGradientType = changeStrokeGradientType;
exports.clearStrokeGradient = clearStrokeGradient;
exports.DEFAULT_COLOR = DEFAULT_COLOR;
exports.CHANGE_STROKE_GRADIENT_TYPE = CHANGE_STROKE_GRADIENT_TYPE;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MAX_STROKE_WIDTH = exports.CHANGE_STROKE_WIDTH = exports.changeStrokeWidth = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _selectedItems = __webpack_require__(7);

var _stylePath = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_STROKE_WIDTH = 'scratch-paint/stroke-width/CHANGE_STROKE_WIDTH';
var MAX_STROKE_WIDTH = 100;
var initialState = 4;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_STROKE_WIDTH:
            if (isNaN(action.strokeWidth)) {
                _log2.default.warn('Invalid brush size: ' + action.strokeWidth);
                return state;
            }
            return Math.min(MAX_STROKE_WIDTH, Math.max(0, action.strokeWidth));
        case _selectedItems.CHANGE_SELECTED_ITEMS:
            // Don't change state if no selection
            if (!action.selectedItems || !action.selectedItems.length) {
                return state;
            }
            // Bitmap mode doesn't have stroke width
            if (action.bitmapMode) {
                return state;
            }
            return (0, _stylePath.getColorsFromSelection)(action.selectedItems, action.bitmapMode).strokeWidth;
        default:
            return state;
    }
};

// Action creators ==================================
var changeStrokeWidth = function changeStrokeWidth(strokeWidth) {
    return {
        type: CHANGE_STROKE_WIDTH,
        strokeWidth: strokeWidth
    };
};

exports.default = reducer;
exports.changeStrokeWidth = changeStrokeWidth;
exports.CHANGE_STROKE_WIDTH = CHANGE_STROKE_WIDTH;
exports.MAX_STROKE_WIDTH = MAX_STROKE_WIDTH;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _inputGroup = __webpack_require__(165);

var _inputGroup2 = _interopRequireDefault(_inputGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var InputGroup = function InputGroup(props) {
    return _react2.default.createElement(
        'div',
        {
            className: (0, _classnames2.default)(props.className, _inputGroup2.default.inputGroup, _defineProperty({}, _inputGroup2.default.disabled, props.disabled)),
            dir: props.rtl ? 'rtl' : ''
        },
        props.children
    );
};

InputGroup.propTypes = {
    children: _propTypes2.default.node.isRequired,
    className: _propTypes2.default.string,
    disabled: _propTypes2.default.bool,
    rtl: _propTypes2.default.bool
};

exports.default = InputGroup;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  if (!(obj instanceof Object && !Array.isArray(obj))) {
    throw new Error('keyMirror(...): Argument must be an object.');
  }
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.REDO = exports.UNDO = exports.MAX_STACK_SIZE = exports.clearUndoState = exports.undoSnapshot = exports.redo = exports.undo = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UNDO = 'scratch-paint/undo/UNDO';
var REDO = 'scratch-paint/undo/REDO';
var SNAPSHOT = 'scratch-paint/undo/SNAPSHOT';
var CLEAR = 'scratch-paint/undo/CLEAR';
var MAX_STACK_SIZE = 100;
var initialState = {
    stack: [],
    pointer: -1
};

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case UNDO:
            if (state.pointer <= 0) {
                _log2.default.warn('Can\'t undo, undo stack is empty');
                return state;
            }
            return {
                stack: state.stack,
                pointer: state.pointer - 1
            };
        case REDO:
            if (state.pointer <= -1 || state.pointer === state.stack.length - 1) {
                _log2.default.warn('Can\'t redo, redo stack is empty');
                return state;
            }
            return {
                stack: state.stack,
                pointer: state.pointer + 1
            };
        case SNAPSHOT:
            if (!action.snapshot) {
                _log2.default.warn('Couldn\'t create undo snapshot, no data provided');
                return state;
            }
            // Overflowed or about to overflow
            if (state.pointer >= MAX_STACK_SIZE - 1) {
                return {
                    // Make a stack of size MAX_STACK_SIZE, cutting off the oldest snapshots.
                    stack: state.stack.slice(state.pointer - MAX_STACK_SIZE + 2, state.pointer + 1).concat(action.snapshot),
                    pointer: MAX_STACK_SIZE - 1
                };
            }
            return {
                // Performing an action clears the redo stack
                stack: state.stack.slice(0, state.pointer + 1).concat(action.snapshot),
                pointer: state.pointer + 1
            };
        case CLEAR:
            return initialState;
        default:
            return state;
    }
};

// Action creators ==================================
var undoSnapshot = function undoSnapshot(snapshot) {
    return {
        type: SNAPSHOT,
        snapshot: snapshot
    };
};
/**
 * @param {Format} format Either VECTOR_SKIP_CONVERT or BITMAP_SKIP_CONVERT
 * @return {Action} undo action
 */
var undo = function undo(format) {
    return {
        type: UNDO,
        format: format
    };
};
/**
 * @param {Format} format Either VECTOR_SKIP_CONVERT or BITMAP_SKIP_CONVERT
 * @return {Action} undo action
 */
var redo = function redo(format) {
    return {
        type: REDO,
        format: format
    };
};
var clearUndoState = function clearUndoState() {
    return {
        type: CLEAR
    };
};

exports.default = reducer;
exports.undo = undo;
exports.redo = redo;
exports.undoSnapshot = undoSnapshot;
exports.clearUndoState = clearUndoState;
exports.MAX_STACK_SIZE = MAX_STACK_SIZE;
exports.UNDO = UNDO;
exports.REDO = REDO;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.clearHoveredItem = exports.setHoveredItem = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_HOVERED = 'scratch-paint/hover/CHANGE_HOVERED';
var initialState = null;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_HOVERED:
            if (typeof action.hoveredItemId === 'undefined') {
                _log2.default.warn('Hovered item should not be set to undefined. Use null.');
                return state;
            } else if (typeof action.hoveredItemId === 'undefined' || isNaN(action.hoveredItemId)) {
                _log2.default.warn('Hovered item should be an item ID number. Got: ' + action.hoveredItemId);
                return state;
            }
            return action.hoveredItemId;
        default:
            return state;
    }
};

// Action creators ==================================
/**
 * Set the hovered item state to the given item ID
 * @param {number} hoveredItemId The paper.Item ID of the hover indicator item.
 * @return {object} Redux action to change the hovered item.
 */
var setHoveredItem = function setHoveredItem(hoveredItemId) {
    return {
        type: CHANGE_HOVERED,
        hoveredItemId: hoveredItemId
    };
};

var clearHoveredItem = function clearHoveredItem() {
    return {
        type: CHANGE_HOVERED,
        hoveredItemId: null
    };
};

exports.default = reducer;
exports.setHoveredItem = setHoveredItem;
exports.clearHoveredItem = clearHoveredItem;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.updateViewBounds = exports.default = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UPDATE_VIEW_BOUNDS = 'scratch-paint/view/UPDATE_VIEW_BOUNDS';
var initialState = new _paper2.default.Matrix(); // Identity

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case UPDATE_VIEW_BOUNDS:
            if (!(action.viewBounds instanceof _paper2.default.Matrix)) {
                _log2.default.warn('View bounds should be a paper.Matrix.');
                return state;
            }
            return action.viewBounds;
        default:
            return state;
    }
};

// Action creators ==================================
/**
 * Set the view bounds, which defines the zoom and scroll of the paper canvas.
 * @param {paper.Matrix} matrix The matrix applied to the view
 * @return {object} Redux action to set the view bounds
 */
var updateViewBounds = function updateViewBounds(matrix) {
    return {
        type: UPDATE_VIEW_BOUNDS,
        viewBounds: matrix.clone()
    };
};

exports.default = reducer;
exports.updateViewBounds = updateViewBounds;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _button = __webpack_require__(108);

var _button2 = _interopRequireDefault(_button);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; } /* DO NOT EDIT
                                                                                                                                                                                                                             @todo This file is copied from GUI and should be pulled out into a shared library.
                                                                                                                                                                                                                             See #13 */

/* ACTUALLY, THIS IS EDITED ;)
THIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD HANDLING FOR DISABLED STATES.*/

var ButtonComponent = function ButtonComponent(_ref) {
    var _classNames;

    var className = _ref.className,
        highlighted = _ref.highlighted,
        onClick = _ref.onClick,
        children = _ref.children,
        props = _objectWithoutProperties(_ref, ['className', 'highlighted', 'onClick', 'children']);

    var disabled = props.disabled || false;
    if (disabled === false) {
        // if not disabled, add `onClick()` to be applied
        // in props. If disabled, don't add `onClick()`
        props.onClick = onClick;
    }
    return _react2.default.createElement(
        'span',
        _extends({
            className: (0, _classnames2.default)(_button2.default.button, className, (_classNames = {}, _defineProperty(_classNames, _button2.default.modDisabled, disabled), _defineProperty(_classNames, _button2.default.highlighted, highlighted), _classNames)),
            role: 'button'
        }, props),
        children
    );
};

ButtonComponent.propTypes = {
    children: _propTypes2.default.node,
    className: _propTypes2.default.string,
    disabled: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.bool]),
    highlighted: _propTypes2.default.bool,
    onClick: _propTypes2.default.func.isRequired
};
exports.default = ButtonComponent;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var ACTIVATE_EYE_DROPPER = 'scratch-paint/eye-dropper/ACTIVATE_COLOR_PICKER';
var DEACTIVATE_EYE_DROPPER = 'scratch-paint/eye-dropper/DEACTIVATE_COLOR_PICKER';

var initialState = {
    active: false,
    callback: function callback() {}, // this will either be `onChangeFillColor` or `onChangeOutlineColor`
    previousTool: null // the tool that was previously active before eye dropper
};

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case ACTIVATE_EYE_DROPPER:
            return Object.assign({}, state, {
                active: true,
                callback: action.callback,
                previousTool: action.previousMode
            });
        case DEACTIVATE_EYE_DROPPER:
            return Object.assign({}, state, {
                active: false,
                callback: function callback() {},
                previousTool: null
            });
        default:
            return state;
    }
};

var activateEyeDropper = function activateEyeDropper(currentMode, callback) {
    return {
        type: ACTIVATE_EYE_DROPPER,
        callback: callback,
        previousMode: currentMode
    };
};
var deactivateEyeDropper = function deactivateEyeDropper() {
    return {
        type: DEACTIVATE_EYE_DROPPER
    };
};

exports.default = reducer;
exports.activateEyeDropper = activateEyeDropper;
exports.deactivateEyeDropper = deactivateEyeDropper;
exports.ACTIVATE_EYE_DROPPER = ACTIVATE_EYE_DROPPER;
exports.DEACTIVATE_EYE_DROPPER = DEACTIVATE_EYE_DROPPER;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeFormat = exports.default = undefined;

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _undo = __webpack_require__(35);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_FORMAT = 'scratch-paint/formats/CHANGE_FORMAT';
var initialState = null;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case _undo.UNDO:
        /* falls through */
        case _undo.REDO:
        /* falls through */
        case CHANGE_FORMAT:
            if (!action.format) return state;
            if (action.format in _format2.default) {
                return action.format;
            }
            _log2.default.warn('Format does not exist: ' + action.format);
        /* falls through */
        default:
            return state;
    }
};

// Action creators ==================================
var changeFormat = function changeFormat(format) {
    return {
        type: CHANGE_FORMAT,
        format: format
    };
};

exports.default = reducer;
exports.changeFormat = changeFormat;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeGradientType = exports.default = undefined;

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _fillStyle = __webpack_require__(18);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = null; // Gradient type shown in the fill tool. This is the last gradient type explicitly chosen by the user,
// and isn't overwritten by changing the selection.


var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case _fillStyle.CHANGE_FILL_GRADIENT_TYPE:
            if (action.gradientType in _gradientTypes2.default) {
                return action.gradientType;
            }
            _log2.default.warn('Gradient type does not exist: ' + action.gradientType);
        /* falls through */
        default:
            return state;
    }
};

// Action creators ==================================
// Use this for user-initiated gradient type selections only.
// See reducers/fill-style.js for other ways gradient type changes.
var changeGradientType = function changeGradientType(gradientType) {
    return {
        type: _fillStyle.CHANGE_FILL_GRADIENT_TYPE,
        gradientType: gradientType
    };
};

exports.default = reducer;
exports.changeGradientType = changeGradientType;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeColorIndex = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _fillStyle = __webpack_require__(18);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_COLOR_INDEX = 'scratch-paint/color-index/CHANGE_COLOR_INDEX';
var initialState = 0;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_COLOR_INDEX:
            if (action.index !== 1 && action.index !== 0) {
                _log2.default.warn('Invalid color index: ' + action.index);
                return state;
            }
            return action.index;
        case _fillStyle.CHANGE_FILL_GRADIENT_TYPE:
            if (action.gradientType === _gradientTypes2.default.SOLID) return 0;
        /* falls through */
        default:
            return state;
    }
};

// Action creators ==================================
var changeColorIndex = function changeColorIndex(index) {
    return {
        type: CHANGE_COLOR_INDEX,
        index: index
    };
};

exports.default = reducer;
exports.changeColorIndex = changeColorIndex;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var convert = __webpack_require__(144);

module.exports = function (cstr) {
    var m, conv, parts, alpha;
    if (m = /^((?:rgb|hs[lv]|cmyk|xyz|lab)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
        var name = m[1];
        var base = name.replace(/a$/, '');
        var size = base === 'cmyk' ? 4 : 3;
        conv = convert[base];
        
        parts = m[2].replace(/^\s+|\s+$/g, '')
            .split(/\s*,\s*/)
            .map(function (x, i) {
                if (/%$/.test(x) && i === size) {
                    return parseFloat(x) / 100;
                }
                else if (/%$/.test(x)) {
                    return parseFloat(x);
                }
                return parseFloat(x);
            })
        ;
        if (name === base) parts.push(1);
        alpha = parts[size] === undefined ? 1 : parts[size];
        parts = parts.slice(0, size);
        
        conv[base] = function () { return parts };
    }
    else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
        var base = cstr.replace(/^#/,'');
        var size = base.length;
        conv = convert.rgb;
        parts = base.split(size === 3 ? /(.)/ : /(..)/);
        parts = parts.filter(Boolean)
            .map(function (x) {
                if (size === 3) {
                    return parseInt(x + x, 16);
                }
                else {
                    return parseInt(x, 16)
                }
            })
        ;
        alpha = 1;
        conv.rgb = function () { return parts };
        if (!parts[0]) parts[0] = 0;
        if (!parts[1]) parts[1] = 0;
        if (!parts[2]) parts[2] = 0;
    }
    else {
        conv = convert.keyword;
        conv.keyword = function () { return cstr };
        parts = cstr;
        alpha = 1;
    }
    
    var res = {
        rgb: undefined,
        hsl: undefined,
        hsv: undefined,
        cmyk: undefined,
        keyword: undefined,
        hex: undefined
    };
    try { res.rgb = conv.rgb(parts) } catch (e) {}
    try { res.hsl = conv.hsl(parts) } catch (e) {}
    try { res.hsv = conv.hsv(parts) } catch (e) {}
    try { res.cmyk = conv.cmyk(parts) } catch (e) {}
    try { res.keyword = conv.keyword(parts) } catch (e) {}
    
    if (res.rgb) res.hex = '#' + res.rgb.map(function (x) {
        var s = x.toString(16);
        if (s.length === 1) return '0' + s;
        return s;
    }).join('');
    
    if (res.rgb) res.rgba = res.rgb.concat(alpha);
    if (res.hsl) res.hsla = res.hsl.concat(alpha);
    if (res.hsv) res.hsva = res.hsv.concat(alpha);
    if (res.cmyk) res.cmyka = res.cmyk.concat(alpha);
    
    return res;
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setTextEditTarget = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_TEXT_EDIT_TARGET = 'scratch-paint/text-tool/CHANGE_TEXT_EDIT_TARGET';
var initialState = null;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_TEXT_EDIT_TARGET:
            if (typeof action.textEditTargetId === 'undefined') {
                _log2.default.warn('Text edit target should not be set to undefined. Use null.');
                return state;
            } else if (typeof action.textEditTargetId === 'undefined' || isNaN(action.textEditTargetId)) {
                _log2.default.warn('Text edit target should be an item ID number. Got: ' + action.textEditTargetId);
                return state;
            }
            return action.textEditTargetId;
        default:
            return state;
    }
};

// Action creators ==================================
/**
 * Set the currently-being-edited text field to the given item ID
 * @param {?number} textEditTargetId The paper.Item ID of the active text field.
 *     Leave empty if there is no text editing target.
 * @return {object} Redux action to change the text edit target.
 */
var setTextEditTarget = function setTextEditTarget(textEditTargetId) {
    return {
        type: CHANGE_TEXT_EDIT_TARGET,
        textEditTargetId: textEditTargetId ? textEditTargetId : null
    };
};

exports.default = reducer;
exports.setTextEditTarget = setTextEditTarget;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);
  return basePickBy(object, props, function(value, key) {
    return key in object;
  });
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick from.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, props, predicate) {
  var index = -1,
      length = props.length,
      result = {};

  while (++index < length) {
    var key = props[index],
        value = object[key];

    if (predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = baseRest(function(object, props) {
  if (object == null) {
    return {};
  }
  props = arrayMap(baseFlatten(props, 1), toKey);
  return basePick(object, baseDifference(getAllKeysIn(object), props));
});

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = omit;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(59)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var Fonts = {
    SANS_SERIF: 'Sans Serif',
    SERIF: 'Serif',
    HANDWRITING: 'Handwriting',
    MARKER: 'Marker',
    CURLY: 'Curly',
    PIXEL: 'Pixel',
    CHINESE: '"Microsoft YaHei", "微软雅黑", STXihei, "华文细黑"',
    JAPANESE: '"ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro", Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic"',
    KOREAN: 'Malgun Gothic'
};

exports.default = Fonts;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shouldShowRedo = exports.shouldShowUndo = exports.performRedo = exports.performUndo = exports.performSnapshot = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _layer = __webpack_require__(12);

var _selection = __webpack_require__(3);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Take an undo snapshot
 * @param {function} dispatchPerformSnapshot Callback to dispatch a state update
 * @param {Formats} format Either Formats.BITMAP or Formats.VECTOR
 */
var performSnapshot = function performSnapshot(dispatchPerformSnapshot, format) {
    if (!format) {
        _log2.default.error('Format must be specified.');
    }
    var guideLayers = (0, _layer.hideGuideLayers)();
    dispatchPerformSnapshot({
        json: _paper2.default.project.exportJSON({ asString: false }),
        paintEditorFormat: format
    });
    (0, _layer.showGuideLayers)(guideLayers);
}; // undo functionality
// modifed from https://github.com/memononen/stylii


var _restore = function _restore(entry, setSelectedItems, onUpdateImage, isBitmapMode) {
    for (var i = _paper2.default.project.layers.length - 1; i >= 0; i--) {
        var layer = _paper2.default.project.layers[i];
        if (!layer.data.isBackgroundGuideLayer && !layer.data.isDragCrosshairLayer && !layer.data.isOutlineLayer) {
            layer.removeChildren();
            layer.remove();
        }
    }
    _paper2.default.project.importJSON(entry.json);
    setSelectedItems();

    // Ensure that all rasters are loaded before updating storage with new image data.
    var rastersThatNeedToLoad = [];
    var onLoad = function onLoad() {
        if (!(0, _layer.getRaster)().loaded) return;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = rastersThatNeedToLoad[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var raster = _step.value;

                if (!raster.loaded) return;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        onUpdateImage(true /* skipSnapshot */);
    };

    // Bitmap mode should have at most 1 selected item
    if (isBitmapMode) {
        var selectedItems = (0, _selection.getSelectedLeafItems)();
        if (selectedItems.length === 1 && selectedItems[0] instanceof _paper2.default.Raster) {
            rastersThatNeedToLoad.push(selectedItems[0]);
            if (selectedItems[0].data && selectedItems[0].data.expanded instanceof _paper2.default.Raster) {
                rastersThatNeedToLoad.push(selectedItems[0].data.expanded);
            }
        }
    }

    (0, _layer.getRaster)().onLoad = onLoad;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = rastersThatNeedToLoad[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var raster = _step2.value;

            raster.onLoad = onLoad;
            if (raster.loaded) raster.onLoad();
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }
};

var performUndo = function performUndo(undoState, dispatchPerformUndo, setSelectedItems, onUpdateImage) {
    if (undoState.pointer > 0) {
        var state = undoState.stack[undoState.pointer - 1];
        _restore(state, setSelectedItems, onUpdateImage, (0, _format.isBitmap)(state.paintEditorFormat));
        var format = (0, _format.isVector)(state.paintEditorFormat) ? _format2.default.VECTOR_SKIP_CONVERT : (0, _format.isBitmap)(state.paintEditorFormat) ? _format2.default.BITMAP_SKIP_CONVERT : null;
        dispatchPerformUndo(format);
    }
};

var performRedo = function performRedo(undoState, dispatchPerformRedo, setSelectedItems, onUpdateImage) {
    if (undoState.pointer >= 0 && undoState.pointer < undoState.stack.length - 1) {
        var state = undoState.stack[undoState.pointer + 1];
        _restore(state, setSelectedItems, onUpdateImage, (0, _format.isBitmap)(state.paintEditorFormat));
        var format = (0, _format.isVector)(state.paintEditorFormat) ? _format2.default.VECTOR_SKIP_CONVERT : (0, _format.isBitmap)(state.paintEditorFormat) ? _format2.default.BITMAP_SKIP_CONVERT : null;
        dispatchPerformRedo(format);
    }
};

var shouldShowUndo = function shouldShowUndo(undoState) {
    return undoState.pointer > 0;
};

var shouldShowRedo = function shouldShowRedo(undoState) {
    return undoState.pointer > -1 && undoState.pointer !== undoState.stack.length - 1;
};

exports.performSnapshot = performSnapshot;
exports.performUndo = performUndo;
exports.performRedo = performRedo;
exports.shouldShowUndo = shouldShowUndo;
exports.shouldShowRedo = shouldShowRedo;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var isCompoundPath = function isCompoundPath(item) {
    return item && item.className === 'CompoundPath';
};

var isCompoundPathChild = function isCompoundPathChild(item) {
    if (item.parent) {
        return item.parent.className === 'CompoundPath';
    }
    return false;
};

var getItemsCompoundPath = function getItemsCompoundPath(item) {
    var itemParent = item.parent;

    if (isCompoundPath(itemParent)) {
        return itemParent;
    }
    return null;
};

exports.isCompoundPath = isCompoundPath;
exports.isCompoundPathChild = isCompoundPathChild;
exports.getItemsCompoundPath = getItemsCompoundPath;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.clearPasteOffset = exports.incrementPasteOffset = exports.setClipboardItems = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SET = 'scratch-paint/clipboard/SET';
var INCREMENT_PASTE_OFFSET = 'scratch-paint/clipboard/INCREMENT_PASTE_OFFSET';
var CLEAR_PASTE_OFFSET = 'scratch-paint/clipboard/CLEAR_PASTE_OFFSET';
var initialState = {
    items: [],
    pasteOffset: 0
};

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case SET:
            if (!action.clipboardItems || !(action.clipboardItems instanceof Array) || action.clipboardItems.length === 0) {
                _log2.default.warn('Invalid clipboard item format');
                return state;
            }
            return {
                items: action.clipboardItems,
                pasteOffset: 1
            };
        case INCREMENT_PASTE_OFFSET:
            return {
                items: state.items,
                pasteOffset: state.pasteOffset + 1
            };
        case CLEAR_PASTE_OFFSET:
            return {
                items: state.items,
                pasteOffset: 0
            };
        default:
            return state;
    }
};

// Action creators ==================================
var setClipboardItems = function setClipboardItems(clipboardItems) {
    return {
        type: SET,
        clipboardItems: clipboardItems
    };
};

var incrementPasteOffset = function incrementPasteOffset() {
    return {
        type: INCREMENT_PASTE_OFFSET
    };
};

var clearPasteOffset = function clearPasteOffset() {
    return {
        type: CLEAR_PASTE_OFFSET
    };
};

exports.default = reducer;
exports.setClipboardItems = setClipboardItems;
exports.incrementPasteOffset = incrementPasteOffset;
exports.clearPasteOffset = clearPasteOffset;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _guides = __webpack_require__(27);

var _selection = __webpack_require__(3);

var _layer = __webpack_require__(12);

var _view = __webpack_require__(22);

var _bitmap = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Tool to handle drag selection. A dotted line box appears and everything enclosed is selected. */
var SelectionBoxTool = function () {
    /**
     * @param {!Modes} mode Current paint editor mode
     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
     */
    function SelectionBoxTool(mode, setSelectedItems, clearSelectedItems) {
        _classCallCheck(this, SelectionBoxTool);

        this.selectionRect = null;
        this.mode = mode;
        this.setSelectedItems = setSelectedItems;
        this.clearSelectedItems = clearSelectedItems;
    }
    /**
     * @param {boolean} multiselect Whether to multiselect on mouse down (e.g. shift key held)
     */


    _createClass(SelectionBoxTool, [{
        key: 'onMouseDown',
        value: function onMouseDown(multiselect) {
            if (!multiselect) {
                (0, _selection.clearSelection)(this.clearSelectedItems);
                this.clearSelectedItems();
            }
        }
    }, {
        key: 'onMouseDrag',
        value: function onMouseDrag(event) {
            if (event.event.button > 0) return; // only first mouse button
            if (this.selectionRect) {
                this.selectionRect.remove();
            }
            this.selectionRect = (0, _guides.rectSelect)(event);
        }
    }, {
        key: 'onMouseUpVector',
        value: function onMouseUpVector(event) {
            if (event.event.button > 0) return; // only first mouse button
            if (this.selectionRect) {
                (0, _selection.processRectangularSelection)(event, this.selectionRect, this.mode);
                this.selectionRect.remove();
                this.selectionRect = null;
                this.setSelectedItems();
            }
        }
    }, {
        key: 'onMouseUpBitmap',
        value: function onMouseUpBitmap(event) {
            if (event.event.button > 0) return; // only first mouse button
            if (this.selectionRect) {
                var rect = new _paper2.default.Rectangle({
                    from: new _paper2.default.Point(Math.max(0, Math.round(this.selectionRect.bounds.topLeft.x)), Math.max(0, Math.round(this.selectionRect.bounds.topLeft.y))),
                    to: new _paper2.default.Point(Math.min(_view.ART_BOARD_WIDTH, Math.round(this.selectionRect.bounds.bottomRight.x)), Math.min(_view.ART_BOARD_HEIGHT, Math.round(this.selectionRect.bounds.bottomRight.y)))
                });

                // Trim/tighten selection bounds inwards to only the opaque region, excluding transparent pixels
                rect = (0, _bitmap.getHitBounds)((0, _layer.getRaster)(), rect);

                if (rect.area) {
                    // Pull selected raster to active layer
                    var raster = (0, _layer.getRaster)().getSubRaster(rect);
                    raster.parent = _paper2.default.project.activeLayer;
                    raster.canvas.getContext('2d').imageSmoothingEnabled = false;
                    raster.selected = true;
                    // Gather a bit of extra data so that we can avoid aliasing at edges
                    var expanded = (0, _layer.getRaster)().getSubRaster(rect.expand(4));
                    expanded.remove();
                    raster.data = { expanded: expanded };

                    // Clear area from raster layer
                    var context = (0, _layer.getRaster)().getContext(true /* modify */);
                    context.clearRect(rect.x, rect.y, rect.width, rect.height);
                    this.setSelectedItems();
                }

                // Remove dotted rectangle
                this.selectionRect.remove();
                this.selectionRect = null;
            }
        }
    }]);

    return SelectionBoxTool;
}();

exports.default = SelectionBoxTool;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeBrushSize = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_ERASER_SIZE = 'scratch-paint/eraser-mode/CHANGE_ERASER_SIZE';
var initialState = { brushSize: 40 };

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_ERASER_SIZE:
            if (isNaN(action.brushSize)) {
                _log2.default.warn('Invalid brush size: ' + action.brushSize);
                return state;
            }
            return { brushSize: Math.max(1, action.brushSize) };
        default:
            return state;
    }
};

// Action creators ==================================
var changeBrushSize = function changeBrushSize(brushSize) {
    return {
        type: CHANGE_ERASER_SIZE,
        brushSize: brushSize
    };
};

exports.default = reducer;
exports.changeBrushSize = changeBrushSize;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _initialState;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var OPEN_MODAL = 'scratch-paint/modals/OPEN_MODAL';
var CLOSE_MODAL = 'scratch-paint/modals/CLOSE_MODAL';

var MODAL_FILL_COLOR = 'fillColor';
var MODAL_STROKE_COLOR = 'strokeColor';

var initialState = (_initialState = {}, _defineProperty(_initialState, MODAL_FILL_COLOR, false), _defineProperty(_initialState, MODAL_STROKE_COLOR, false), _initialState);

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case OPEN_MODAL:
            return Object.assign({}, initialState, _defineProperty({}, action.modal, true));
        case CLOSE_MODAL:
            return Object.assign({}, initialState, _defineProperty({}, action.modal, false));
        default:
            return state;
    }
};

var openModal = function openModal(modal) {
    return {
        type: OPEN_MODAL,
        modal: modal
    };
};

var closeModal = function closeModal(modal) {
    return {
        type: CLOSE_MODAL,
        modal: modal
    };
};

// Action creators ==================================

var openFillColor = function openFillColor() {
    return openModal(MODAL_FILL_COLOR);
};

var openStrokeColor = function openStrokeColor() {
    return openModal(MODAL_STROKE_COLOR);
};

var closeFillColor = function closeFillColor() {
    return closeModal(MODAL_FILL_COLOR);
};

var closeStrokeColor = function closeStrokeColor() {
    return closeModal(MODAL_STROKE_COLOR);
};

exports.default = reducer;
exports.openFillColor = openFillColor;
exports.openStrokeColor = openStrokeColor;
exports.closeFillColor = closeFillColor;
exports.closeStrokeColor = closeStrokeColor;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _button = __webpack_require__(38);

var _button2 = _interopRequireDefault(_button);

var _labeledIconButton = __webpack_require__(155);

var _labeledIconButton2 = _interopRequireDefault(_labeledIconButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; } /* @todo This file should be pulled out into a shared library with scratch-gui,
                                                                                                                                                                                                                             consolidating this component with icon-button.jsx in gui.
                                                                                                                                                                                                                             See #13 */

var LabeledIconButton = function LabeledIconButton(_ref) {
    var className = _ref.className,
        hideLabel = _ref.hideLabel,
        imgAlt = _ref.imgAlt,
        imgSrc = _ref.imgSrc,
        onClick = _ref.onClick,
        title = _ref.title,
        props = _objectWithoutProperties(_ref, ['className', 'hideLabel', 'imgAlt', 'imgSrc', 'onClick', 'title']);

    return _react2.default.createElement(
        _button2.default,
        _extends({
            className: (0, _classnames2.default)(className, _labeledIconButton2.default.modEditField),
            onClick: onClick
        }, props),
        _react2.default.createElement('img', {
            alt: imgAlt || title,
            className: _labeledIconButton2.default.editFieldIcon,
            draggable: false,
            src: imgSrc,
            title: title
        }),
        !hideLabel && _react2.default.createElement(
            'span',
            { className: _labeledIconButton2.default.editFieldTitle },
            title
        )
    );
};

LabeledIconButton.propTypes = {
    className: _propTypes2.default.string,
    hideLabel: _propTypes2.default.bool,
    highlighted: _propTypes2.default.bool,
    imgAlt: _propTypes2.default.string,
    imgSrc: _propTypes2.default.string.isRequired,
    onClick: _propTypes2.default.func.isRequired,
    title: _propTypes2.default.string.isRequired
};

exports.default = LabeledIconButton;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _label = __webpack_require__(167);

var _label2 = _interopRequireDefault(_label);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Label = function Label(props) {
    return _react2.default.createElement(
        'label',
        { className: _label2.default.inputGroup },
        _react2.default.createElement(
            'span',
            { className: props.secondary ? _label2.default.inputLabelSecondary : _label2.default.inputLabel },
            props.text
        ),
        props.children
    );
}; /* DO NOT EDIT
   @todo This file is copied from GUI and should be pulled out into a shared library.
   See https://github.com/LLK/scratch-paint/issues/13 */

Label.propTypes = {
    children: _propTypes2.default.node,
    secondary: _propTypes2.default.bool,
    text: _propTypes2.default.string.isRequired
};

Label.defaultProps = {
    secondary: false
};

exports.default = Label;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _input = __webpack_require__(187);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; } /* DO NOT EDIT
                                                                                                                                                                                                                             @todo This file is copied from GUI and should be pulled out into a shared library.
                                                                                                                                                                                                                             See https://github.com/LLK/scratch-paint/issues/13 */

/* NOTE:
Edited to add range prop
*/

var Input = function Input(props) {
    var _classNames;

    var small = props.small,
        range = props.range,
        componentProps = _objectWithoutProperties(props, ['small', 'range']);

    return _react2.default.createElement('input', _extends({}, componentProps, {
        className: (0, _classnames2.default)(_input2.default.inputForm, props.className, (_classNames = {}, _defineProperty(_classNames, _input2.default.inputSmall, small && !range), _defineProperty(_classNames, _input2.default.inputSmallRange, small && range), _classNames))
    }));
};

Input.propTypes = {
    className: _propTypes2.default.string,
    range: _propTypes2.default.bool,
    small: _propTypes2.default.bool
};

Input.defaultProps = {
    range: false,
    small: false
};

exports.default = Input;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SET_LAYOUT = exports.setLayout = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SET_LAYOUT = 'scratch-paint/layout/SET_LAYOUT';
var initialState = { rtl: false };

var layouts = ['ltr', 'rtl'];

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case SET_LAYOUT:
            if (layouts.indexOf(action.layout) === -1) {
                _log2.default.warn('Unrecognized layout provided: ' + action.layout);
                return state;
            }
            return { rtl: action.layout === 'rtl' };
        default:
            return state;
    }
};

// Action creators ==================================
/**
 * Change the layout to the new layout
 * @param {string} layout either 'ltr' or 'rtl'
 * @return {object} Redux action to change the selected items.
 */
var setLayout = function setLayout(layout) {
    return {
        type: SET_LAYOUT,
        layout: layout
    };
};

exports.default = reducer;
exports.setLayout = setLayout;
exports.SET_LAYOUT = SET_LAYOUT;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeFont = exports.default = undefined;

var _fonts = __webpack_require__(46);

var _fonts2 = _interopRequireDefault(_fonts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_FONT = 'scratch-paint/fonts/CHANGE_FONT';
var initialState = _fonts2.default.SANS_SERIF;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_FONT:
            if (!action.font) return state;
            return action.font;
        default:
            return state;
    }
};

// Action creators ==================================
var changeFont = function changeFont(font) {
    return {
        type: CHANGE_FONT,
        font: font
    };
};

exports.default = reducer;
exports.changeFont = changeFont;

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),
/* 59 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setZoomLevelId = exports.saveZoomLevel = exports.default = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SAVE_ZOOM_LEVEL = 'scratch-paint/zoom-levels/SAVE_ZOOM_LEVEL';
var SET_ZOOM_LEVEL_ID = 'scratch-paint/zoom-levels/SET_ZOOM_LEVEL_ID';
var initialState = {};

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case SET_ZOOM_LEVEL_ID:
            if (action.zoomLevelId === 'currentZoomLevelId') {
                _log2.default.warn('currentZoomLevelId is an invalid string for zoomLevel');
                return state;
            }
            return Object.assign({}, state, {
                currentZoomLevelId: action.zoomLevelId
            });
        case SAVE_ZOOM_LEVEL:
            return Object.assign({}, state, _defineProperty({}, state.currentZoomLevelId, action.zoomLevel));
        default:
            return state;
    }
};

// Action creators ==================================
var saveZoomLevel = function saveZoomLevel(zoomLevel) {
    if (!(zoomLevel instanceof _paper2.default.Matrix)) {
        _log2.default.warn('Not a matrix: ' + zoomLevel);
    }
    return {
        type: SAVE_ZOOM_LEVEL,
        zoomLevel: new _paper2.default.Matrix(zoomLevel)
    };
};
var setZoomLevelId = function setZoomLevelId(zoomLevelId) {
    return {
        type: SET_ZOOM_LEVEL_ID,
        zoomLevelId: zoomLevelId
    };
};

exports.default = reducer;
exports.saveZoomLevel = saveZoomLevel;
exports.setZoomLevelId = setZoomLevelId;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
/* DO NOT EDIT
@todo This file is copied from GUI and should be pulled out into a shared library.
See https://github.com/LLK/scratch-paint/issues/13 */

var getEventXY = function getEventXY(e) {
    if (e.touches && e.touches[0]) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    } else if (e.changedTouches && e.changedTouches[0]) {
        return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
    }
    return { x: e.clientX, y: e.clientY };
};

exports.getEventXY = getEventXY;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _selectedItems = __webpack_require__(7);

var _stylePath = __webpack_require__(9);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Matches hex colors
var hexRegex = /^#([0-9a-f]{3}){1,2}$/i;

var isValidHexColor = function isValidHexColor(color) {
    if (!hexRegex.test(color) && color !== null && color !== _stylePath.MIXED) {
        _log2.default.warn('Invalid hex color code: ' + color);
        return false;
    }
    return true;
};

var makeColorStyleReducer = function makeColorStyleReducer(_ref) {
    var changePrimaryColorAction = _ref.changePrimaryColorAction,
        changeSecondaryColorAction = _ref.changeSecondaryColorAction,
        changeGradientTypeAction = _ref.changeGradientTypeAction,
        clearGradientAction = _ref.clearGradientAction,
        defaultColor = _ref.defaultColor,
        selectionPrimaryColorKey = _ref.selectionPrimaryColorKey,
        selectionSecondaryColorKey = _ref.selectionSecondaryColorKey,
        selectionGradientTypeKey = _ref.selectionGradientTypeKey;
    return function colorReducer(state, action) {
        if (typeof state === 'undefined') {
            state = {
                primary: defaultColor,
                secondary: null,
                gradientType: _gradientTypes2.default.SOLID
            };
        }
        switch (action.type) {
            case changePrimaryColorAction:
                if (!isValidHexColor(action.color)) return state;
                return _extends({}, state, { primary: action.color });
            case changeSecondaryColorAction:
                if (!isValidHexColor(action.color)) return state;
                return _extends({}, state, { secondary: action.color });
            case _selectedItems.CHANGE_SELECTED_ITEMS:
                {
                    // Don't change state if no selection
                    if (!action.selectedItems || !action.selectedItems.length) {
                        return state;
                    }
                    var colors = (0, _stylePath.getColorsFromSelection)(action.selectedItems, action.bitmapMode);

                    // Only set the primary color + gradient type if they exist in what getColorsFromSelection gave us.
                    // E.g. in bitmap mode, getColorsFromSelection will not return stroke color/gradient type. This allows us to
                    // preserve stroke swatch state across bitmap mode-- if getColorsFromSelection set them to null, then selecting
                    // anything in bitmap mode would overwrite the stroke state.
                    var newState = _extends({}, state);
                    if (selectionPrimaryColorKey in colors) {
                        newState.primary = colors[selectionPrimaryColorKey];
                    }
                    if (selectionGradientTypeKey in colors) {
                        newState.gradientType = colors[selectionGradientTypeKey];
                    }

                    // Gradient type may be solid when multiple gradient types are selected.
                    // In this case, changing the first color should not change the second color.
                    if (selectionSecondaryColorKey in colors && (colors[selectionGradientTypeKey] !== _gradientTypes2.default.SOLID || colors[selectionSecondaryColorKey] === _stylePath.MIXED)) {
                        newState.secondary = colors[selectionSecondaryColorKey];
                    }
                    return newState;
                }
            case changeGradientTypeAction:
                if (action.gradientType in _gradientTypes2.default) {
                    return _extends({}, state, { gradientType: action.gradientType });
                }
                _log2.default.warn('Gradient type does not exist: ' + action.gradientType);
                return state;
            case clearGradientAction:
                return _extends({}, state, { secondary: null, gradientType: _gradientTypes2.default.SOLID });
            default:
                return state;
        }
    };
};

exports.default = makeColorStyleReducer;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Ebrush%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='brush' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cpath d='M9.50062663,11.4981734 L10.4995734,11.4981734 L10.4995734,14.4990134 L9.49962669,14.4990134 L9.49962669,11.4991734 L6.49978668,11.4991734 L6.49978668,10.4992267 L9.50062663,10.4992267 L9.50062663,11.4981734 Z M13.4992134,3.5 L16.5000533,3.5 L16.5000533,4.49994667 L17.5,4.49994667 L17.5,7.49978668 L16.5000533,7.49978668 L16.5000533,8.4987334 L15.4991067,8.4987334 L15.4991067,9.49868007 L14.49916,9.49868007 L14.49916,10.4986267 L12.4992667,10.4986267 L12.4992667,11.4985734 L11.49932,11.4985734 L11.49932,10.4986267 L10.4993734,10.4986267 L10.4993734,9.49868007 L9.4994267,9.49868007 L9.4994267,7.49978668 L10.4993734,7.49978668 L10.4993734,6.49984001 L11.49932,6.49984001 L11.49932,5.49989334 L12.4992667,5.49989334 L12.4992667,4.49994667 L13.4992134,4.49994667 L13.4992134,3.5 Z M5.49954002,11.4987734 L6.49948669,11.4987734 L6.49948669,12.49972 L7.50043331,12.49972 L7.50043331,13.4996667 L8.50037998,13.4996667 L8.50037998,14.4996134 L9.50032665,14.4996134 L9.50032665,15.49956 L8.50037998,15.49956 L8.50037998,16.4985067 L4.49959336,16.4985067 L4.49959336,15.49956 L3.49964669,15.49956 L3.49964669,13.4996667 L5.49954002,13.4996667 L5.49954002,11.4987734 Z M2.5,13.4990667 L2.5,12.49912 L3.49994667,12.49912 L3.49994667,13.4990667 L2.5,13.4990667 Z' id='Combined-Shape' fill='%23575E75'%3E%3C/path%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _layer = __webpack_require__(12);

var _bitmap = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tool for drawing with the bitmap brush and eraser
 */
var BrushTool = function (_paper$Tool) {
    _inherits(BrushTool, _paper$Tool);

    /**
     * @param {!function} onUpdateImage A callback to call when the image visibly changes
     * @param {boolean} isEraser True if brush should erase
     */
    function BrushTool(onUpdateImage, isEraser) {
        _classCallCheck(this, BrushTool);

        var _this = _possibleConstructorReturn(this, (BrushTool.__proto__ || Object.getPrototypeOf(BrushTool)).call(this));

        _this.onUpdateImage = onUpdateImage;
        _this.isEraser = isEraser;

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseMove = _this.handleMouseMove;
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseDrag = _this.handleMouseDrag;
        _this.onMouseUp = _this.handleMouseUp;

        _this.colorState = null;
        _this.active = false;
        _this.lastPoint = null;
        _this.cursorPreview = null;
        return _this;
    }

    _createClass(BrushTool, [{
        key: 'setColor',
        value: function setColor(color) {
            this.color = color;
            this.tmpCanvas = (0, _bitmap.getBrushMark)(this.size, this.color, this.isEraser || !this.color);
        }
    }, {
        key: 'setBrushSize',
        value: function setBrushSize(size) {
            // For performance, make sure this is an integer
            this.size = Math.max(1, ~~size);
            this.tmpCanvas = (0, _bitmap.getBrushMark)(this.size, this.color, this.isEraser || !this.color);
        }
        // Draw a brush mark at the given point

    }, {
        key: 'draw',
        value: function draw(x, y) {
            var roundedUpRadius = Math.ceil(this.size / 2);
            var context = (0, _layer.getRaster)().getContext('2d');
            if (this.isEraser || !this.color) {
                context.globalCompositeOperation = 'destination-out';
            }
            (0, _layer.getRaster)().drawImage(this.tmpCanvas, new _paper2.default.Point(~~x - roundedUpRadius, ~~y - roundedUpRadius));
            if (this.isEraser || !this.color) {
                context.globalCompositeOperation = 'source-over';
            }
        }
    }, {
        key: 'updateCursorIfNeeded',
        value: function updateCursorIfNeeded() {
            if (!this.size) {
                return;
            }

            // The cursor preview was unattached from the view by an outside process,
            // such as changing costumes or undo.
            if (this.cursorPreview && !this.cursorPreview.parent) {
                this.cursorPreview = null;
            }

            if (!this.cursorPreview || !(this.lastSize === this.size && this.lastColor === this.color)) {
                if (this.cursorPreview) {
                    this.cursorPreview.remove();
                }

                this.tmpCanvas = (0, _bitmap.getBrushMark)(this.size, this.color, this.isEraser || !this.color);
                this.cursorPreview = new _paper2.default.Raster(this.tmpCanvas);
                this.cursorPreview.guide = true;
                this.cursorPreview.parent = (0, _layer.getGuideLayer)();
                this.cursorPreview.data.isHelperItem = true;
            }

            this.lastSize = this.size;
            this.lastColor = this.color;
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            this.updateCursorIfNeeded();
            this.cursorPreview.position = new _paper2.default.Point(~~event.point.x, ~~event.point.y);
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;

            if (this.cursorPreview) {
                this.cursorPreview.remove();
            }

            this.draw(event.point.x, event.point.y);
            this.lastPoint = event.point;
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            (0, _bitmap.forEachLinePoint)(this.lastPoint, event.point, this.draw.bind(this));
            this.lastPoint = event.point;
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            (0, _bitmap.forEachLinePoint)(this.lastPoint, event.point, this.draw.bind(this));
            this.onUpdateImage();

            this.lastPoint = null;
            this.active = false;

            this.updateCursorIfNeeded();
            this.cursorPreview.position = new _paper2.default.Point(~~event.point.x, ~~event.point.y);
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.active = false;
            this.tmpCanvas = null;
            if (this.cursorPreview) {
                this.cursorPreview.remove();
                this.cursorPreview = null;
            }
        }
    }]);

    return BrushTool;
}(_paper2.default.Tool);

exports.default = BrushTool;

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eline%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='line' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cpath d='M12,7.998 L12,6 L14,6 L14,8 L12.002,8 L12.002,10 L10,10 L10,7.998 L12,7.998 Z M8,12 L8,10 L10,10 L10,12 L8,12 Z M14,6 L14,4 L16,4 L16,6 L14,6 Z M4,16 L4,14 L6,14 L6,16 L4,16 Z M6,14 L6,12 L8,12 L8,14 L6,14 Z' id='Combined-Shape' fill='%23575E75'%3E%3C/path%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var Cursors = {
    DEFAULT: 'default',
    GRAB: 'grab',
    GRABBING: 'grabbing',
    NONE: 'none',
    RESIZE_EW: 'ew-resize',
    RESIZE_NS: 'ns-resize',
    RESIZE_NESW: 'nesw-resize',
    RESIZE_NWSE: 'nwse-resize'
};

exports.default = Cursors;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _group = __webpack_require__(24);

var _item = __webpack_require__(26);

var _math = __webpack_require__(20);

var _view = __webpack_require__(22);

var _selection = __webpack_require__(3);

var _layer = __webpack_require__(12);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Snap to align selection center to rotation center within this distance */
var SNAPPING_THRESHOLD = 4;
var FADE_DISTANCE = 10;

/**
 * Tool to handle dragging an item to reposition it in a selection mode.
 */

var MoveTool = function () {
    /**
     * @param {Modes} mode Paint editor mode
     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
     * @param {!function} onUpdateImage A callback to call when the image visibly changes
     * @param {?function} switchToTextTool A callback to call to switch to the text tool
     */
    function MoveTool(mode, setSelectedItems, clearSelectedItems, onUpdateImage, switchToTextTool) {
        _classCallCheck(this, MoveTool);

        this.mode = mode;
        this.setSelectedItems = setSelectedItems;
        this.clearSelectedItems = clearSelectedItems;
        this.selectedItems = null;
        this.selectionCenter = null;
        this.onUpdateImage = onUpdateImage;
        this.switchToTextTool = switchToTextTool;
        this.boundsPath = null;
        this.firstDrag = false;
    }

    /**
     * @param {!object} hitProperties Describes the mouse event
     * @param {!paper.HitResult} hitProperties.hitResult Data about the location of the mouse click
     * @param {?boolean} hitProperties.clone Whether to clone on mouse down (e.g. alt key held)
     * @param {?boolean} hitProperties.multiselect Whether to multiselect on mouse down (e.g. shift key held)
     * @param {?boolean} hitProperties.doubleClicked True if this is the second click in a short amout of time
     * @param {?boolean} hitProperties.subselect True if we allow selection of subgroups, false if we should
     *     select the whole group.
     */


    _createClass(MoveTool, [{
        key: 'onMouseDown',
        value: function onMouseDown(hitProperties) {
            var item = hitProperties.hitResult.item;
            if (!hitProperties.subselect) {
                var root = (0, _item.getRootItem)(hitProperties.hitResult.item);
                item = (0, _item.isCompoundPathItem)(root) || (0, _group.isGroup)(root) ? root : hitProperties.hitResult.item;
            }
            if (item.selected) {
                // Double click causes all points to be selected in subselect mode. If the target is text, it
                // enters text edit.
                if (hitProperties.doubleClicked) {
                    if (!hitProperties.multiselect) {
                        if (this.switchToTextTool && item instanceof _paper2.default.PointText) {
                            this.switchToTextTool();
                            return;
                        }
                        (0, _selection.clearSelection)(this.clearSelectedItems);
                    }
                    this._select(item, true /* state */, hitProperties.subselect, true /* fullySelect */);
                } else if (hitProperties.multiselect) {
                    this._select(item, false /* state */, hitProperties.subselect);
                }
            } else {
                // deselect all by default if multiselect isn't on
                if (!hitProperties.multiselect) {
                    (0, _selection.clearSelection)(this.clearSelectedItems);
                }
                this._select(item, true, hitProperties.subselect);
            }
            if (hitProperties.clone) (0, _selection.cloneSelection)(hitProperties.subselect, this.onUpdateImage);

            this.selectedItems = this.mode === _modes2.default.RESHAPE ? (0, _selection.getSelectedLeafItems)() : (0, _selection.getSelectedRootItems)();
            if (this.selectedItems.length === 0) {
                return;
            }

            var selectionBounds = void 0;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = this.selectedItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var selectedItem = _step.value;

                    if (selectionBounds) {
                        selectionBounds = selectionBounds.unite(selectedItem.bounds);
                    } else {
                        selectionBounds = selectedItem.bounds;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.selectionCenter = selectionBounds.center;

            if (this.boundsPath) {
                this.selectedItems.push(this.boundsPath);
            }

            this.firstDrag = true;
        }
    }, {
        key: 'setBoundsPath',
        value: function setBoundsPath(boundsPath) {
            this.boundsPath = boundsPath;
        }
        /**
         * Sets the selection state of an item.
         * @param {!paper.Item} item Item to select or deselect
         * @param {?boolean} state True if item should be selected, false if deselected
         * @param {?boolean} subselect True if a subset of all points in an item are allowed to be
         *     selected, false if items must be selected all or nothing.
         * @param {?boolean} fullySelect True if in addition to the item being selected, all of its
         *     control points should be selected. False if the item should be selected but not its
         *     points. Only relevant when subselect is true.
         */

    }, {
        key: '_select',
        value: function _select(item, state, subselect, fullySelect) {
            if (subselect) {
                item.selected = false;
                if (fullySelect) {
                    item.fullySelected = state;
                } else {
                    item.selected = state;
                }
            } else {
                (0, _selection.setItemSelection)(item, state);
            }
            this.setSelectedItems();
        }
    }, {
        key: 'onMouseDrag',
        value: function onMouseDrag(event) {
            var point = event.point;
            var actionBounds = (0, _view.getActionBounds)(this.mode in _modes.BitmapModes);

            point.x = Math.max(actionBounds.left, Math.min(point.x, actionBounds.right));
            point.y = Math.max(actionBounds.top, Math.min(point.y, actionBounds.bottom));

            var dragVector = point.subtract(event.downPoint);
            var snapVector = void 0;

            // Snapping to align center. Not in reshape mode, because reshape doesn't show center crosshair
            if (!event.modifiers.shift && this.mode !== _modes2.default.RESHAPE) {
                if ((0, _math.checkPointsClose)(this.selectionCenter.add(dragVector), _view.CENTER, SNAPPING_THRESHOLD / _paper2.default.view.zoom /* threshold */)) {

                    snapVector = _view.CENTER.subtract(this.selectionCenter);
                }
            }
            if (this.selectedItems.length === 0) {
                return;
            }

            var bounds = void 0;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this.selectedItems[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var item = _step2.value;

                    // add the position of the item before the drag started
                    // for later use in the snap calculation
                    if (!item.data.origPos) {
                        item.data.origPos = item.position;
                    }

                    if (snapVector) {
                        item.position = item.data.origPos.add(snapVector);
                    } else if (event.modifiers.shift) {
                        item.position = item.data.origPos.add((0, _math.snapDeltaToAngle)(dragVector, Math.PI / 4));
                    } else {
                        item.position = item.data.origPos.add(dragVector);
                    }

                    if (bounds) {
                        bounds = bounds.unite(item.bounds);
                    } else {
                        bounds = item.bounds;
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            if (this.firstDrag) {
                // Show the center crosshair above the selected item while dragging.
                (0, _layer.getDragCrosshairLayer)().visible = true;
                this.firstDrag = false;
            }

            // The rotation center crosshair should be opaque over the entire selection bounding box, and fade out to
            // totally transparent outside the selection bounding box.
            var opacityMultiplier = 1;
            var newCenter = this.selectionCenter.add(dragVector);
            if (_view.CENTER.y < bounds.top && _view.CENTER.x < bounds.left || _view.CENTER.y > bounds.bottom && _view.CENTER.x < bounds.left || _view.CENTER.y < bounds.top && _view.CENTER.x > bounds.right || _view.CENTER.y > bounds.bottom && _view.CENTER.x > bounds.right) {

                // rotation center is to one of the 4 corners of the selection bounding box
                var distX = Math.max(_view.CENTER.x - bounds.right, bounds.left - _view.CENTER.x);
                var distY = Math.max(_view.CENTER.y - bounds.bottom, bounds.top - _view.CENTER.y);
                var dist = Math.sqrt(distX * distX + distY * distY);
                opacityMultiplier = Math.max(0, 1 - dist / (FADE_DISTANCE / _paper2.default.view.zoom));
            } else if (_view.CENTER.y < bounds.top || _view.CENTER.y > bounds.bottom) {
                // rotation center is above or below the selection bounding box
                opacityMultiplier = Math.max(0, 1 - (Math.abs(_view.CENTER.y - newCenter.y) - bounds.height / 2) / (FADE_DISTANCE / _paper2.default.view.zoom));
            } else if (_view.CENTER.x < bounds.left || _view.CENTER.x > bounds.right) {
                // rotation center is left or right of the selection bounding box
                opacityMultiplier = Math.max(0, 1 - (Math.abs(_view.CENTER.x - newCenter.x) - bounds.width / 2) / (FADE_DISTANCE / _paper2.default.view.zoom));
            } // else the rotation center is within selection bounds, always show drag crosshair at full opacity
            (0, _layer.getDragCrosshairLayer)().opacity = _layer.CROSSHAIR_FULL_OPACITY * opacityMultiplier;
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp() {
            this.firstDrag = false;
            var moved = false;
            // resetting the items origin point for the next usage
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = this.selectedItems[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var item = _step3.value;

                    if (item.data.origPos) {
                        if (!item.position.equals(item.data.origPos)) moved = true;
                        delete item.data.origPos;
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            this.selectedItems = null;
            this.selectionCenter = null;

            if (moved) {
                this.onUpdateImage();
            }

            // Hide the crosshair we showed earlier.
            (0, _layer.getDragCrosshairLayer)().visible = false;
        }
    }]);

    return MoveTool;
}();

exports.default = MoveTool;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eoval%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='oval' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cpolygon id='Page-1' fill='%23575E75' points='6.66666667 4 6.66666667 5.33333333 5.33333333 5.33333333 5.33333333 6.66666667 4 6.66666667 4 13.3333333 5.33333333 13.3333333 5.33333333 14.6666667 6.66666667 14.6666667 6.66666667 16 13.3333333 16 13.3333333 14.6666667 14.6666667 14.6666667 14.6666667 13.3333333 16 13.3333333 16 6.66666667 14.6666667 6.66666667 14.6666667 5.33333333 13.3333333 5.33333333 13.3333333 4'%3E%3C/polygon%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Erectange%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='rectange' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Crect id='rectangle-icon' fill='%23575E75' x='4' y='4' width='12' height='12'%3E%3C/rect%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eeraser%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='eraser' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cpath d='M9.30022904,14.1996946 L7.89984723,14.1996946 L7.89984723,12.7997327 L6.49988541,12.7997327 L6.49988541,11.3997709 L5.09992359,11.3997709 L5.09992359,9.99840913 L3.69996177,9.99840913 L3.69996177,8.59984728 L2.29999995,8.59984728 L2.29999995,7.19988546 L3.69996177,7.19988546 L3.69996177,5.79992364 L5.09992359,5.79992364 L5.09992359,4.39996182 L6.49988541,4.39996182 L6.49988541,3 L7.89984723,3 L7.89984723,4.39996182 L9.30120901,4.39996182 L9.30120901,5.79992364 L10.7011708,5.79992364 L10.7011708,7.19988546 L12.1011326,7.19988546 L12.1011326,8.59984728 L13.4996945,8.59984728 L13.4996945,9.99840913 L12.1011326,9.99840913 L12.1011326,11.3997709 L10.7011708,11.3997709 L10.7011708,12.7997327 L9.30120901,12.7997327 L9.30120901,14.1995546 L10.7001909,14.1995546 L10.7001909,15.5995164 L9.30022904,15.5995164 L9.30022904,14.1996946 Z M10.7001909,16.9994782 L10.7001909,15.5995164 L14.9000763,15.5995164 L14.9000763,16.9994782 L10.7001909,16.9994782 Z M14.9000763,15.5995164 L14.9000763,14.1995546 L16.3000381,14.1995546 L16.3000381,15.5995164 L14.9000763,15.5995164 Z M14.9000763,12.7995927 L14.9000763,11.3996309 L16.3000381,11.3996309 L16.3000381,12.7995927 L14.9000763,12.7995927 Z M16.3000381,14.1995546 L16.3000381,12.7995927 L17.7,12.7995927 L17.7,14.1995546 L16.3000381,14.1995546 Z M13.5001145,11.3996309 L13.5001145,9.99826914 L14.9000763,9.99826914 L14.9000763,11.3996309 L13.5001145,11.3996309 Z' id='Combined-Shape' fill='%23575E75'%3E%3C/path%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactStyleProptype = __webpack_require__(134);

var _reactStyleProptype2 = _interopRequireDefault(_reactStyleProptype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; } /* DO NOT EDIT
                                                                                                                                                                                                                             @todo This file is copied from GUI and should be pulled out into a shared library.
                                                                                                                                                                                                                             See https://github.com/LLK/scratch-paint/issues/13 */

var getRandomColor = function () {
    // In "DEBUG" mode this is used to output a random background color for each
    // box. The function gives the same "random" set for each seed, allowing re-
    // renders of the same content to give the same random display.
    var random = function (seed) {
        var mW = seed;
        var mZ = 987654321;
        var mask = 0xffffffff;
        return function () {
            mZ = 36969 * (mZ & 65535) + (mZ >> 16) & mask;
            mW = 18000 * (mW & 65535) + (mW >> 16) & mask;
            var result = (mZ << 16) + mW & mask;
            result /= 4294967296;
            return result + 1;
        };
    }(601);
    return function () {
        var r = Math.max(parseInt(random() * 100, 10) % 256, 1);
        var g = Math.max(parseInt(random() * 100, 10) % 256, 1);
        var b = Math.max(parseInt(random() * 100, 10) % 256, 1);
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    };
}();

var Box = function Box(props) {
    var alignContent = props.alignContent,
        alignItems = props.alignItems,
        alignSelf = props.alignSelf,
        basis = props.basis,
        children = props.children,
        className = props.className,
        componentRef = props.componentRef,
        direction = props.direction,
        element = props.element,
        grow = props.grow,
        height = props.height,
        justifyContent = props.justifyContent,
        width = props.width,
        wrap = props.wrap,
        shrink = props.shrink,
        style = props.style,
        componentProps = _objectWithoutProperties(props, ['alignContent', 'alignItems', 'alignSelf', 'basis', 'children', 'className', 'componentRef', 'direction', 'element', 'grow', 'height', 'justifyContent', 'width', 'wrap', 'shrink', 'style']);

    return _react2.default.createElement(element, _extends({
        className: className,
        ref: componentRef,
        style: Object.assign({
            alignContent: alignContent,
            alignItems: alignItems,
            alignSelf: alignSelf,
            flexBasis: basis,
            flexDirection: direction,
            flexGrow: grow,
            flexShrink: shrink,
            flexWrap: wrap,
            justifyContent: justifyContent,
            width: width,
            height: height
        }, process.env.DEBUG ? { // eslint-disable-line no-undef
            backgroundColor: getRandomColor(),
            outline: '1px solid black'
        } : {}, style)
    }, componentProps), children);
};
Box.propTypes = {
    /** Defines how the browser distributes space between and around content items vertically within this box. */
    alignContent: _propTypes2.default.oneOf(['flex-start', 'flex-end', 'center', 'space-between', 'space-around', 'stretch']),
    /** Defines how the browser distributes space between and around flex items horizontally within this box. */
    alignItems: _propTypes2.default.oneOf(['flex-start', 'flex-end', 'center', 'baseline', 'stretch']),
    /** Specifies how this box should be aligned inside of its container (requires the container to be flexable). */
    alignSelf: _propTypes2.default.oneOf(['auto', 'flex-start', 'flex-end', 'center', 'baseline', 'stretch']),
    /** Specifies the initial length of this box */
    basis: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.oneOf(['auto'])]),
    /** Specifies the the HTML nodes which will be child elements of this box. */
    children: _propTypes2.default.node,
    /** Specifies the class name that will be set on this box */
    className: _propTypes2.default.string,
    /**
     * A callback function whose first parameter is the underlying dom elements.
     * This call back will be executed immediately after the component is mounted or unmounted
     */
    componentRef: _propTypes2.default.func,
    /** https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction */
    direction: _propTypes2.default.oneOf(['row', 'row-reverse', 'column', 'column-reverse']),
    /** Specifies the type of HTML element of this box. Defaults to div. */
    element: _propTypes2.default.string,
    /** Specifies the flex grow factor of a flex item. */
    grow: _propTypes2.default.number,
    /** The height in pixels (if specified as a number) or a string if different units are required. */
    height: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /** https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content */
    justifyContent: _propTypes2.default.oneOf(['flex-start', 'flex-end', 'center', 'space-between', 'space-around']),
    /** Specifies the flex shrink factor of a flex item. */
    shrink: _propTypes2.default.number,
    /** An object whose keys are css property names and whose values correspond the the css property. */
    style: _reactStyleProptype2.default,
    /** The width in pixels (if specified as a number) or a string if different units are required. */
    width: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /** How whitespace should wrap within this block. */
    wrap: _propTypes2.default.oneOf(['nowrap', 'wrap', 'wrap-reverse'])
};
Box.defaultProps = {
    element: 'div',
    style: {}
};
exports.default = Box;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(133)))

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _buttonGroup = __webpack_require__(135);

var _buttonGroup2 = _interopRequireDefault(_buttonGroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ButtonGroup = function ButtonGroup(props) {
    return _react2.default.createElement(
        'div',
        { className: (0, _classnames2.default)(props.className, _buttonGroup2.default.buttonGroup) },
        props.children
    );
};

ButtonGroup.propTypes = {
    children: _propTypes2.default.node.isRequired,
    className: _propTypes2.default.string
};

exports.default = ButtonGroup;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _broadBrushHelper = __webpack_require__(138);

var _broadBrushHelper2 = _interopRequireDefault(_broadBrushHelper);

var _segmentBrushHelper = __webpack_require__(139);

var _segmentBrushHelper2 = _interopRequireDefault(_segmentBrushHelper);

var _stylePath = __webpack_require__(9);

var _selection = __webpack_require__(3);

var _layer = __webpack_require__(12);

var _compoundPath = __webpack_require__(48);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Shared code for the brush and eraser mode. Adds functions on the paper tool object
 * to handle mouse events, which are delegated to broad-brush-helper and segment-brush-helper
 * based on the brushSize in the state.
 */
var Blobbiness = function () {
    _createClass(Blobbiness, null, [{
        key: 'BROAD',
        get: function get() {
            return 'broadbrush';
        }
    }, {
        key: 'SEGMENT',
        get: function get() {
            return 'segmentbrush';
        }

        // If brush size >= threshold use segment brush, else use broadbrush
        // Segment brush has performance issues at low threshold, but broad brush has weird corners
        // which get more obvious the bigger it is

    }, {
        key: 'THRESHOLD',
        get: function get() {
            return 30 / _paper2.default.view.zoom;
        }

        /**
         * @param {function} onUpdateImage call when the drawing has changed to let listeners know
         * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
         */

    }]);

    function Blobbiness(onUpdateImage, clearSelectedItems) {
        _classCallCheck(this, Blobbiness);

        this.broadBrushHelper = new _broadBrushHelper2.default();
        this.segmentBrushHelper = new _segmentBrushHelper2.default();
        this.onUpdateImage = onUpdateImage;
        this.clearSelectedItems = clearSelectedItems;

        // The following are stored to check whether these have changed and the cursor preview needs to be redrawn.
        this.strokeColor = null;
        this.brushSize = null;
        this.fillColor = null;
    }

    /**
     * Set configuration options for a blob
     * @param {!object} options Configuration
     * @param {!number} options.brushSize Width of blob marking made by mouse
     * @param {!boolean} options.isEraser Whether the stroke should be treated as an erase path. If false,
     *     the stroke is an additive path.
     * @param {?string} options.fillColor Color of the brush stroke.
     * @param {?string} options.strokeColor Color of the brush outline.
     * @param {?number} options.strokeWidth Width of the brush outline.
     */


    _createClass(Blobbiness, [{
        key: 'setOptions',
        value: function setOptions(options) {
            var oldFillColor = this.options ? this.options.fillColor : 'black';
            var oldStrokeColor = this.options ? this.options.strokeColor : null;
            var oldStrokeWidth = this.options ? this.options.strokeWidth : null;
            // If values are mixed, it means the color was set by a selection contained multiple values.
            // In this case keep drawing with the previous values if any. (For stroke width, null indicates
            // mixed, because stroke width is required to be a number)
            this.options = _extends({}, options, {
                fillColor: options.fillColor === _stylePath.MIXED ? oldFillColor : options.fillColor,
                strokeColor: options.strokeColor === _stylePath.MIXED ? oldStrokeColor : options.strokeColor,
                strokeWidth: options.strokeWidth === null ? oldStrokeWidth : options.strokeWidth
            });
            this.resizeCursorIfNeeded();
        }

        /**
         * Adds handlers on the mouse tool to draw blobs. Initialize with configuration options for a blob.
         * @param {!object} options Configuration
         * @param {!number} options.brushSize Width of blob marking made by mouse
         * @param {!boolean} options.isEraser Whether the stroke should be treated as an erase path. If false,
         *     the stroke is an additive path.
         * @param {?string} options.fillColor Color of the brush stroke.
         * @param {?string} options.strokeColor Color of the brush outline.
         * @param {?number} options.strokeWidth Width of the brush outline.
         */

    }, {
        key: 'activateTool',
        value: function activateTool(options) {
            this.tool = new _paper2.default.Tool();
            this.cursorPreviewLastPoint = new _paper2.default.Point(-10000, -10000);
            this.setOptions(options);
            this.tool.active = false;
            this.tool.fixedDistance = 1;

            var blob = this;
            this.tool.onMouseMove = function (event) {
                blob.resizeCursorIfNeeded(event.point);
                (0, _stylePath.styleCursorPreview)(blob.cursorPreview, blob.options);
                blob.cursorPreview.bringToFront();
                blob.cursorPreview.position = event.point;
            };

            this.tool.onMouseDown = function (event) {
                blob.resizeCursorIfNeeded(event.point);
                if (event.event.button > 0) return; // only first mouse button
                this.active = true;

                if (blob.options.brushSize < Blobbiness.THRESHOLD) {
                    blob.brush = Blobbiness.BROAD;
                    blob.broadBrushHelper.onBroadMouseDown(event, blob.tool, blob.options);
                } else {
                    blob.brush = Blobbiness.SEGMENT;
                    blob.segmentBrushHelper.onSegmentMouseDown(event, blob.tool, blob.options);
                }
                blob.cursorPreview.bringToFront();
                blob.cursorPreview.position = event.point;
            };

            this.tool.onMouseDrag = function (event) {
                if (event.event.button > 0 || !this.active) return; // only first mouse button
                if (blob.brush === Blobbiness.BROAD) {
                    blob.broadBrushHelper.onBroadMouseDrag(event, blob.tool, blob.options);
                } else if (blob.brush === Blobbiness.SEGMENT) {
                    blob.segmentBrushHelper.onSegmentMouseDrag(event, blob.tool, blob.options);
                } else {
                    _log2.default.warn('Brush type does not exist: ' + blob.brush);
                }

                blob.cursorPreview.bringToFront();
                blob.cursorPreview.position = event.point;
            };

            this.tool.onMouseUp = function (event) {
                if (event.event.button > 0 || !this.active) return; // only first mouse button

                var lastPath = void 0;
                if (blob.brush === Blobbiness.BROAD) {
                    lastPath = blob.broadBrushHelper.onBroadMouseUp(event, blob.tool, blob.options);
                } else if (blob.brush === Blobbiness.SEGMENT) {
                    lastPath = blob.segmentBrushHelper.onSegmentMouseUp(event, blob.tool, blob.options);
                } else {
                    _log2.default.warn('Brush type does not exist: ' + blob.brush);
                }

                if (blob.options.isEraser) {
                    blob.mergeEraser(lastPath);
                } else {
                    blob.mergeBrush(lastPath);
                }

                // Remove cursor preview during snapshot, then bring it back
                blob.cursorPreview.remove();
                blob.onUpdateImage();
                blob.cursorPreview.parent = (0, _layer.getGuideLayer)();

                // Reset
                blob.brush = null;
                this.fixedDistance = 1;
                this.active = false;
            };
            this.tool.activate();
        }
    }, {
        key: 'resizeCursorIfNeeded',
        value: function resizeCursorIfNeeded(point) {
            if (!this.options) {
                return;
            }
            // The cursor preview was unattached from the view by an outside process,
            // such as changing costumes or undo.
            if (this.cursorPreview && !this.cursorPreview.parent) {
                this.cursorPreview = null;
            }
            if (this.cursorPreview && this.brushSize === this.options.brushSize && this.fillColor === this.options.fillColor && this.strokeColor === this.options.strokeColor && this.cursorPreviewLastPoint.equals(point)) {
                return;
            }
            if (typeof point !== 'undefined') {
                this.cursorPreviewLastPoint = point;
            }

            if (!this.cursorPreview) {
                this.cursorPreview = new _paper2.default.Shape.Ellipse({
                    point: this.cursorPreviewLastPoint,
                    size: this.options.brushSize / 2
                });
                this.cursorPreview.parent = (0, _layer.getGuideLayer)();
                this.cursorPreview.data.isHelperItem = true;
                (0, _layer.setGuideItem)(this.cursorPreview);
            }
            this.cursorPreview.position = this.cursorPreviewLastPoint;
            this.cursorPreview.radius = this.options.brushSize / 2;
            this.brushSize = this.options.brushSize;
            this.fillColor = this.options.fillColor;
            this.strokeColor = this.options.strokeColor;
            (0, _stylePath.styleCursorPreview)(this.cursorPreview, this.options);
        }
    }, {
        key: 'mergeBrush',
        value: function mergeBrush(lastPath) {
            var blob = this;

            // Get all path items to merge with
            var paths = (0, _selection.getItems)({
                match: function match(item) {
                    return blob.isMergeable(lastPath, item) && item.parent instanceof _paper2.default.Layer; // don't merge with nested in group
                }
            });

            var mergedPath = lastPath;
            var i = void 0;
            // Move down z order to first overlapping item
            for (i = paths.length - 1; i >= 0 && !this.touches(paths[i], lastPath); i--) {
                continue;
            }
            var mergedPathIndex = i;
            for (; i >= 0; i--) {
                if (!this.touches(paths[i], lastPath)) {
                    continue;
                }
                if (!paths[i].getFillColor()) {
                    // Ignore for merge. Paths without fill need to be in paths though,
                    // since they can visibly change if z order changes
                } else if (this.colorMatch(paths[i], lastPath)) {
                    // Make sure the new shape isn't overlapped by anything that would
                    // visibly change if we change its z order
                    for (var j = mergedPathIndex; j > i; j--) {
                        if (this.touches(paths[j], paths[i])) {
                            continue;
                        }
                    }
                    // Merge same fill color
                    var tempPath = mergedPath.unite(paths[i]);
                    tempPath.strokeColor = paths[i].strokeColor;
                    tempPath.strokeWidth = paths[i].strokeWidth;
                    if (mergedPath === lastPath) {
                        tempPath.insertAbove(paths[i]); // First intersected path determines z position of the new path
                    } else {
                        tempPath.insertAbove(mergedPath); // Rest of merges join z index of merged path
                        mergedPathIndex--; // Removed an item, so the merged path index decreases
                    }
                    mergedPath.remove();
                    mergedPath = tempPath;
                    paths[i].remove();
                    paths.splice(i, 1);
                }
            }
        }
    }, {
        key: 'mergeEraser',
        value: function mergeEraser(lastPath) {
            var blob = this;

            // Get all path items to merge with
            // If there are selected items, try to erase from amongst those.
            var items = (0, _selection.getItems)({
                match: function match(item) {
                    return item.selected && blob.isMergeable(lastPath, item) && blob.touches(lastPath, item) &&
                    // Boolean operations will produce incorrect results if directly applied to compound path children,
                    // so exclude those. Their parents are also selected so boolean operations will apply to them.
                    !(0, _compoundPath.isCompoundPathChild)(item);
                },
                class: _paper2.default.PathItem
            });
            // Eraser didn't hit anything selected, so assume they meant to erase from all instead of from subset
            // and deselect the selection
            if (items.length === 0) {
                (0, _selection.clearSelection)(this.clearSelectedItems);
                items = (0, _selection.getItems)({
                    match: function match(item) {
                        return blob.isMergeable(lastPath, item) && blob.touches(lastPath, item) && !(0, _compoundPath.isCompoundPathChild)(item);
                    },
                    class: _paper2.default.PathItem
                });
            }

            for (var i = items.length - 1; i >= 0; i--) {
                if (items[i] instanceof _paper2.default.Path && (!items[i].fillColor || items[i].fillColor._alpha === 0)) {
                    // Gather path segments
                    var _subpaths = [];
                    var firstSeg = items[i];
                    var intersections = firstSeg.getIntersections(lastPath);
                    for (var j = intersections.length - 1; j >= 0; j--) {
                        var split = firstSeg.splitAt(intersections[j]);
                        if (split) {
                            split.insertAbove(firstSeg);
                            _subpaths.push(split);
                        }
                    }
                    _subpaths.push(firstSeg);

                    // Remove the ones that are within the eraser stroke boundary
                    for (var k = _subpaths.length - 1; k >= 0; k--) {
                        var segMidpoint = _subpaths[k].getLocationAt(_subpaths[k].length / 2).point;
                        if (lastPath.contains(segMidpoint)) {
                            _subpaths[k].remove();
                            _subpaths.splice(k, 1);
                        }
                    }
                    lastPath.remove();
                    continue;
                }

                // Erase
                var newPath = items[i].subtract(lastPath);
                newPath.insertBelow(items[i]);

                // Gather path segments
                var subpaths = [];
                if (items[i] instanceof _paper2.default.Path && !items[i].closed) {
                    var _firstSeg = items[i].clone();
                    var _intersections = _firstSeg.getIntersections(lastPath);
                    // keep first and last segments
                    for (var _j = _intersections.length - 1; _j >= 0; _j--) {
                        var _split = _firstSeg.splitAt(_intersections[_j]);
                        _split.insertAbove(_firstSeg);
                        subpaths.push(_split);
                    }
                    subpaths.push(_firstSeg);
                }

                // Remove the ones that are within the eraser stroke boundary, or are already part of new path.
                // This way subpaths only remain if they didn't get turned into a shape by subtract.
                for (var _k = subpaths.length - 1; _k >= 0; _k--) {
                    var _segMidpoint = subpaths[_k].getLocationAt(subpaths[_k].length / 2).point;
                    if (lastPath.contains(_segMidpoint) || newPath.contains(_segMidpoint)) {
                        subpaths[_k].remove();
                        subpaths.splice(_k, 1);
                    }
                }

                if (newPath.children) {
                    this.separateCompoundPath(newPath);
                    newPath.remove();
                }
                items[i].remove();
            }
            lastPath.remove();
        }
    }, {
        key: 'separateCompoundPath',
        value: function separateCompoundPath(compoundPath) {
            if (!compoundPath.isClockwise()) {
                compoundPath.reverse();
            }
            // Divide topologically separate shapes into their own compound paths, instead of
            // everything being stuck together.
            var clockwiseChildren = [];
            var ccwChildren = [];
            for (var j = compoundPath.children.length - 1; j >= 0; j--) {
                var child = compoundPath.children[j];
                if (child.isClockwise()) {
                    clockwiseChildren.push(child);
                } else {
                    ccwChildren.push(child);
                }
            }

            // Sort by area smallest to largest
            clockwiseChildren.sort(function (a, b) {
                return a.area - b.area;
            });
            ccwChildren.sort(function (a, b) {
                return Math.abs(a.area) - Math.abs(b.area);
            });
            // Go smallest to largest non-hole, so larger non-holes don't get the smaller pieces' holes
            for (var _j2 = 0; _j2 < clockwiseChildren.length; _j2++) {
                var cw = clockwiseChildren[_j2];
                cw.copyAttributes(compoundPath);
                cw.fillColor = compoundPath.fillColor;
                cw.strokeColor = compoundPath.strokeColor;
                cw.strokeWidth = compoundPath.strokeWidth;
                cw.insertAbove(compoundPath);

                // Go backward since we are deleting elements. Backwards is largest to smallest hole.
                var newCw = cw;
                for (var k = ccwChildren.length - 1; k >= 0; k--) {
                    var ccw = ccwChildren[k];
                    if (this.firstEnclosesSecond(cw, ccw)) {
                        var temp = newCw.subtract(ccw);
                        temp.insertAbove(compoundPath);
                        newCw.remove();
                        newCw = temp;
                        ccw.remove();
                        ccwChildren.splice(k, 1);
                    }
                }
            }
        }
    }, {
        key: 'colorMatch',
        value: function colorMatch(existingPath, addedPath) {
            // Note: transparent fill colors do notdetect as touching
            return existingPath.getFillColor().equals(addedPath.getFillColor()) && (addedPath.getStrokeColor() === existingPath.getStrokeColor() || // both null
            addedPath.getStrokeColor() && addedPath.getStrokeColor().equals(existingPath.getStrokeColor())) && addedPath.getStrokeWidth() === existingPath.getStrokeWidth() && this.touches(existingPath, addedPath);
        }
    }, {
        key: 'touches',
        value: function touches(path1, path2) {
            // Two shapes are touching if their paths intersect
            if (path1 && path2 && path1.intersects(path2)) {
                return true;
            }
            return this.firstEnclosesSecond(path1, path2) || this.firstEnclosesSecond(path2, path1);
        }
    }, {
        key: 'firstEnclosesSecond',
        value: function firstEnclosesSecond(path1, path2) {
            // Two shapes are also touching if one is completely inside the other
            if (path1 && path2 && path2.firstSegment && path2.firstSegment.point && path1.hitTest(path2.firstSegment.point)) {
                return true;
            }
            // TODO: clean up these no point paths
            return false;
        }
    }, {
        key: 'matchesAnyChild',
        value: function matchesAnyChild(group, path) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = group.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var child = _step.value;

                    if (child.children && this.matchesAnyChild(path, child)) {
                        return true;
                    }
                    if (path === child) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return false;
        }
    }, {
        key: 'isMergeable',
        value: function isMergeable(newPath, existingPath) {
            // Path or compound path
            if (!(existingPath instanceof _paper2.default.PathItem)) {
                return;
            }
            if (newPath.children) {
                if (this.matchesAnyChild(newPath, existingPath)) {
                    // Don't merge with children of self
                    return false;
                }
            }
            return existingPath !== newPath; // don't merge with self
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            if (this.cursorPreview) {
                this.cursorPreview.remove();
                this.cursorPreview = null;
            }
            this.tool.remove();
            this.tool = null;
        }
    }]);

    return Blobbiness;
}();

exports.default = Blobbiness;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Ebrush%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' stroke-linecap='round' stroke-linejoin='round'%3E %3Cg id='brush' stroke='%23575E75' stroke-width='0.5' fill='%23575E75'%3E %3Cpath d='M12.5787225,11.2102026 C11.6196284,12.1692967 10.9129274,12.6614634 10.3576624,12.8507583 C10.1936069,12.3459719 9.91597437,11.8790445 9.52476494,11.4878351 C9.12093585,11.0966257 8.65400846,10.8189932 8.14922209,10.6423179 C8.35113664,10.0870529 8.84330335,9.38035203 9.78977778,8.43387759 C12.0613164,6.14971929 16.0996074,3.36077461 16.8694066,4.13057382 C17.6392058,4.90037303 14.8502611,8.93866396 12.5787225,11.2102026 Z M8.39124334,15.4120104 C8.01569197,15.7748657 7.53110955,15.9621459 7.04652713,15.9855559 L7.04652713,15.9972609 L6.92538153,15.9972609 C3.67867934,16.114311 2.26127577,12.4389379 3.37581533,12.8252032 C4.84167714,13.3285186 5.43650205,12.602808 5.45951972,12.579398 C6.27119527,11.8068673 7.57956779,11.8068673 8.39124334,12.579398 C9.20291889,13.3636337 9.20291889,14.6394798 8.39124334,15.4120104 Z' id='bursh-icon'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eeraser%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='eraser' fill='%23575E75'%3E %3Cpath d='M13.5370061,14.8291597 L10.9660545,14.8291597 L8.3016138,12.164719 L11.1686144,9.29771842 L15.1263216,13.2554257 L13.5370061,14.8291597 Z M16.7779633,12.6944908 L11.1686144,7.10072343 L8.3016138,4.23372287 C8.00556483,3.92209238 7.50695604,3.92209238 7.19532554,4.23372287 L3.22203673,8.20701169 C2.92598776,8.50306066 2.92598776,9.00166945 3.22203673,9.29771842 L6.10461881,12.164719 L10.0934891,16.1535893 C10.2337229,16.3094046 10.4362827,16.3873122 10.6388425,16.3873122 L13.8642181,16.3873122 C14.066778,16.3873122 14.2693378,16.3094046 14.4095715,16.1535893 L16.7779633,13.8007791 C17.0740122,13.5047301 17.0740122,13.0061213 16.7779633,12.6944908 L16.7779633,12.6944908 Z' id='eraser-icon'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _parseColor = __webpack_require__(43);

var _parseColor2 = _interopRequireDefault(_parseColor);

var _reactIntl = __webpack_require__(23);

var _selection = __webpack_require__(3);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _colorIndicator = __webpack_require__(146);

var _colorIndicator2 = _interopRequireDefault(_colorIndicator);

var _stylePath = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var makeColorIndicator = function makeColorIndicator(label, isStroke) {
    var ColorIndicator = function (_React$Component) {
        _inherits(ColorIndicator, _React$Component);

        function ColorIndicator(props) {
            _classCallCheck(this, ColorIndicator);

            var _this = _possibleConstructorReturn(this, (ColorIndicator.__proto__ || Object.getPrototypeOf(ColorIndicator)).call(this, props));

            (0, _lodash2.default)(_this, ['handleChangeColor', 'handleChangeGradientType', 'handleCloseColor', 'handleSwap']);

            // Flag to track whether an svg-update-worthy change has been made
            _this._hasChanged = false;
            return _this;
        }

        _createClass(ColorIndicator, [{
            key: 'componentWillReceiveProps',
            value: function componentWillReceiveProps(newProps) {
                var _props = this.props,
                    colorModalVisible = _props.colorModalVisible,
                    onUpdateImage = _props.onUpdateImage;

                if (colorModalVisible && !newProps.colorModalVisible) {
                    // Submit the new SVG, which also stores a single undo/redo action.
                    if (this._hasChanged) onUpdateImage();
                    this._hasChanged = false;
                }
            }
        }, {
            key: 'handleChangeColor',
            value: function handleChangeColor(newColor) {
                // Stroke-selector-specific logic: if we change the stroke color from "none" to something visible, ensure
                // there's a nonzero stroke width. If we change the stroke color to "none", set the stroke width to zero.
                if (isStroke) {

                    // Whether the old color style in this color indicator was null (completely transparent).
                    // If it's a solid color, this means that the first color is null.
                    // If it's a gradient, this means both colors are null.
                    var oldStyleWasNull = this.props.gradientType === _gradientTypes2.default.SOLID ? this.props.color === null : this.props.color === null && this.props.color2 === null;

                    var otherColor = this.props.colorIndex === 1 ? this.props.color : this.props.color2;
                    // Whether the new color style in this color indicator is null.
                    var newStyleIsNull = this.props.gradientType === _gradientTypes2.default.SOLID ? newColor === null : newColor === null && otherColor === null;

                    if (oldStyleWasNull && !newStyleIsNull) {
                        this._hasChanged = (0, _stylePath.applyStrokeWidthToSelection)(1, this.props.textEditTarget) || this._hasChanged;
                        this.props.onChangeStrokeWidth(1);
                    } else if (!oldStyleWasNull && newStyleIsNull) {
                        this._hasChanged = (0, _stylePath.applyStrokeWidthToSelection)(0, this.props.textEditTarget) || this._hasChanged;
                        this.props.onChangeStrokeWidth(0);
                    }
                }

                var formatIsBitmap = (0, _format.isBitmap)(this.props.format);
                // Apply color and update redux, but do not update svg until picker closes.
                var isDifferent = (0, _stylePath.applyColorToSelection)(newColor, this.props.colorIndex, this.props.gradientType === _gradientTypes2.default.SOLID,
                // In bitmap mode, only the fill color selector is used, but it applies to stroke if fillBitmapShapes
                // is set to true via the "Fill"/"Outline" selector button
                isStroke || formatIsBitmap && !this.props.fillBitmapShapes, this.props.textEditTarget);
                this._hasChanged = this._hasChanged || isDifferent;
                this.props.onChangeColor(newColor, this.props.colorIndex);
            }
        }, {
            key: 'handleChangeGradientType',
            value: function handleChangeGradientType(gradientType) {
                var formatIsBitmap = (0, _format.isBitmap)(this.props.format);
                // Apply color and update redux, but do not update svg until picker closes.
                var isDifferent = (0, _stylePath.applyGradientTypeToSelection)(gradientType, isStroke || formatIsBitmap && !this.props.fillBitmapShapes, this.props.textEditTarget);
                this._hasChanged = this._hasChanged || isDifferent;
                var hasSelectedItems = (0, _selection.getSelectedLeafItems)().length > 0;
                if (hasSelectedItems) {
                    if (isDifferent) {
                        // Recalculates the swatch colors
                        this.props.setSelectedItems(this.props.format);
                    }
                }
                if (this.props.gradientType === _gradientTypes2.default.SOLID && gradientType !== _gradientTypes2.default.SOLID) {
                    // Generate color 2 and change to the 2nd swatch when switching from solid to gradient
                    if (!hasSelectedItems) {
                        this.props.onChangeColor((0, _stylePath.generateSecondaryColor)(this.props.color), 1);
                    }
                    this.props.onChangeColorIndex(1);
                }
                if (this.props.onChangeGradientType) this.props.onChangeGradientType(gradientType);
            }
        }, {
            key: 'handleCloseColor',
            value: function handleCloseColor() {
                // If the eyedropper is currently being used, don't
                // close the color menu.
                if (this.props.isEyeDropping) return;

                // Otherwise, close the color menu and
                // also reset the color index to indicate
                // that `color1` is selected.
                this.props.onCloseColor();
                this.props.onChangeColorIndex(0);
            }
        }, {
            key: 'handleSwap',
            value: function handleSwap() {
                if ((0, _selection.getSelectedLeafItems)().length) {
                    var formatIsBitmap = (0, _format.isBitmap)(this.props.format);
                    var isDifferent = (0, _stylePath.swapColorsInSelection)(isStroke || formatIsBitmap && !this.props.fillBitmapShapes, this.props.textEditTarget);
                    this.props.setSelectedItems(this.props.format);
                    this._hasChanged = this._hasChanged || isDifferent;
                } else {
                    var color1 = this.props.color;
                    var color2 = this.props.color2;
                    color1 = color1 === null || color1 === _stylePath.MIXED ? color1 : (0, _parseColor2.default)(color1).hex;
                    color2 = color2 === null || color2 === _stylePath.MIXED ? color2 : (0, _parseColor2.default)(color2).hex;
                    this.props.onChangeColor(color1, 1);
                    this.props.onChangeColor(color2, 0);
                }
            }
        }, {
            key: 'render',
            value: function render() {
                return _react2.default.createElement(_colorIndicator2.default, _extends({}, this.props, {
                    label: this.props.intl.formatMessage(label),
                    outline: isStroke,
                    onChangeColor: this.handleChangeColor,
                    onChangeGradientType: this.handleChangeGradientType,
                    onCloseColor: this.handleCloseColor,
                    onSwap: this.handleSwap
                }));
            }
        }]);

        return ColorIndicator;
    }(_react2.default.Component);

    ColorIndicator.propTypes = {
        colorIndex: _propTypes2.default.number.isRequired,
        disabled: _propTypes2.default.bool.isRequired,
        color: _propTypes2.default.string,
        color2: _propTypes2.default.string,
        colorModalVisible: _propTypes2.default.bool.isRequired,
        fillBitmapShapes: _propTypes2.default.bool.isRequired,
        format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
        gradientType: _propTypes2.default.oneOf(Object.keys(_gradientTypes2.default)).isRequired,
        intl: _reactIntl.intlShape,
        isEyeDropping: _propTypes2.default.bool.isRequired,
        onChangeColorIndex: _propTypes2.default.func.isRequired,
        onChangeColor: _propTypes2.default.func.isRequired,
        onChangeGradientType: _propTypes2.default.func,
        onChangeStrokeWidth: _propTypes2.default.func,
        onCloseColor: _propTypes2.default.func.isRequired,
        onUpdateImage: _propTypes2.default.func.isRequired,
        setSelectedItems: _propTypes2.default.func.isRequired,
        textEditTarget: _propTypes2.default.number
    };

    return (0, _reactIntl.injectIntl)(ColorIndicator);
};

exports.default = makeColorIndicator;

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = require("react-popover");

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eno-fill%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' stroke-linecap='square'%3E %3Cg id='no-fill' stroke='%23FF661A' stroke-width='2'%3E %3Cpath d='M3,17 L17,3' id='Line'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Emixed-fill%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0.75'%3E %3Cg id='mixed-fill'%3E %3Cg id='mixed-fill-icon' transform='translate(2.000000, 2.500000)'%3E %3Ccircle id='blue' fill='%234C97FF' cx='4.5' cy='10.5' r='4.5'%3E%3C/circle%3E %3Ccircle id='red' fill='%23FF5500' cx='8' cy='4.5' r='4.5'%3E%3C/circle%3E %3Ccircle id='yellow' fill='%23FFBF00' cx='11.4099998' cy='10.5' r='4.5'%3E%3C/circle%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHoveredItem = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _item = __webpack_require__(26);

var _guides = __webpack_require__(27);

var _group = __webpack_require__(24);

var _math = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {!MouseEvent} event mouse event
 * @param {?object} hitOptions hit options to use
 * @param {?boolean} subselect Whether items within groups can be hovered. If false, the
 *    entire group should be hovered.
 * @return {paper.Item} the hovered item or null if there is none
 */
var getHoveredItem = function getHoveredItem(event, hitOptions, subselect) {
    var oldMatch = hitOptions.match;
    hitOptions.match = function (hitResult) {
        if (hitResult.item.data && hitResult.item.data.noHover) return false;
        return oldMatch ? oldMatch(hitResult) : true;
    };
    var hitResults = _paper2.default.project.hitTestAll(event.point, hitOptions);
    if (hitResults.length === 0) {
        return null;
    }

    // Get highest z-index result
    var hitResult = void 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = hitResults[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var result = _step.value;

            if (!hitResult || (0, _math.sortItemsByZIndex)(hitResult.item, result.item) < 0) {
                hitResult = result;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    var item = hitResult.item;
    // If the hovered item is already selected, then there should be no hovered item.
    if (!item || item.selected) {
        return null;
    }

    var hoverGuide = void 0;
    if ((0, _item.isBoundsItem)(item)) {
        hoverGuide = (0, _guides.hoverBounds)(item);
    } else if (!subselect && (0, _group.isGroupChild)(item)) {
        hoverGuide = (0, _guides.hoverBounds)((0, _item.getRootItem)(item));
    } else {
        hoverGuide = (0, _guides.hoverItem)(item);
    }
    hoverGuide.data.hitResult = hitResult;

    return hoverGuide;
};

exports.getHoveredItem = getHoveredItem;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ZOOM_SCALE = exports.LOUPE_RADIUS = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _layer = __webpack_require__(12);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LOUPE_RADIUS = 20;
var ZOOM_SCALE = 3;

var EyeDropperTool = function (_paper$Tool) {
    _inherits(EyeDropperTool, _paper$Tool);

    function EyeDropperTool(canvas, width, height, pixelRatio, zoom, offsetX, offsetY, isBitmap) {
        _classCallCheck(this, EyeDropperTool);

        var _this = _possibleConstructorReturn(this, (EyeDropperTool.__proto__ || Object.getPrototypeOf(EyeDropperTool)).call(this));

        var layer = isBitmap ? (0, _layer.getRaster)().layer : _paper2.default.project.activeLayer;
        var contentRaster3x = layer.rasterize(72 * ZOOM_SCALE * _paper2.default.view.zoom, false /* insert */, _paper2.default.view.bounds);
        var backgroundRaster3x = (0, _layer.getBackgroundGuideLayer)().rasterize(72 * ZOOM_SCALE * _paper2.default.view.zoom, false /* insert */, _paper2.default.view.bounds);

        // Canvas from which loupe is cut, shows art and grid
        _this.bufferCanvas = (0, _layer.createCanvas)(canvas.width * ZOOM_SCALE, canvas.height * ZOOM_SCALE);
        var bufferCanvasContext = _this.bufferCanvas.getContext('2d');
        // Canvas to sample colors from; just the art
        _this.colorCanvas = (0, _layer.createCanvas)(canvas.width * ZOOM_SCALE, canvas.height * ZOOM_SCALE);
        var colorCanvasContext = _this.colorCanvas.getContext('2d');

        backgroundRaster3x.onLoad = function () {
            bufferCanvasContext.drawImage(backgroundRaster3x.canvas, 0, 0);
            contentRaster3x.onLoad = function () {
                colorCanvasContext.drawImage(contentRaster3x.canvas, 0, 0);
                bufferCanvasContext.drawImage(_this.colorCanvas, 0, 0);
                _this.bufferLoaded = true;
            };
            if (contentRaster3x.loaded) contentRaster3x.onLoad();
        };

        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseUp = _this.handleMouseUp;
        _this.onMouseMove = _this.handleMouseMove;

        _this.canvas = canvas;
        _this.pixelRatio = pixelRatio;
        _this.zoom = zoom;
        _this.offsetX = offsetX;
        _this.offsetY = offsetY;
        _this.width = width * _this.zoom * _this.pixelRatio;
        _this.height = height * _this.zoom * _this.pixelRatio;
        _this.rect = canvas.getBoundingClientRect();
        _this.colorString = '';
        _this.pickX = -1;
        _this.pickY = -1;
        _this.hideLoupe = true;
        return _this;
    }

    _createClass(EyeDropperTool, [{
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            // Set the pickX/Y for the color picker loop to pick up
            this.pickX = (event.point.x - this.offsetX) * this.zoom * this.pixelRatio;
            this.pickY = (event.point.y - this.offsetY) * this.zoom * this.pixelRatio;

            // check if the x/y are outside of the canvas
            this.hideLoupe = this.pickX > this.width || this.pickX < 0 || this.pickY > this.height || this.pickY < 0;
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            // Nothing special on mousedown, just send to move handler which will show the loupe,
            // and the mouse up handler submits the color. This allows touch to drag
            // with the loupe visible to find the correct color
            this.handleMouseMove(event);
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp() {
            if (!this.hideLoupe) {
                var colorInfo = this.getColorInfo(this.pickX, this.pickY, this.hideLoupe);
                if (!colorInfo) return;
                if (colorInfo.color[3] === 0) {
                    // Alpha 0
                    this.colorString = null;
                    return;
                }
                var r = colorInfo.color[0];
                var g = colorInfo.color[1];
                var b = colorInfo.color[2];

                // from https://github.com/LLK/scratch-gui/blob/77e54a80a31b6cd4684d4b2a70f1aeec671f229e/src/containers/stage.jsx#L218-L222
                // formats the color info from the canvas into hex for parsing by the color picker
                var componentToString = function componentToString(c) {
                    var hex = c.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                this.colorString = '#' + componentToString(r) + componentToString(g) + componentToString(b);
            }
        }
    }, {
        key: 'getColorInfo',
        value: function getColorInfo(x, y, hideLoupe) {
            var artX = x / this.pixelRatio;
            var artY = y / this.pixelRatio;
            if (!this.bufferLoaded) return null;
            var colorContext = this.colorCanvas.getContext('2d');
            var bufferContext = this.bufferCanvas.getContext('2d');
            var colors = colorContext.getImageData(artX * ZOOM_SCALE, artY * ZOOM_SCALE, 1, 1);
            return {
                x: x,
                y: y,
                color: colors.data,
                data: bufferContext.getImageData(ZOOM_SCALE * (artX - LOUPE_RADIUS), ZOOM_SCALE * (artY - LOUPE_RADIUS), LOUPE_RADIUS * 2 * ZOOM_SCALE, LOUPE_RADIUS * 2 * ZOOM_SCALE).data,
                hideLoupe: hideLoupe
            };
        }
    }]);

    return EyeDropperTool;
}(_paper2.default.Tool);

exports.default = EyeDropperTool;
exports.LOUPE_RADIUS = LOUPE_RADIUS;
exports.ZOOM_SCALE = ZOOM_SCALE;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shouldShowSendBackward = exports.shouldShowBringForward = exports.sendBackward = exports.bringForward = exports.sendToBack = exports.bringToFront = undefined;

var _selection = __webpack_require__(3);

var bringToFront = function bringToFront(onUpdateImage) {
    var items = (0, _selection.getSelectedRootItems)();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            item.bringToFront();
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    onUpdateImage();
};

var sendToBack = function sendToBack(onUpdateImage) {
    var items = (0, _selection.getSelectedRootItems)();
    for (var i = items.length - 1; i >= 0; i--) {
        items[i].sendToBack();
    }
    onUpdateImage();
};

var bringForward = function bringForward(onUpdateImage) {
    var items = (0, _selection.getSelectedRootItems)();
    // Already at front
    if (items.length === 0 || !items[items.length - 1].nextSibling) {
        return;
    }

    var nextSibling = items[items.length - 1].nextSibling;
    for (var i = items.length - 1; i >= 0; i--) {
        items[i].insertAbove(nextSibling);
    }
    onUpdateImage();
};

var sendBackward = function sendBackward(onUpdateImage) {
    var items = (0, _selection.getSelectedRootItems)();
    // Already at front
    if (items.length === 0 || !items[0].previousSibling) {
        return;
    }

    var previousSibling = items[0].previousSibling;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var item = _step2.value;

            item.insertBelow(previousSibling);
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    onUpdateImage();
};

var shouldShowSendBackward = function shouldShowSendBackward() {
    var items = (0, _selection.getSelectedRootItems)();
    if (items.length === 0 || !items[0].previousSibling) {
        return false;
    }
    return true;
};

var shouldShowBringForward = function shouldShowBringForward() {
    var items = (0, _selection.getSelectedRootItems)();
    if (items.length === 0 || !items[items.length - 1].nextSibling) {
        return false;
    }
    return true;
};

exports.bringToFront = bringToFront;
exports.sendToBack = sendToBack;
exports.bringForward = bringForward;
exports.sendBackward = sendBackward;
exports.shouldShowBringForward = shouldShowBringForward;
exports.shouldShowSendBackward = shouldShowSendBackward;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _reactPopover = __webpack_require__(77);

var _reactPopover2 = _interopRequireDefault(_reactPopover);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _dropdown = __webpack_require__(184);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _dropdownCaret = __webpack_require__(186);

var _dropdownCaret2 = _interopRequireDefault(_dropdownCaret);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Dropdown = function (_React$Component) {
    _inherits(Dropdown, _React$Component);

    function Dropdown(props) {
        _classCallCheck(this, Dropdown);

        var _this = _possibleConstructorReturn(this, (Dropdown.__proto__ || Object.getPrototypeOf(Dropdown)).call(this, props));

        (0, _lodash2.default)(_this, ['handleClosePopover', 'handleToggleOpenState', 'isOpen']);
        _this.state = {
            isOpen: false
        };
        return _this;
    }

    _createClass(Dropdown, [{
        key: 'handleClosePopover',
        value: function handleClosePopover() {
            this.setState({
                isOpen: false
            });
        }
    }, {
        key: 'handleToggleOpenState',
        value: function handleToggleOpenState() {
            var newState = !this.state.isOpen;
            this.setState({
                isOpen: newState
            });
            if (newState && this.props.onOpen) {
                this.props.onOpen();
            }
        }
    }, {
        key: 'isOpen',
        value: function isOpen() {
            return this.state.isOpen;
        }
    }, {
        key: 'render',
        value: function render() {
            var _classNames;

            return _react2.default.createElement(
                _reactPopover2.default,
                _extends({
                    body: this.props.popoverContent,
                    isOpen: this.state.isOpen,
                    preferPlace: 'below',
                    onOuterAction: this.props.onOuterAction ? this.props.onOuterAction : this.handleClosePopover
                }, this.props),
                _react2.default.createElement(
                    'div',
                    {
                        className: (0, _classnames2.default)(_dropdown2.default.dropdown, this.props.className, (_classNames = {}, _defineProperty(_classNames, _dropdown2.default.modOpen, this.state.isOpen), _defineProperty(_classNames, _dropdown2.default.modClosed, !this.state.isOpen), _classNames)),
                        onClick: this.handleToggleOpenState
                    },
                    this.props.children,
                    _react2.default.createElement('img', {
                        className: (0, _classnames2.default)(_dropdown2.default.dropdownIcon, _defineProperty({}, _dropdown2.default.modCaretUp, this.state.isOpen)),
                        draggable: false,
                        src: _dropdownCaret2.default
                    })
                )
            );
        }
    }]);

    return Dropdown;
}(_react2.default.Component);

Dropdown.propTypes = {
    children: _propTypes2.default.node.isRequired,
    className: _propTypes2.default.string,
    onOpen: _propTypes2.default.func,
    onOuterAction: _propTypes2.default.func,
    popoverContent: _propTypes2.default.node.isRequired
};

exports.default = Dropdown;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var localeTooBig = ['ab', 'ca', 'cy', 'de', 'et', 'el', 'ga', 'gd', 'gl', 'mi', 'nl', 'ja', 'ja-Hira', 'nb', 'nn', 'rap', 'th', 'sr', 'sk', 'sl', 'fi', 'sv', 'sw', 'vi', 'tr', 'uk'];

var hideLabel = function hideLabel(locale) {
    return localeTooBig.includes(locale);
};

exports.hideLabel = hideLabel;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _lodash3 = __webpack_require__(45);

var _lodash4 = _interopRequireDefault(_lodash3);

var _reactRedux = __webpack_require__(6);

var _selection = __webpack_require__(3);

var _bitmap = __webpack_require__(21);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _selectedItems = __webpack_require__(7);

var _clipboard = __webpack_require__(49);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CopyPasteHOC = function CopyPasteHOC(WrappedComponent) {
    var CopyPasteWrapper = function (_React$Component) {
        _inherits(CopyPasteWrapper, _React$Component);

        function CopyPasteWrapper(props) {
            _classCallCheck(this, CopyPasteWrapper);

            var _this = _possibleConstructorReturn(this, (CopyPasteWrapper.__proto__ || Object.getPrototypeOf(CopyPasteWrapper)).call(this, props));

            (0, _lodash2.default)(_this, ['handleCopy', 'handlePaste']);
            return _this;
        }

        _createClass(CopyPasteWrapper, [{
            key: 'handleCopy',
            value: function handleCopy() {
                var selectedItems = [];
                if (this.props.mode === _modes2.default.RESHAPE) {
                    var leafItems = (0, _selection.getSelectedLeafItems)();
                    // Copy root of compound paths
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = leafItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var item = _step.value;

                            if (item.parent && item.parent instanceof _paper2.default.CompoundPath) {
                                selectedItems.push(item.parent);
                            } else {
                                selectedItems.push(item);
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                } else {
                    selectedItems = (0, _selection.getSelectedRootItems)();
                }
                if (selectedItems.length === 0) {
                    if ((0, _format.isBitmap)(this.props.format)) {
                        var raster = (0, _bitmap.getTrimmedRaster)(false /* shouldInsert */);
                        if (!raster) return;
                        selectedItems.push(raster);
                    } else {
                        selectedItems = (0, _selection.getAllRootItems)();
                    }
                }
                var clipboardItems = [];
                for (var i = 0; i < selectedItems.length; i++) {
                    var jsonItem = selectedItems[i].exportJSON({ asString: false });
                    clipboardItems.push(jsonItem);
                }
                this.props.setClipboardItems(clipboardItems);
            }
        }, {
            key: 'handlePaste',
            value: function handlePaste() {
                (0, _selection.clearSelection)(this.props.clearSelectedItems);

                if (this.props.clipboardItems.length === 0) return;

                var items = [];
                for (var i = 0; i < this.props.clipboardItems.length; i++) {
                    var item = _paper2.default.Base.importJSON(this.props.clipboardItems[i]);
                    if (item) {
                        items.push(item);
                    }
                }
                if (!items.length) return;
                // If pasting a group or non-raster to bitmap, rasterize first
                if ((0, _format.isBitmap)(this.props.format) && !(items.length === 1 && items[0] instanceof _paper2.default.Raster)) {
                    var group = new _paper2.default.Group(items);
                    items = [group.rasterize()];
                    group.remove();
                }
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var _item = _step2.value;

                        var placedItem = _paper2.default.project.getActiveLayer().addChild(_item);
                        placedItem.selected = true;
                        placedItem.position.x += 10 * this.props.pasteOffset;
                        placedItem.position.y += 10 * this.props.pasteOffset;
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                this.props.incrementPasteOffset();
                this.props.setSelectedItems(this.props.format);
                this.props.onUpdateImage();
            }
        }, {
            key: 'render',
            value: function render() {
                var componentProps = (0, _lodash4.default)(this.props, ['clearSelectedItems', 'clipboardItems', 'format', 'incrementPasteOffset', 'mode', 'pasteOffset', 'setClipboardItems', 'setSelectedItems']);
                return _react2.default.createElement(WrappedComponent, _extends({
                    onCopyToClipboard: this.handleCopy,
                    onPasteFromClipboard: this.handlePaste
                }, componentProps));
            }
        }]);

        return CopyPasteWrapper;
    }(_react2.default.Component);

    CopyPasteWrapper.propTypes = {
        clearSelectedItems: _propTypes2.default.func.isRequired,
        clipboardItems: _propTypes2.default.arrayOf(_propTypes2.default.array),
        format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
        incrementPasteOffset: _propTypes2.default.func.isRequired,
        mode: _propTypes2.default.oneOf(Object.keys(_modes2.default)),
        onUpdateImage: _propTypes2.default.func.isRequired,
        pasteOffset: _propTypes2.default.number,
        setClipboardItems: _propTypes2.default.func.isRequired,
        setSelectedItems: _propTypes2.default.func.isRequired
    };
    var mapStateToProps = function mapStateToProps(state) {
        return {
            clipboardItems: state.scratchPaint.clipboard.items,
            format: state.scratchPaint.format,
            mode: state.scratchPaint.mode,
            pasteOffset: state.scratchPaint.clipboard.pasteOffset
        };
    };
    var mapDispatchToProps = function mapDispatchToProps(dispatch) {
        return {
            setClipboardItems: function setClipboardItems(items) {
                dispatch((0, _clipboard.setClipboardItems)(items));
            },
            incrementPasteOffset: function incrementPasteOffset() {
                dispatch((0, _clipboard.incrementPasteOffset)());
            },
            clearSelectedItems: function clearSelectedItems() {
                dispatch((0, _selectedItems.clearSelectedItems)());
            },
            setSelectedItems: function setSelectedItems(format) {
                dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), (0, _format.isBitmap)(format)));
            }
        };
    };

    return (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(CopyPasteWrapper);
};

exports.default = CopyPasteHOC;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeBrushSize = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_BRUSH_SIZE = 'scratch-paint/brush-mode/CHANGE_BRUSH_SIZE';
var initialState = { brushSize: 10 };

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_BRUSH_SIZE:
            if (isNaN(action.brushSize)) {
                _log2.default.warn('Invalid brush size: ' + action.brushSize);
                return state;
            }
            return { brushSize: Math.max(1, action.brushSize) };
        default:
            return state;
    }
};

// Action creators ==================================
var changeBrushSize = function changeBrushSize(brushSize) {
    return {
        type: CHANGE_BRUSH_SIZE,
        brushSize: brushSize
    };
};

exports.default = reducer;
exports.changeBrushSize = changeBrushSize;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeBitBrushSize = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _selectedItems = __webpack_require__(7);

var _stylePath = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Bit brush size affects bit brush width, circle/rectangle outline drawing width, and line width
// in the bitmap paint editor.
var CHANGE_BIT_BRUSH_SIZE = 'scratch-paint/brush-mode/CHANGE_BIT_BRUSH_SIZE';
var initialState = 10;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_BIT_BRUSH_SIZE:
            if (isNaN(action.brushSize)) {
                _log2.default.warn('Invalid brush size: ' + action.brushSize);
                return state;
            }
            return Math.max(1, action.brushSize);
        case _selectedItems.CHANGE_SELECTED_ITEMS:
            {
                // Don't change state if no selection
                if (!action.selectedItems || !action.selectedItems.length) {
                    return state;
                }
                // Vector mode doesn't have bit width
                if (!action.bitmapMode) {
                    return state;
                }
                var colorState = (0, _stylePath.getColorsFromSelection)(action.selectedItems, action.bitmapMode);
                if (colorState.thickness) return colorState.thickness;
                return state;
            }
        default:
            return state;
    }
};

// Action creators ==================================
var changeBitBrushSize = function changeBitBrushSize(brushSize) {
    return {
        type: CHANGE_BIT_BRUSH_SIZE,
        brushSize: brushSize
    };
};

exports.default = reducer;
exports.changeBitBrushSize = changeBitBrushSize;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeBitEraserSize = exports.default = undefined;

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANGE_BIT_ERASER_SIZE = 'scratch-paint/eraser-mode/CHANGE_BIT_ERASER_SIZE';
var initialState = 40;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case CHANGE_BIT_ERASER_SIZE:
            if (isNaN(action.eraserSize)) {
                _log2.default.warn('Invalid eraser size: ' + action.eraserSize);
                return state;
            }
            return Math.max(1, action.eraserSize);
        default:
            return state;
    }
};

// Action creators ==================================
var changeBitEraserSize = function changeBitEraserSize(eraserSize) {
    return {
        type: CHANGE_BIT_ERASER_SIZE,
        eraserSize: eraserSize
    };
};

exports.default = reducer;
exports.changeBitEraserSize = changeBitEraserSize;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setShapesFilled = exports.default = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _selectedItems = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SET_FILLED = 'scratch-paint/fill-bitmap-shapes/SET_FILLED';
var initialState = true;

var reducer = function reducer(state, action) {
    if (typeof state === 'undefined') state = initialState;
    switch (action.type) {
        case SET_FILLED:
            return action.filled;
        case _selectedItems.CHANGE_SELECTED_ITEMS:
            if (action.bitmapMode && action.selectedItems && action.selectedItems[0] instanceof _paper2.default.Shape) {
                return action.selectedItems[0].strokeWidth === 0;
            }
            return state;
        default:
            return state;
    }
};

// Action creators ==================================
var setShapesFilled = function setShapesFilled(filled) {
    return {
        type: SET_FILLED,
        filled: filled
    };
};

exports.default = reducer;
exports.setShapesFilled = setShapesFilled;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(204);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function (Input) {
    var LiveInput = function (_React$Component) {
        _inherits(LiveInput, _React$Component);

        function LiveInput(props) {
            _classCallCheck(this, LiveInput);

            var _this = _possibleConstructorReturn(this, (LiveInput.__proto__ || Object.getPrototypeOf(LiveInput)).call(this, props));

            (0, _lodash2.default)(_this, ['handleChange', 'handleKeyPress', 'handleFlush']);
            _this.state = {
                value: null
            };
            return _this;
        }

        _createClass(LiveInput, [{
            key: 'handleKeyPress',
            value: function handleKeyPress(e) {
                if (e.key === 'Enter') {
                    this.handleChange(e);
                    e.target.blur();
                }
            }
        }, {
            key: 'handleFlush',
            value: function handleFlush() {
                this.setState({ value: null });
            }
        }, {
            key: 'handleChange',
            value: function handleChange(e) {
                var isNumeric = typeof this.props.value === 'number';
                var validatesNumeric = isNumeric ? !isNaN(e.target.value) : true;
                if (e.target.value !== null && validatesNumeric) {
                    var val = Number(e.target.value);
                    if (typeof this.props.max !== 'undefined' && val > Number(this.props.max)) {
                        val = this.props.max;
                    }
                    if (typeof this.props.min !== 'undefined' && val < Number(this.props.min)) {
                        val = this.props.min;
                    }
                    this.props.onSubmit(val);
                }
                this.setState({ value: e.target.value });
            }
        }, {
            key: 'render',
            value: function render() {
                var liveValue = this.state.value === null ? this.props.value : this.state.value;
                return _react2.default.createElement(Input, _extends({}, this.props, {
                    value: liveValue,
                    onBlur: this.handleFlush,
                    onChange: this.handleChange,
                    onKeyPress: this.handleKeyPress
                }));
            }
        }]);

        return LiveInput;
    }(_react2.default.Component);

    LiveInput.propTypes = {
        max: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
        min: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
        onSubmit: _propTypes2.default.func.isRequired,
        value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])
    };

    return LiveInput;
};

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Higher Order Component to manage inputs that submit on change and <enter>
 * @param {React.Component} Input text input that consumes onChange, onBlur, onKeyPress
 * @returns {React.Component} Live input that calls onSubmit on change and <enter>
 */

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScratchPaintReducer = exports.default = undefined;

var _paintEditor = __webpack_require__(93);

var _paintEditor2 = _interopRequireDefault(_paintEditor);

var _scratchPaintReducer = __webpack_require__(253);

var _scratchPaintReducer2 = _interopRequireDefault(_scratchPaintReducer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _paintEditor2.default;
exports.ScratchPaintReducer = _scratchPaintReducer2.default;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _paintEditor = __webpack_require__(98);

var _paintEditor2 = _interopRequireDefault(_paintEditor);

var _keyboardShortcutsHoc = __webpack_require__(249);

var _keyboardShortcutsHoc2 = _interopRequireDefault(_keyboardShortcutsHoc);

var _selectionHoc = __webpack_require__(250);

var _selectionHoc2 = _interopRequireDefault(_selectionHoc);

var _undoHoc = __webpack_require__(251);

var _undoHoc2 = _interopRequireDefault(_undoHoc);

var _updateImageHoc = __webpack_require__(252);

var _updateImageHoc2 = _interopRequireDefault(_updateImageHoc);

var _modes = __webpack_require__(10);

var _format = __webpack_require__(40);

var _selectedItems = __webpack_require__(7);

var _eyeDropper = __webpack_require__(39);

var _textEditTarget = __webpack_require__(44);

var _viewBounds = __webpack_require__(37);

var _layout = __webpack_require__(56);

var _selection = __webpack_require__(3);

var _bitmap = __webpack_require__(21);

var _view = __webpack_require__(22);

var _eyeDropper2 = __webpack_require__(81);

var _eyeDropper3 = _interopRequireDefault(_eyeDropper2);

var _modes2 = __webpack_require__(4);

var _modes3 = _interopRequireDefault(_modes2);

var _format2 = __webpack_require__(11);

var _format3 = _interopRequireDefault(_format2);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The top-level paint editor component. See README for more details on usage.
 *
 * <PaintEditor
 *     image={optionalImage}
 *     imageId={optionalId}
 *     imageFormat='svg'
 *     rotationCenterX={optionalCenterPointX}
 *     rotationCenterY={optionalCenterPointY}
 *     rtl={true|false}
 *     onUpdateImage={handleUpdateImageFunction}
 *     zoomLevelId={optionalZoomLevelId}
 * />
 *
 * `image`: may either be nothing, an SVG string or a base64 data URI)
 * SVGs of up to size 480 x 360 will fit into the view window of the paint editor,
 * while bitmaps of size up to 960 x 720 will fit into the paint editor. One unit
 * of an SVG will appear twice as tall and wide as one unit of a bitmap. This quirky
 * import behavior comes from needing to support legacy projects in Scratch.
 *
 * `imageId`: If this parameter changes, then the paint editor will be cleared, the
 * undo stack reset, and the image re-imported.
 *
 * `imageFormat`: 'svg', 'png', or 'jpg'. Other formats are currently not supported.
 *
 * `rotationCenterX`: x coordinate relative to the top left corner of the sprite of
 * the point that should be centered.
 *
 * `rotationCenterY`: y coordinate relative to the top left corner of the sprite of
 * the point that should be centered.
 *
 * `rtl`: True if the paint editor should be laid out right to left (meant for right
 * to left languages)
 *
 * `onUpdateImage`: A handler called with the new image (either an SVG string or an
 * ImageData) each time the drawing is edited.
 *
 * `zoomLevelId`: All costumes with the same zoom level ID will share the same saved
 * zoom level. When a new zoom level ID is encountered, the paint editor will zoom to
 * fit the current costume comfortably. Leave undefined to perform no zoom to fit.
 */
var PaintEditor = function (_React$Component) {
    _inherits(PaintEditor, _React$Component);

    _createClass(PaintEditor, null, [{
        key: 'ZOOM_INCREMENT',
        get: function get() {
            return 0.5;
        }
    }]);

    function PaintEditor(props) {
        _classCallCheck(this, PaintEditor);

        var _this = _possibleConstructorReturn(this, (PaintEditor.__proto__ || Object.getPrototypeOf(PaintEditor)).call(this, props));

        (0, _lodash2.default)(_this, ['switchModeForFormat', 'onMouseDown', 'onMouseUp', 'setCanvas', 'setTextArea', 'startEyeDroppingLoop', 'stopEyeDroppingLoop', 'handleSetSelectedItems', 'handleZoomIn', 'handleZoomOut', 'handleZoomReset']);
        _this.state = {
            canvas: null,
            colorInfo: null
        };
        _this.props.setLayout(_this.props.rtl ? 'rtl' : 'ltr');
        return _this;
    }

    _createClass(PaintEditor, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            document.addEventListener('keydown', this.props.onKeyPress);

            // document listeners used to detect if a mouse is down outside of the
            // canvas, and should therefore stop the eye dropper
            document.addEventListener('mousedown', this.onMouseDown);
            document.addEventListener('touchstart', this.onMouseDown);
            document.addEventListener('mouseup', this.onMouseUp);
            document.addEventListener('touchend', this.onMouseUp);
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(newProps) {
            if (!(0, _format2.isBitmap)(this.props.format) && (0, _format2.isBitmap)(newProps.format)) {
                this.switchModeForFormat(_format3.default.BITMAP);
            } else if (!(0, _format2.isVector)(this.props.format) && (0, _format2.isVector)(newProps.format)) {
                this.switchModeForFormat(_format3.default.VECTOR);
            }
            if (newProps.rtl !== this.props.rtl) {
                this.props.setLayout(newProps.rtl ? 'rtl' : 'ltr');
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps) {
            if (this.props.isEyeDropping && !prevProps.isEyeDropping) {
                this.startEyeDroppingLoop();
            } else if (!this.props.isEyeDropping && prevProps.isEyeDropping) {
                this.stopEyeDroppingLoop();
            } else if (this.props.isEyeDropping && this.props.viewBounds !== prevProps.viewBounds) {
                if (this.props.previousTool) this.props.previousTool.activate();
                this.props.onDeactivateEyeDropper();
                this.stopEyeDroppingLoop();
            }

            if (this.props.format === _format3.default.VECTOR && (0, _format2.isBitmap)(prevProps.format)) {
                (0, _bitmap.convertToVector)(this.props.clearSelectedItems, this.props.onUpdateImage);
            } else if ((0, _format2.isVector)(prevProps.format) && this.props.format === _format3.default.BITMAP) {
                (0, _bitmap.convertToBitmap)(this.props.clearSelectedItems, this.props.onUpdateImage, this.props.fontInlineFn);
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            document.removeEventListener('keydown', this.props.onKeyPress);
            this.stopEyeDroppingLoop();
            document.removeEventListener('mousedown', this.onMouseDown);
            document.removeEventListener('touchstart', this.onMouseDown);
            document.removeEventListener('mouseup', this.onMouseUp);
            document.removeEventListener('touchend', this.onMouseUp);
        }
    }, {
        key: 'switchModeForFormat',
        value: function switchModeForFormat(newFormat) {
            if ((0, _format2.isVector)(newFormat) && this.props.mode in _modes2.VectorModes || (0, _format2.isBitmap)(newFormat) && this.props.mode in _modes2.BitmapModes) {
                // Format didn't change; no mode change needed
                return;
            }
            if ((0, _format2.isVector)(newFormat)) {
                switch (this.props.mode) {
                    case _modes3.default.BIT_BRUSH:
                        this.props.changeMode(_modes3.default.BRUSH);
                        break;
                    case _modes3.default.BIT_LINE:
                        this.props.changeMode(_modes3.default.LINE);
                        break;
                    case _modes3.default.BIT_OVAL:
                        this.props.changeMode(_modes3.default.OVAL);
                        break;
                    case _modes3.default.BIT_RECT:
                        this.props.changeMode(_modes3.default.RECT);
                        break;
                    case _modes3.default.BIT_TEXT:
                        this.props.changeMode(_modes3.default.TEXT);
                        break;
                    case _modes3.default.BIT_FILL:
                        this.props.changeMode(_modes3.default.FILL);
                        break;
                    case _modes3.default.BIT_ERASER:
                        this.props.changeMode(_modes3.default.ERASER);
                        break;
                    case _modes3.default.BIT_SELECT:
                        this.props.changeMode(_modes3.default.SELECT);
                        break;
                    default:
                        _log2.default.error('Mode not handled: ' + this.props.mode);
                        this.props.changeMode(_modes3.default.BRUSH);
                }
            } else if ((0, _format2.isBitmap)(newFormat)) {
                switch (this.props.mode) {
                    case _modes3.default.BRUSH:
                        this.props.changeMode(_modes3.default.BIT_BRUSH);
                        break;
                    case _modes3.default.LINE:
                        this.props.changeMode(_modes3.default.BIT_LINE);
                        break;
                    case _modes3.default.OVAL:
                        this.props.changeMode(_modes3.default.BIT_OVAL);
                        break;
                    case _modes3.default.RECT:
                        this.props.changeMode(_modes3.default.BIT_RECT);
                        break;
                    case _modes3.default.TEXT:
                        this.props.changeMode(_modes3.default.BIT_TEXT);
                        break;
                    case _modes3.default.FILL:
                        this.props.changeMode(_modes3.default.BIT_FILL);
                        break;
                    case _modes3.default.ERASER:
                        this.props.changeMode(_modes3.default.BIT_ERASER);
                        break;
                    case _modes3.default.RESHAPE:
                    /* falls through */
                    case _modes3.default.SELECT:
                        this.props.changeMode(_modes3.default.BIT_SELECT);
                        break;
                    default:
                        _log2.default.error('Mode not handled: ' + this.props.mode);
                        this.props.changeMode(_modes3.default.BIT_BRUSH);
                }
            }
        }
    }, {
        key: 'handleZoomIn',
        value: function handleZoomIn() {
            // Make the "next step" after the outermost zoom level be the default
            // zoom level (0.5)
            var zoomIncrement = PaintEditor.ZOOM_INCREMENT;
            if (_paper2.default.view.zoom === _view.OUTERMOST_ZOOM_LEVEL) {
                zoomIncrement = 0.5 - _view.OUTERMOST_ZOOM_LEVEL;
            }
            (0, _view.zoomOnSelection)(zoomIncrement);
            this.props.updateViewBounds(_paper2.default.view.matrix);
            this.handleSetSelectedItems();
        }
    }, {
        key: 'handleZoomOut',
        value: function handleZoomOut() {
            (0, _view.zoomOnSelection)(-PaintEditor.ZOOM_INCREMENT);
            this.props.updateViewBounds(_paper2.default.view.matrix);
            this.handleSetSelectedItems();
        }
    }, {
        key: 'handleZoomReset',
        value: function handleZoomReset() {
            (0, _view.resetZoom)();
            this.props.updateViewBounds(_paper2.default.view.matrix);
            this.handleSetSelectedItems();
        }
    }, {
        key: 'handleSetSelectedItems',
        value: function handleSetSelectedItems() {
            this.props.setSelectedItems(this.props.format);
        }
    }, {
        key: 'setCanvas',
        value: function setCanvas(canvas) {
            this.setState({ canvas: canvas });
            this.canvas = canvas;
        }
    }, {
        key: 'setTextArea',
        value: function setTextArea(element) {
            this.setState({ textArea: element });
        }
    }, {
        key: 'onMouseDown',
        value: function onMouseDown(event) {
            if (event.target === _paper2.default.view.element && document.activeElement instanceof HTMLInputElement) {
                document.activeElement.blur();
            }

            if (event.target !== _paper2.default.view.element && event.target !== this.state.textArea) {
                // Exit text edit mode if you click anywhere outside of canvas
                this.props.removeTextEditTarget();
            }
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp() {
            if (this.props.isEyeDropping) {
                var colorString = this.eyeDropper.colorString;
                var callback = this.props.changeColorToEyeDropper;

                this.eyeDropper.remove();
                if (!this.eyeDropper.hideLoupe) {
                    // If not hide loupe, that means the click is inside the canvas,
                    // so apply the new color
                    callback(colorString);
                }
                if (this.props.previousTool) this.props.previousTool.activate();
                this.props.onDeactivateEyeDropper();
                this.stopEyeDroppingLoop();
            }
        }
    }, {
        key: 'startEyeDroppingLoop',
        value: function startEyeDroppingLoop() {
            var _this2 = this;

            this.eyeDropper = new _eyeDropper3.default(this.canvas, _paper2.default.project.view.bounds.width, _paper2.default.project.view.bounds.height, _paper2.default.project.view.pixelRatio, _paper2.default.view.zoom, _paper2.default.project.view.bounds.x, _paper2.default.project.view.bounds.y, (0, _format2.isBitmap)(this.props.format));
            this.eyeDropper.pickX = -1;
            this.eyeDropper.pickY = -1;
            this.eyeDropper.activate();

            this.intervalId = setInterval(function () {
                var colorInfo = _this2.eyeDropper.getColorInfo(_this2.eyeDropper.pickX, _this2.eyeDropper.pickY, _this2.eyeDropper.hideLoupe);
                if (!colorInfo) return;
                if (_this2.state.colorInfo === null || _this2.state.colorInfo.x !== colorInfo.x || _this2.state.colorInfo.y !== colorInfo.y) {
                    _this2.setState({
                        colorInfo: colorInfo
                    });
                }
            }, 30);
        }
    }, {
        key: 'stopEyeDroppingLoop',
        value: function stopEyeDroppingLoop() {
            clearInterval(this.intervalId);
            this.setState({ colorInfo: null });
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_paintEditor2.default, {
                canRedo: this.props.shouldShowRedo,
                canUndo: this.props.shouldShowUndo,
                canvas: this.state.canvas,
                colorInfo: this.state.colorInfo,
                format: this.props.format,
                image: this.props.image,
                imageFormat: this.props.imageFormat,
                imageId: this.props.imageId,
                isEyeDropping: this.props.isEyeDropping,
                name: this.props.name,
                rotationCenterX: this.props.rotationCenterX,
                rotationCenterY: this.props.rotationCenterY,
                rtl: this.props.rtl,
                setCanvas: this.setCanvas,
                setTextArea: this.setTextArea,
                textArea: this.state.textArea,
                zoomLevelId: this.props.zoomLevelId,
                onRedo: this.props.onRedo,
                onSwitchToBitmap: this.props.handleSwitchToBitmap,
                onSwitchToVector: this.props.handleSwitchToVector,
                onUndo: this.props.onUndo,
                onUpdateImage: this.props.onUpdateImage,
                onUpdateName: this.props.onUpdateName,
                onZoomIn: this.handleZoomIn,
                onZoomOut: this.handleZoomOut,
                onZoomReset: this.handleZoomReset
            });
        }
    }]);

    return PaintEditor;
}(_react2.default.Component);

PaintEditor.propTypes = {
    changeColorToEyeDropper: _propTypes2.default.func,
    changeMode: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    format: _propTypes2.default.oneOf(Object.keys(_format3.default)), // Internal, up-to-date data format
    fontInlineFn: _propTypes2.default.func,
    handleSwitchToBitmap: _propTypes2.default.func.isRequired,
    handleSwitchToVector: _propTypes2.default.func.isRequired,
    image: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.instanceOf(HTMLImageElement)]),
    imageFormat: _propTypes2.default.string, // The incoming image's data format, used during import
    imageId: _propTypes2.default.string,
    isEyeDropping: _propTypes2.default.bool,
    mode: _propTypes2.default.oneOf(Object.keys(_modes3.default)).isRequired,
    name: _propTypes2.default.string,
    onDeactivateEyeDropper: _propTypes2.default.func.isRequired,
    onKeyPress: _propTypes2.default.func.isRequired,
    onRedo: _propTypes2.default.func.isRequired,
    onUndo: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    onUpdateName: _propTypes2.default.func.isRequired,
    previousTool: _propTypes2.default.shape({ // paper.Tool
        activate: _propTypes2.default.func.isRequired,
        remove: _propTypes2.default.func.isRequired
    }),
    removeTextEditTarget: _propTypes2.default.func.isRequired,
    rotationCenterX: _propTypes2.default.number,
    rotationCenterY: _propTypes2.default.number,
    rtl: _propTypes2.default.bool,
    setLayout: _propTypes2.default.func.isRequired,
    setSelectedItems: _propTypes2.default.func.isRequired,
    shouldShowRedo: _propTypes2.default.func.isRequired,
    shouldShowUndo: _propTypes2.default.func.isRequired,
    updateViewBounds: _propTypes2.default.func.isRequired,
    viewBounds: _propTypes2.default.instanceOf(_paper2.default.Matrix).isRequired,
    zoomLevelId: _propTypes2.default.string
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        changeColorToEyeDropper: state.scratchPaint.color.eyeDropper.callback,
        format: state.scratchPaint.format,
        isEyeDropping: state.scratchPaint.color.eyeDropper.active,
        mode: state.scratchPaint.mode,
        previousTool: state.scratchPaint.color.eyeDropper.previousTool,
        viewBounds: state.scratchPaint.viewBounds
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        changeMode: function changeMode(mode) {
            dispatch((0, _modes.changeMode)(mode));
        },
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        handleSwitchToBitmap: function handleSwitchToBitmap() {
            dispatch((0, _format.changeFormat)(_format3.default.BITMAP));
        },
        handleSwitchToVector: function handleSwitchToVector() {
            dispatch((0, _format.changeFormat)(_format3.default.VECTOR));
        },
        removeTextEditTarget: function removeTextEditTarget() {
            dispatch((0, _textEditTarget.setTextEditTarget)());
        },
        setLayout: function setLayout(layout) {
            dispatch((0, _layout.setLayout)(layout));
        },
        setSelectedItems: function setSelectedItems(format) {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), (0, _format2.isBitmap)(format)));
        },
        onDeactivateEyeDropper: function onDeactivateEyeDropper() {
            // set redux values to default for eye dropper reducer
            dispatch((0, _eyeDropper.deactivateEyeDropper)());
        },
        updateViewBounds: function updateViewBounds(matrix) {
            dispatch((0, _viewBounds.updateViewBounds)(matrix));
        }
    };
};

exports.default = (0, _updateImageHoc2.default)((0, _selectionHoc2.default)((0, _undoHoc2.default)((0, _keyboardShortcutsHoc2.default)((0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(PaintEditor)))));

/***/ }),
/* 94 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 95 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SourceLocation", function() { return SourceLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokContext", function() { return TokContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOptions", function() { return defaultOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineInfo", function() { return getLineInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierChar", function() { return isIdentifierChar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierStart", function() { return isIdentifierStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNewLine", function() { return isNewLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keywordTypes", function() { return keywords; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreak", function() { return lineBreak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreakG", function() { return lineBreakG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonASCIIwhitespace", function() { return nonASCIIwhitespace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseExpressionAt", function() { return parseExpressionAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokContexts", function() { return types; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokTypes", function() { return types$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenizer", function() { return tokenizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
// This file was generated. Do not modify manually!
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

// This file was generated. Do not modify manually!
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];

// This file was generated. Do not modify manually!
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

// This file was generated. Do not modify manually!
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

// These are a run-length and offset encoded representation of the

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords[name] = new TokenType(name, options)
}

var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),
  coalesce: binop("??", 1),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
}

function nextLineBreak(code, from, end) {
  if ( end === void 0 ) end = code.length;

  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next))
      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
  }
  return -1
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

var hasOwn = Object.hasOwn || (function (obj, propName) { return (
  hasOwnProperty.call(obj, propName)
); });

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    var nextBreak = nextLineBreak(input, cur, offset);
    if (nextBreak < 0) { return new Position(line, offset - cur) }
    ++line;
    cur = nextBreak;
  }
}

// A second argument must be given to configure the parser process.
// These options are recognized (only `ecmaVersion` is required):

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

var warnedAboutEcmaVersion = false;

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (opts.allowHashBang == null)
    { options.allowHashBang = options.ecmaVersion >= 14; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128,
    SCOPE_CLASS_STATIC_BLOCK = 256,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal* and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types$1.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = Object.create(null);

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;

  // The stack of private names.
  // Each element has two properties: 'declared' and 'used'.
  // When it exited from the outermost class definition, all used private names must be declared.
  this.privateNameStack = [];
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

prototypeAccessors.canAwait.get = function () {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
    if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
  }
  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
};

prototypeAccessors.allowSuper.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
    var inClassFieldInit = ref.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
};

prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

prototypeAccessors.allowNewDotTarget.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
    var inClassFieldInit = ref.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
};

prototypeAccessors.inClassStaticBlock.get = function () {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
};

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp$9 = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) { return false }
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" ||
        (lineBreak.test(spaceAfter[0]) &&
         !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
    }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof ||
    this.type === types$1.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

var DestructuringErrors = function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
};

pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
};

pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$8 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$8.parseTopLevel = function(node) {
  var exports = Object.create(null);
  if (!node.body) { node.body = []; }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91 || nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '[', '/', astral
  if (context) { return false }

  if (nextCh === 123) { return true } // '{'
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
    if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length ||
     !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types$1._debugger: return this.parseDebuggerStatement(node)
  case types$1._do: return this.parseDoStatement(node)
  case types$1._for: return this.parseForStatement(node)
  case types$1._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types$1._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types$1._if: return this.parseIfStatement(node)
  case types$1._return: return this.parseReturnStatement(node)
  case types$1._switch: return this.parseSwitchStatement(node)
  case types$1._throw: return this.parseThrowStatement(node)
  case types$1._try: return this.parseTryStatement(node)
  case types$1._const: case types$1._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types$1._while: return this.parseWhileStatement(node)
  case types$1._with: return this.parseWithStatement(node)
  case types$1.braceL: return this.parseBlock(true, node)
  case types$1.semi: return this.parseEmptyStatement(node)
  case types$1._export:
  case types$1._import:
    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40 || nextCh === 46) // '(' or '.'
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types$1.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types$1.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR;) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty$1 = [];

pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$8.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$8.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) { this.strict = false; }
  this.next();
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$8.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) { break }
  }
  return node
};

pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types$1.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$8.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) { return null }

  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;

  if (this.eatContextual("static")) {
    // Parse static init block
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }

  // Parse element name
  if (keyName) {
    // 'async', 'get', 'set', or 'static' were not a keyword contextually.
    // The last token is any of those. Make it the element name.
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }

  // Parse element value
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
    if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }

  return node
};

pp$8.isClassElementNameStart = function() {
  return (
    this.type === types$1.name ||
    this.type === types$1.privateId ||
    this.type === types$1.num ||
    this.type === types$1.string ||
    this.type === types$1.bracketL ||
    this.type.keyword
  )
};

pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};

pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  // Check key and flags
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }

  // Parse value
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

  // Check value
  if (method.kind === "get" && value.params.length !== 0)
    { this.raiseRecoverable(value.start, "getter should have no params"); }
  if (method.kind === "set" && value.params.length !== 1)
    { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && value.params[0].type === "RestElement")
    { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

  return this.finishNode(method, "MethodDefinition")
};

pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }

  if (this.eat(types$1.eq)) {
    // To raise SyntaxError if 'arguments' exists in the initializer.
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();

  return this.finishNode(field, "PropertyDefinition")
};

pp$8.parseClassStaticBlock = function(node) {
  node.body = [];

  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;

  return this.finishNode(node, "StaticBlock")
};

pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
};

pp$8.enterClassBody = function() {
  var element = {declared: Object.create(null), used: []};
  this.privateNameStack.push(element);
  return element.declared
};

pp$8.exitClassBody = function() {
  var ref = this.privateNameStack.pop();
  var declared = ref.declared;
  var used = ref.used;
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
      }
    }
  }
};

function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];

  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }

  // `class { get #a(){}; static set #a(_){} }` is also conflict.
  if (
    curr === "iget" && next === "iset" ||
    curr === "iset" && next === "iget" ||
    curr === "sget" && next === "sset" ||
    curr === "sset" && next === "sget"
  ) {
    privateNameMap[name] = "true";
    return false
  } else if (!curr) {
    privateNameMap[name] = next;
    return false
  } else {
    return true
  }
}

function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (
    key.type === "Identifier" && key.name === name ||
    key.type === "Literal" && key.value === name
  )
}

// Parses module export declaration.

pp$8.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types$1.star)) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node.exported = this.parseModuleExportName();
        this.checkExport(exports, node.exported, this.lastTokStart);
      } else {
        node.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types$1._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);

        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$8.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (typeof name !== "string")
    { name = name.type === "Identifier" ? name.name : name.value; }
  if (hasOwn(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
};

pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseModuleExportName();
    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
    this.checkExport(
      exports,
      node.exported,
      node.exported.start
    );
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$8.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLValSimple(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types$1.comma)) { return nodes }
  }
  if (this.type === types$1.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLValSimple(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLValSimple(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral
  }
  return this.parseIdent(true)
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return (
    this.options.ecmaVersion >= 5 &&
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$7 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "AssignmentPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "ChainExpression":
      this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types$1.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types$1.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types$1.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types$1.comma); }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$7.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// The following three functions all verify that a node is an lvalue —
// something that can be bound, or assigned to. In order to do so, they perform
// a variety of checks:
//
// - Check that none of the bound/assigned-to identifiers are reserved words.
// - Record name declarations for bindings in the appropriate scope.
// - Check duplicate argument names, if checkClashes is set.
//
// If a complex binding pattern is encountered (e.g., object and array
// destructuring), the entire pattern is recursively checked.
//
// There are three versions of checkLVal*() appropriate for different
// circumstances:
//
// - checkLValSimple() shall be used if the syntactic construct supports
//   nothing other than identifiers and member expressions. Parenthesized
//   expressions are also correctly handled. This is generally appropriate for
//   constructs for which the spec says
//
//   > It is a Syntax Error if AssignmentTargetType of [the production] is not
//   > simple.
//
//   It is also appropriate for checking if an identifier is valid and not
//   defined elsewhere, like import declarations or function/class identifiers.
//
//   Examples where this is used include:
//     a += …;
//     import a from '…';
//   where a is the node to be checked.
//
// - checkLValPattern() shall be used if the syntactic construct supports
//   anything checkLValSimple() supports, as well as object and array
//   destructuring patterns. This is generally appropriate for constructs for
//   which the spec says
//
//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
//   > an ArrayLiteral and AssignmentTargetType of [the production] is not
//   > simple.
//
//   Examples where this is used include:
//     (a = …);
//     const a = …;
//     try { … } catch (a) { … }
//   where a is the node to be checked.
//
// - checkLValInnerPattern() shall be used if the syntactic construct supports
//   anything checkLValPattern() supports, as well as default assignment
//   patterns, rest elements, and other constructs that may appear within an
//   object or array destructuring pattern.
//
//   As a special case, function parameters also use checkLValInnerPattern(),
//   as they also support defaults and rest constructs.
//
// These functions deliberately support both assignment and binding constructs,
// as the logic for both is exceedingly similar. If the node is the target of
// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
// should be set to the appropriate BIND_* constant, like BIND_VAR or
// BIND_LEXICAL.
//
// If the function is called with a non-BIND_NONE bindingType, then
// additionally a checkClashes object may be specified to allow checking for
// duplicate argument names. checkClashes is ignored if the provided construct
// is an assignment (i.e., bindingType is BIND_NONE).

pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  var isBind = bindingType !== BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (isBind) {
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (checkClashes) {
        if (hasOwn(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    }
    break

  case "ChainExpression":
    this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
    break

  case "MemberExpression":
    if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ParenthesizedExpression":
    if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
    return this.checkLValSimple(expr.expression, bindingType, checkClashes)

  default:
    this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};

pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1) {
      var prop = list[i];

    this.checkLValInnerPattern(prop, bindingType, checkClashes);
    }
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
    }
    break

  default:
    this.checkLValSimple(expr, bindingType, checkClashes);
  }
};

pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
    break

  case "AssignmentPattern":
    this.checkLValPattern(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLValPattern(expr.argument, bindingType, checkClashes);
    break

  default:
    this.checkLValPattern(expr, bindingType, checkClashes);
  }
};

// The algorithm used to determine whether a regexp can appear at a

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$6 = Parser.prototype;

pp$6.initialContext = function() {
  return [types.b_stat]
};

pp$6.curContext = function() {
  return this.context[this.context.length - 1]
};

pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat)
    { return true }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
    { return true }
  if (prevType === types$1.braceL)
    { return parent === types.b_stat }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
    { return false }
  return !this.exprAllowed
};

pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Used to handle egde cases when token context could not be inferred correctly during tokenization phase

pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};

// Token-specific context update code

types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

types$1.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else &&
      !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
    { this.context.push(types.f_expr); }
  else
    { this.context.push(types.f_stat); }
  this.exprAllowed = false;
};

types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types.q_tmpl); }
  this.exprAllowed = false;
};

types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr)
      { this.context[index] = types.f_expr_gen; }
    else
      { this.context[index] = types.f_gen; }
  }
  this.exprAllowed = true;
};

types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// A recursive descent parser operates by defining functions for all

var pp$5 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(forInit) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq)
      { left = this.toAssignable(left, false, refDestructuringErrors); }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start)
      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
    if (this.type === types$1.eq)
      { this.checkLValPattern(left); }
    else
      { this.checkLValSimple(left); }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
    }
  }
  return left
};

pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLValSimple(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
      { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if (forInit || this.privateNameStack.length === 0) { this.unexpected(); }
    expr = this.parsePrivateIdent();
    // only could be private fields in 'in', such as #x in obj
    if (this.type !== types$1._in) { this.unexpected(); }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary)
      { this.unexpected(this.lastTokStart); }
    else
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
  } else {
    return expr
  }
};

function isPrivateFieldAccess(node) {
  return (
    node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
    node.type === "ChainExpression" && isPrivateFieldAccess(node.expression)
  )
}

// Parse call, dot, and `[]`-subscript expressions.

pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
  }
  return result
};

pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
      this.potentialArrowAt === base.start;
  var optionalChained = false;

  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

    if (element.optional) { optionalChained = true; }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element
    }

    base = element;
  }
};

pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

  var computed = this.eat(types$1.bracketL);
  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types$1.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types$1._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types$1.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super ( Arguments )
    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types$1._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types$1.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
      this.overrideContext(types.f_expr);
      return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
    }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types$1.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
          (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
      }
    }
    return id

  case types$1.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types$1.num: case types$1.string:
    return this.parseLiteral(this.value)

  case types$1._null: case types$1._true: case types$1._false:
    node = this.startNode();
    node.value = this.type === types$1._null ? null : this.type === types$1._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types$1.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types$1.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types$1.braceL:
    this.overrideContext(types.b_expr);
    return this.parseObj(false, refDestructuringErrors)

  case types$1._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types$1._class:
    return this.parseClass(this.startNode(), false)

  case types$1._new:
    return this.parseNew()

  case types$1.backQuote:
    return this.parseTemplate()

  case types$1._import:
    if (this.options.ecmaVersion >= 11) {
      return this.parseExprImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
};

pp$5.parseExprImport = function() {
  var node = this.startNode();

  // Consume `import` as an identifier for `import.meta`.
  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
  var meta = this.parseIdent(true);

  switch (this.type) {
  case types$1.parenL:
    return this.parseDynamicImport(node)
  case types$1.dot:
    node.meta = meta;
    return this.parseImportMeta(node)
  default:
    this.unexpected();
  }
};

pp$5.parseDynamicImport = function(node) {
  this.next(); // skip `(`

  // Parse node.source.
  node.source = this.parseMaybeAssign();

  // Verify ending.
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }

  return this.finishNode(node, "ImportExpression")
};

pp$5.parseImportMeta = function(node) {
  this.next(); // skip `.`

  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);

  if (node.property.name !== "meta")
    { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
  if (containsEsc)
    { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
    { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

  return this.finishNode(node, "MetaProperty")
};

pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val
};

pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$5.parseParenItem = function(item) {
  return item
};

pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty = [];

pp$5.parseNew = function() {
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
    if (!this.allowNewDotTarget)
      { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
  if (isImport && node.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$5.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$5.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types$1.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon)
    { this.unexpected(); }

  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};

pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = Object.create(null);
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types$1.comma)
      { elt = null; }
    else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$5.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.currentThisScope().inClassFieldInit && name === "arguments")
    { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
    { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$5.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");

  // For validating existence
  if (this.privateNameStack.length === 0) {
    this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
  } else {
    this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
  }

  return node
};

// Parses yield expression inside generator.

pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$3 = Parser.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
  // A switch to disallow the identifier reference 'arguments'
  this.inClassFieldInit = false;
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$3.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$3.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$2 = Parser.prototype;

pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) { newNode[prop] = node[prop]; }
  return newNode
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues
};

var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}

for (var i = 0, list = [9, 10, 11, 12, 13]; i < list.length; i += 1) {
  var ecmaVersion = list[i];

  buildUnicodeData(ecmaVersion);
}

var pp$1 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current (forceU) {
    if ( forceU === void 0 ) forceU = false;

  return this.at(this.pos, forceU)
};

RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
    if ( forceU === void 0 ) forceU = false;

  return this.at(this.nextIndex(this.pos, forceU), forceU)
};

RegExpValidationState.prototype.advance = function advance (forceU) {
    if ( forceU === void 0 ) forceU = false;

  this.pos = this.nextIndex(this.pos, forceU);
};

RegExpValidationState.prototype.eat = function eat (ch, forceU) {
    if ( forceU === void 0 ) forceU = false;

  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true
  }
  return false
};

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$1.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$1.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$1.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier ::
//   [empty]
//   `?` GroupName
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName ::
//   `<` RegExpIdentifierName `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName ::
//   RegExpIdentifierStart
//   RegExpIdentifierName RegExpIdentifierPart
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
//   <ZWNJ>
//   <ZWJ>
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$1.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$1.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if ( forceU === void 0 ) forceU = false;

  var start = state.pos;
  var switchU = forceU || state.switchU;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &&
      this.regexp_eatUnicodePropertyValueExpression(state) &&
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name))
    { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise("Invalid property value"); }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
    { state.raise("Invalid property name"); }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* ] */)) {
      return true
    }
    // Unreachable since it threw "unterminated regular expression" error before.
    state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$1.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* ] */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp = Parser.prototype;

// Move to the next token

pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
    { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp[Symbol.iterator] = function() {
    var this$1$1 = this;

    return {
      next: function () {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

// Read a single token, updating the parser object's token-related
// properties.

pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xdc00) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
};

pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // '/'
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // '*'
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types$1.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot)
  }
};

pp.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.slash, 1)
};

pp.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
  }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
};

pp.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.bitwiseXOR, 1)
};

pp.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types$1.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.plusMin, 1)
};

pp.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
    return this.finishOp(types$1.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types$1.relational, size)
};

pp.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types$1.arrow)
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
};

pp.readToken_question = function() { // '?'
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
      }
      return this.finishOp(types$1.coalesce, 2)
    }
  }
  return this.finishOp(types$1.question, 1)
};

pp.readToken_numberSign = function() { // '#'
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35; // '#'
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
      return this.finishToken(types$1.privateId, this.readWord1())
    }
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types$1.parenL)
  case 41: ++this.pos; return this.finishToken(types$1.parenR)
  case 59: ++this.pos; return this.finishToken(types$1.semi)
  case 44: ++this.pos; return this.finishToken(types$1.comma)
  case 91: ++this.pos; return this.finishToken(types$1.bracketL)
  case 93: ++this.pos; return this.finishToken(types$1.bracketR)
  case 123: ++this.pos; return this.finishToken(types$1.braceL)
  case 125: ++this.pos; return this.finishToken(types$1.braceR)
  case 58: ++this.pos; return this.finishToken(types$1.colon)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types$1.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.
  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 63: // '?'
    return this.readToken_question()

  case 126: // '~'
    return this.finishOp(types$1.prefix, 1)

  case 35: // '#'
    return this.readToken_numberSign()
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  // `len` is used for character escape sequences. In that case, disallow separators.
  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
  // and isn't fraction part nor exponent part. In that case, if the first digit
  // is zero then disallow separators.
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);

    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
      if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
      if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
      lastCode = code;
      continue
    }

    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    lastCode = code;
    total = total * radix + val;
  }

  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8)
  }

  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
  return parseFloat(str.replace(/_/g, ""))
}

function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null
  }

  // `BigInt(value)` throws syntax error if the string contains numeric separators.
  return BigInt(str.replace(/_/g, ""))
}

pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types$1.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types$1.num, val$1)
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 0x2028 || ch === 0x2029) {
      if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out)
    }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case "\\":
      ++this.pos;
      break

    case "$":
      if (this.input[this.pos + 1] !== "{") {
        break
      }

    // falls through
    case "`":
      return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  case 56:
  case 57:
    if (this.strict) {
      this.invalidStringToken(
        this.pos - 1,
        "Invalid escape sequence"
      );
    }
    if (inTemplate) {
      var codePos = this.pos - 1;

      this.invalidStringToken(
        codePos,
        "Invalid escape sequence in template string"
      );

      return null
    }
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.

var version = "8.8.0";

Parser.acorn = {
  Parser: Parser,
  version: version,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext: TokContext,
  tokContexts: types,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  Token: Token,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
};

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return Parser.parse(input, options)
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}




/***/ }),
/* 96 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = require("minilog");

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _reactIntl = __webpack_require__(23);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _paperCanvas = __webpack_require__(99);

var _paperCanvas2 = _interopRequireDefault(_paperCanvas);

var _scrollableCanvas = __webpack_require__(102);

var _scrollableCanvas2 = _interopRequireDefault(_scrollableCanvas);

var _bitBrushMode = __webpack_require__(106);

var _bitBrushMode2 = _interopRequireDefault(_bitBrushMode);

var _bitLineMode = __webpack_require__(112);

var _bitLineMode2 = _interopRequireDefault(_bitLineMode);

var _bitOvalMode = __webpack_require__(115);

var _bitOvalMode2 = _interopRequireDefault(_bitOvalMode);

var _bitRectMode = __webpack_require__(120);

var _bitRectMode2 = _interopRequireDefault(_bitRectMode);

var _bitFillMode = __webpack_require__(123);

var _bitFillMode2 = _interopRequireDefault(_bitFillMode);

var _bitEraserMode = __webpack_require__(127);

var _bitEraserMode2 = _interopRequireDefault(_bitEraserMode);

var _bitSelectMode = __webpack_require__(129);

var _bitSelectMode2 = _interopRequireDefault(_bitSelectMode);

var _box = __webpack_require__(71);

var _box2 = _interopRequireDefault(_box);

var _button = __webpack_require__(38);

var _button2 = _interopRequireDefault(_button);

var _buttonGroup = __webpack_require__(72);

var _buttonGroup2 = _interopRequireDefault(_buttonGroup);

var _brushMode = __webpack_require__(137);

var _brushMode2 = _interopRequireDefault(_brushMode);

var _eraserMode = __webpack_require__(141);

var _eraserMode2 = _interopRequireDefault(_eraserMode);

var _fillColorIndicator = __webpack_require__(143);

var _fillColorIndicator2 = _interopRequireDefault(_fillColorIndicator);

var _fillMode = __webpack_require__(169);

var _fillMode2 = _interopRequireDefault(_fillMode);

var _inputGroup = __webpack_require__(33);

var _inputGroup2 = _interopRequireDefault(_inputGroup);

var _lineMode = __webpack_require__(173);

var _lineMode2 = _interopRequireDefault(_lineMode);

var _loupe = __webpack_require__(177);

var _loupe2 = _interopRequireDefault(_loupe);

var _fixedTools = __webpack_require__(180);

var _fixedTools2 = _interopRequireDefault(_fixedTools);

var _modeTools = __webpack_require__(200);

var _modeTools2 = _interopRequireDefault(_modeTools);

var _ovalMode = __webpack_require__(216);

var _ovalMode2 = _interopRequireDefault(_ovalMode);

var _rectMode = __webpack_require__(220);

var _rectMode2 = _interopRequireDefault(_rectMode);

var _reshapeMode = __webpack_require__(224);

var _reshapeMode2 = _interopRequireDefault(_reshapeMode);

var _selectMode = __webpack_require__(230);

var _selectMode2 = _interopRequireDefault(_selectMode);

var _strokeColorIndicator = __webpack_require__(234);

var _strokeColorIndicator2 = _interopRequireDefault(_strokeColorIndicator);

var _strokeWidthIndicator = __webpack_require__(235);

var _strokeWidthIndicator2 = _interopRequireDefault(_strokeWidthIndicator);

var _textMode = __webpack_require__(237);

var _textMode2 = _interopRequireDefault(_textMode);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _paintEditor = __webpack_require__(243);

var _paintEditor2 = _interopRequireDefault(_paintEditor);

var _bitmap = __webpack_require__(245);

var _bitmap2 = _interopRequireDefault(_bitmap);

var _zoomIn = __webpack_require__(246);

var _zoomIn2 = _interopRequireDefault(_zoomIn);

var _zoomOut = __webpack_require__(247);

var _zoomOut2 = _interopRequireDefault(_zoomOut);

var _zoomReset = __webpack_require__(248);

var _zoomReset2 = _interopRequireDefault(_zoomReset);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var messages = (0, _reactIntl.defineMessages)({
    bitmap: {
        'id': 'paint.paintEditor.bitmap',
        'defaultMessage': 'Convert to Bitmap'
    },
    vector: {
        'id': 'paint.paintEditor.vector',
        'defaultMessage': 'Convert to Vector'
    }
});

var PaintEditorComponent = function PaintEditorComponent(props) {
    return _react2.default.createElement(
        'div',
        {
            className: _paintEditor2.default.editorContainer,
            dir: props.rtl ? 'rtl' : 'ltr'
        },
        props.canvas !== null ? // eslint-disable-line no-negated-condition
        _react2.default.createElement(
            'div',
            { className: _paintEditor2.default.editorContainerTop },
            _react2.default.createElement(
                'div',
                { className: _paintEditor2.default.row },
                _react2.default.createElement(_fixedTools2.default, {
                    canRedo: props.canRedo,
                    canUndo: props.canUndo,
                    name: props.name,
                    onRedo: props.onRedo,
                    onUndo: props.onUndo,
                    onUpdateImage: props.onUpdateImage,
                    onUpdateName: props.onUpdateName
                })
            ),
            (0, _format.isVector)(props.format) ? _react2.default.createElement(
                'div',
                { className: _paintEditor2.default.row },
                _react2.default.createElement(
                    _inputGroup2.default,
                    {
                        className: (0, _classnames2.default)(_paintEditor2.default.row, _paintEditor2.default.modDashedBorder, _paintEditor2.default.modLabeledIconHeight)
                    },
                    _react2.default.createElement(_fillColorIndicator2.default, {
                        className: _paintEditor2.default.modMarginAfter,
                        onUpdateImage: props.onUpdateImage
                    }),
                    _react2.default.createElement(_strokeColorIndicator2.default, {
                        onUpdateImage: props.onUpdateImage
                    }),
                    _react2.default.createElement(_strokeWidthIndicator2.default, {
                        onUpdateImage: props.onUpdateImage
                    })
                ),
                _react2.default.createElement(
                    _inputGroup2.default,
                    { className: _paintEditor2.default.modModeTools },
                    _react2.default.createElement(_modeTools2.default, {
                        onUpdateImage: props.onUpdateImage
                    })
                )
            ) : (0, _format.isBitmap)(props.format) ? _react2.default.createElement(
                'div',
                { className: _paintEditor2.default.row },
                _react2.default.createElement(
                    _inputGroup2.default,
                    {
                        className: (0, _classnames2.default)(_paintEditor2.default.row, _paintEditor2.default.modDashedBorder, _paintEditor2.default.modLabeledIconHeight)
                    },
                    _react2.default.createElement(_fillColorIndicator2.default, {
                        className: _paintEditor2.default.modMarginAfter,
                        onUpdateImage: props.onUpdateImage
                    })
                ),
                _react2.default.createElement(
                    _inputGroup2.default,
                    { className: _paintEditor2.default.modModeTools },
                    _react2.default.createElement(_modeTools2.default, {
                        onUpdateImage: props.onUpdateImage
                    })
                )
            ) : null
        ) : null,
        _react2.default.createElement(
            'div',
            { className: _paintEditor2.default.topAlignRow },
            props.canvas !== null && (0, _format.isVector)(props.format) ? // eslint-disable-line no-negated-condition
            _react2.default.createElement(
                'div',
                { className: _paintEditor2.default.modeSelector },
                _react2.default.createElement(_selectMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_reshapeMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_brushMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_eraserMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_fillMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_textMode2.default, {
                    textArea: props.textArea,
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_lineMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_ovalMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_rectMode2.default, {
                    onUpdateImage: props.onUpdateImage
                })
            ) : null,
            props.canvas !== null && (0, _format.isBitmap)(props.format) ? // eslint-disable-line no-negated-condition
            _react2.default.createElement(
                'div',
                { className: _paintEditor2.default.modeSelector },
                _react2.default.createElement(_bitBrushMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_bitLineMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_bitOvalMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_bitRectMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_textMode2.default, {
                    isBitmap: true,
                    textArea: props.textArea,
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_bitFillMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_bitEraserMode2.default, {
                    onUpdateImage: props.onUpdateImage
                }),
                _react2.default.createElement(_bitSelectMode2.default, {
                    onUpdateImage: props.onUpdateImage
                })
            ) : null,
            _react2.default.createElement(
                'div',
                { className: _paintEditor2.default.controlsContainer },
                _react2.default.createElement(
                    _scrollableCanvas2.default,
                    {
                        canvas: props.canvas,
                        hideScrollbars: props.isEyeDropping,
                        style: _paintEditor2.default.canvasContainer
                    },
                    _react2.default.createElement(_paperCanvas2.default, {
                        canvasRef: props.setCanvas,
                        image: props.image,
                        imageFormat: props.imageFormat,
                        imageId: props.imageId,
                        rotationCenterX: props.rotationCenterX,
                        rotationCenterY: props.rotationCenterY,
                        zoomLevelId: props.zoomLevelId,
                        onUpdateImage: props.onUpdateImage
                    }),
                    _react2.default.createElement('textarea', {
                        className: _paintEditor2.default.textArea,
                        ref: props.setTextArea,
                        spellCheck: false
                    }),
                    props.isEyeDropping && props.colorInfo !== null && !props.colorInfo.hideLoupe ? _react2.default.createElement(
                        _box2.default,
                        { className: _paintEditor2.default.colorPickerWrapper },
                        _react2.default.createElement(_loupe2.default, {
                            colorInfo: props.colorInfo,
                            pixelRatio: _paper2.default.project.view.pixelRatio
                        })
                    ) : null
                ),
                _react2.default.createElement(
                    'div',
                    { className: _paintEditor2.default.canvasControls },
                    (0, _format.isVector)(props.format) ? _react2.default.createElement(
                        _button2.default,
                        {
                            className: _paintEditor2.default.bitmapButton,
                            onClick: props.onSwitchToBitmap
                        },
                        _react2.default.createElement('img', {
                            className: _paintEditor2.default.bitmapButtonIcon,
                            draggable: false,
                            src: _bitmap2.default
                        }),
                        _react2.default.createElement(
                            'span',
                            { className: _paintEditor2.default.buttonText },
                            props.intl.formatMessage(messages.bitmap)
                        )
                    ) : (0, _format.isBitmap)(props.format) ? _react2.default.createElement(
                        _button2.default,
                        {
                            className: _paintEditor2.default.bitmapButton,
                            onClick: props.onSwitchToVector
                        },
                        _react2.default.createElement('img', {
                            className: _paintEditor2.default.bitmapButtonIcon,
                            draggable: false,
                            src: _bitmap2.default
                        }),
                        _react2.default.createElement(
                            'span',
                            { className: _paintEditor2.default.buttonText },
                            props.intl.formatMessage(messages.vector)
                        )
                    ) : null,
                    _react2.default.createElement(
                        _inputGroup2.default,
                        { className: _paintEditor2.default.zoomControls },
                        _react2.default.createElement(
                            _buttonGroup2.default,
                            null,
                            _react2.default.createElement(
                                _button2.default,
                                {
                                    className: _paintEditor2.default.buttonGroupButton,
                                    onClick: props.onZoomOut
                                },
                                _react2.default.createElement('img', {
                                    alt: 'Zoom Out',
                                    className: _paintEditor2.default.buttonGroupButtonIcon,
                                    draggable: false,
                                    src: _zoomOut2.default
                                })
                            ),
                            _react2.default.createElement(
                                _button2.default,
                                {
                                    className: _paintEditor2.default.buttonGroupButton,
                                    onClick: props.onZoomReset
                                },
                                _react2.default.createElement('img', {
                                    alt: 'Zoom Reset',
                                    className: _paintEditor2.default.buttonGroupButtonIcon,
                                    draggable: false,
                                    src: _zoomReset2.default
                                })
                            ),
                            _react2.default.createElement(
                                _button2.default,
                                {
                                    className: _paintEditor2.default.buttonGroupButton,
                                    onClick: props.onZoomIn
                                },
                                _react2.default.createElement('img', {
                                    alt: 'Zoom In',
                                    className: _paintEditor2.default.buttonGroupButtonIcon,
                                    draggable: false,
                                    src: _zoomIn2.default
                                })
                            )
                        )
                    )
                )
            )
        )
    );
};

PaintEditorComponent.propTypes = {
    canRedo: _propTypes2.default.func.isRequired,
    canUndo: _propTypes2.default.func.isRequired,
    canvas: _propTypes2.default.instanceOf(Element),
    colorInfo: _loupe2.default.propTypes.colorInfo,
    format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
    image: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.instanceOf(HTMLImageElement)]),
    imageFormat: _propTypes2.default.string,
    imageId: _propTypes2.default.string,
    intl: _reactIntl.intlShape,
    isEyeDropping: _propTypes2.default.bool,
    name: _propTypes2.default.string,
    onRedo: _propTypes2.default.func.isRequired,
    onSwitchToBitmap: _propTypes2.default.func.isRequired,
    onSwitchToVector: _propTypes2.default.func.isRequired,
    onUndo: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    onUpdateName: _propTypes2.default.func.isRequired,
    onZoomIn: _propTypes2.default.func.isRequired,
    onZoomOut: _propTypes2.default.func.isRequired,
    onZoomReset: _propTypes2.default.func.isRequired,
    rotationCenterX: _propTypes2.default.number,
    rotationCenterY: _propTypes2.default.number,
    rtl: _propTypes2.default.bool,
    setCanvas: _propTypes2.default.func.isRequired,
    setTextArea: _propTypes2.default.func.isRequired,
    textArea: _propTypes2.default.instanceOf(Element),
    zoomLevelId: _propTypes2.default.string
};

exports.default = (0, _reactIntl.injectIntl)(PaintEditorComponent);

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _undo = __webpack_require__(47);

var _undo2 = __webpack_require__(35);

var _group = __webpack_require__(24);

var _layer = __webpack_require__(12);

var _selectedItems = __webpack_require__(7);

var _view = __webpack_require__(22);

var _math = __webpack_require__(20);

var _hover = __webpack_require__(36);

var _clipboard = __webpack_require__(49);

var _format3 = __webpack_require__(40);

var _viewBounds = __webpack_require__(37);

var _zoomLevels = __webpack_require__(60);

var _paperCanvas = __webpack_require__(100);

var _paperCanvas2 = _interopRequireDefault(_paperCanvas);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PaperCanvas = function (_React$Component) {
    _inherits(PaperCanvas, _React$Component);

    function PaperCanvas(props) {
        _classCallCheck(this, PaperCanvas);

        var _this = _possibleConstructorReturn(this, (PaperCanvas.__proto__ || Object.getPrototypeOf(PaperCanvas)).call(this, props));

        (0, _lodash2.default)(_this, ['clearQueuedImport', 'setCanvas', 'importSvg', 'initializeSvg', 'maybeZoomToFit', 'switchCostume', 'onViewResize', 'recalibrateSize']);
        return _this;
    }

    _createClass(PaperCanvas, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            _paper2.default.setup(this.canvas);
            _paper2.default.view.on('resize', this.onViewResize);
            (0, _view.resetZoom)();
            if (this.props.zoomLevelId) {
                this.props.setZoomLevelId(this.props.zoomLevelId);
                if (this.props.zoomLevels[this.props.zoomLevelId]) {
                    // This is the matrix that the view should be zoomed to after image import
                    this.shouldZoomToFit = this.props.zoomLevels[this.props.zoomLevelId];
                } else {
                    // Zoom to fit true means find a comfortable zoom level for viewing the costume
                    this.shouldZoomToFit = true;
                }
            } else {
                this.props.updateViewBounds(_paper2.default.view.matrix);
            }

            var context = this.canvas.getContext('2d');
            context.webkitImageSmoothingEnabled = false;
            context.imageSmoothingEnabled = false;

            // Don't show handles by default
            _paper2.default.settings.handleSize = 0;
            // Make layers.
            (0, _layer.setupLayers)(this.props.format);
            this.importImage(this.props.imageFormat, this.props.image, this.props.rotationCenterX, this.props.rotationCenterY);
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(newProps) {
            if (this.props.imageId !== newProps.imageId) {
                this.switchCostume(newProps.imageFormat, newProps.image, newProps.rotationCenterX, newProps.rotationCenterY, this.props.zoomLevelId, newProps.zoomLevelId);
            }
            if (this.props.format !== newProps.format) {
                this.recalibrateSize();
                (0, _layer.convertBackgroundGuideLayer)(newProps.format);
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            this.clearQueuedImport();
            // shouldZoomToFit means the zoom level hasn't been initialized yet
            if (!this.shouldZoomToFit) {
                this.props.saveZoomLevel();
            }
            _paper2.default.remove();
        }
    }, {
        key: 'clearQueuedImport',
        value: function clearQueuedImport() {
            if (this.queuedImport) {
                window.clearTimeout(this.queuedImport);
                this.queuedImport = null;
            }
            if (this.queuedImageToLoad) {
                this.queuedImageToLoad.src = '';
                this.queuedImageToLoad.onload = null;
                this.queuedImageToLoad = null;
            }
        }
    }, {
        key: 'switchCostume',
        value: function switchCostume(format, image, rotationCenterX, rotationCenterY, oldZoomLevelId, newZoomLevelId) {
            if (oldZoomLevelId && oldZoomLevelId !== newZoomLevelId) {
                this.props.saveZoomLevel();
            }
            if (newZoomLevelId && oldZoomLevelId !== newZoomLevelId) {
                if (this.props.zoomLevels[newZoomLevelId]) {
                    this.shouldZoomToFit = this.props.zoomLevels[newZoomLevelId];
                } else {
                    this.shouldZoomToFit = true;
                }
                this.props.setZoomLevelId(newZoomLevelId);
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _paper2.default.project.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var layer = _step.value;

                    if (layer.data.isRasterLayer) {
                        (0, _layer.clearRaster)();
                    } else if (!layer.data.isBackgroundGuideLayer && !layer.data.isDragCrosshairLayer && !layer.data.isOutlineLayer) {
                        layer.removeChildren();
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.props.clearUndo();
            this.props.clearSelectedItems();
            this.props.clearHoveredItem();
            this.props.clearPasteOffset();
            this.importImage(format, image, rotationCenterX, rotationCenterY);
        }
    }, {
        key: 'importImage',
        value: function importImage(format, image, rotationCenterX, rotationCenterY) {
            var _this2 = this;

            // Stop any in-progress imports
            this.clearQueuedImport();

            if (!image) {
                this.props.changeFormat(_format2.default.VECTOR_SKIP_CONVERT);
                (0, _undo.performSnapshot)(this.props.undoSnapshot, _format2.default.VECTOR_SKIP_CONVERT);
                this.recalibrateSize();
                return;
            }

            if (format === 'jpg' || format === 'png') {
                // import bitmap
                this.props.changeFormat(_format2.default.BITMAP_SKIP_CONVERT);

                var mask = new _paper2.default.Shape.Rectangle((0, _layer.getRaster)().getBounds());
                mask.guide = true;
                mask.locked = true;
                mask.setPosition(_view.CENTER);
                mask.clipMask = true;

                var imgElement = new Image();
                this.queuedImageToLoad = imgElement;
                imgElement.onload = function () {
                    if (!_this2.queuedImageToLoad) return;
                    _this2.queuedImageToLoad = null;

                    if (typeof rotationCenterX === 'undefined') {
                        rotationCenterX = imgElement.width / 2;
                    }
                    if (typeof rotationCenterY === 'undefined') {
                        rotationCenterY = imgElement.height / 2;
                    }

                    (0, _layer.getRaster)().drawImage(imgElement, _view.ART_BOARD_WIDTH / 2 - rotationCenterX, _view.ART_BOARD_HEIGHT / 2 - rotationCenterY);
                    (0, _layer.getRaster)().drawImage(imgElement, _view.ART_BOARD_WIDTH / 2 - rotationCenterX, _view.ART_BOARD_HEIGHT / 2 - rotationCenterY);

                    _this2.maybeZoomToFit(true /* isBitmap */);
                    (0, _undo.performSnapshot)(_this2.props.undoSnapshot, _format2.default.BITMAP_SKIP_CONVERT);
                    _this2.recalibrateSize();
                };
                imgElement.src = image;
            } else if (format === 'svg') {
                this.props.changeFormat(_format2.default.VECTOR_SKIP_CONVERT);
                this.importSvg(image, rotationCenterX, rotationCenterY);
            } else {
                _log2.default.error('Didn\'t recognize format: ' + format + '. Use \'jpg\', \'png\' or \'svg\'.');
                this.props.changeFormat(_format2.default.VECTOR_SKIP_CONVERT);
                (0, _undo.performSnapshot)(this.props.undoSnapshot, _format2.default.VECTOR_SKIP_CONVERT);
                this.recalibrateSize();
            }
        }
    }, {
        key: 'maybeZoomToFit',
        value: function maybeZoomToFit(isBitmapMode) {
            if (this.shouldZoomToFit instanceof _paper2.default.Matrix) {
                _paper2.default.view.matrix = this.shouldZoomToFit;
                this.props.updateViewBounds(_paper2.default.view.matrix);
                (0, _view.resizeCrosshair)();
            } else if (this.shouldZoomToFit === true) {
                (0, _view.zoomToFit)(isBitmapMode);
            }
            this.shouldZoomToFit = false;
            (0, _view.setWorkspaceBounds)();
            this.props.updateViewBounds(_paper2.default.view.matrix);
        }
    }, {
        key: 'importSvg',
        value: function importSvg(svg, rotationCenterX, rotationCenterY) {
            var paperCanvas = this;
            // Pre-process SVG to prevent parsing errors (discussion from #213)
            // 1. Remove svg: namespace on elements.
            // TODO: remove
            svg = svg.split(/<\s*svg:/).join('<');
            svg = svg.split(/<\/\s*svg:/).join('</');
            // 2. Add root svg namespace if it does not exist.
            var svgAttrs = svg.match(/<svg [^>]*>/);
            if (svgAttrs && svgAttrs[0].indexOf('xmlns=') === -1) {
                svg = svg.replace('<svg ', '<svg xmlns="http://www.w3.org/2000/svg" ');
            }

            // Get the origin which the viewBox is defined relative to. During import, Paper will translate
            // the viewBox to start at (0, 0), and we need to translate it back for some costumes to render
            // correctly.
            var parser = new DOMParser();
            var svgDom = parser.parseFromString(svg, 'text/xml');
            var viewBox = svgDom.documentElement.attributes.viewBox ? svgDom.documentElement.attributes.viewBox.value.match(/\S+/g) : null;
            if (viewBox) {
                for (var i = 0; i < viewBox.length; i++) {
                    viewBox[i] = parseFloat(viewBox[i]);
                }
            }

            _paper2.default.project.importSVG(svg, {
                expandShapes: true,
                onLoad: function onLoad(item) {
                    if (!item) {
                        _log2.default.error('SVG import failed:');
                        _log2.default.info(svg);
                        this.props.changeFormat(_format2.default.VECTOR_SKIP_CONVERT);
                        (0, _undo.performSnapshot)(paperCanvas.props.undoSnapshot, _format2.default.VECTOR_SKIP_CONVERT);
                        return;
                    }
                    item.remove();

                    // Without the callback, rasters' load function has not been called yet, and they are
                    // positioned incorrectly
                    paperCanvas.queuedImport = paperCanvas.recalibrateSize(function () {
                        paperCanvas.props.updateViewBounds(_paper2.default.view.matrix);
                        paperCanvas.initializeSvg(item, rotationCenterX, rotationCenterY, viewBox);
                    });
                }
            });
        }
    }, {
        key: 'initializeSvg',
        value: function initializeSvg(item, rotationCenterX, rotationCenterY, viewBox) {
            if (this.queuedImport) this.queuedImport = null;
            var itemWidth = item.bounds.width;
            var itemHeight = item.bounds.height;

            // Get reference to viewbox
            var mask = void 0;
            if (item.clipped) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = item.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var child = _step2.value;

                        if (child.isClipMask()) {
                            mask = child;
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                mask.clipMask = false;
            } else {
                mask = new _paper2.default.Shape.Rectangle(item.bounds);
            }
            mask.guide = true;
            mask.locked = true;
            mask.matrix = new _paper2.default.Matrix(); // Identity
            // Set the artwork to get clipped at the max costume size
            mask.size.height = _view.MAX_WORKSPACE_BOUNDS.height;
            mask.size.width = _view.MAX_WORKSPACE_BOUNDS.width;
            mask.setPosition(_view.CENTER);
            _paper2.default.project.activeLayer.addChild(mask);
            mask.clipMask = true;

            // Reduce single item nested in groups
            if (item instanceof _paper2.default.Group && item.children.length === 1) {
                item = item.reduce();
            }

            (0, _math.ensureClockwise)(item);
            (0, _math.scaleWithStrokes)(item, 2, new _paper2.default.Point()); // Import at 2x

            // Apply rotation center
            if (typeof rotationCenterX !== 'undefined' && typeof rotationCenterY !== 'undefined') {
                var rotationPoint = new _paper2.default.Point(rotationCenterX, rotationCenterY);
                if (viewBox && viewBox.length >= 2 && !isNaN(viewBox[0]) && !isNaN(viewBox[1])) {
                    rotationPoint = rotationPoint.subtract(viewBox[0], viewBox[1]);
                }
                item.translate(_view.CENTER.subtract(rotationPoint.multiply(2)));
            } else {
                // Center
                item.translate(_view.CENTER.subtract(itemWidth, itemHeight));
            }

            _paper2.default.project.activeLayer.insertChild(0, item);
            if ((0, _group.isGroup)(item)) {
                // Fixes an issue where we may export empty groups
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = item.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var _child = _step3.value;

                        if ((0, _group.isGroup)(_child) && _child.children.length === 0) {
                            _child.remove();
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }

                (0, _group.ungroupItems)([item]);
            }

            (0, _undo.performSnapshot)(this.props.undoSnapshot, _format2.default.VECTOR_SKIP_CONVERT);
            this.maybeZoomToFit();
        }
    }, {
        key: 'onViewResize',
        value: function onViewResize() {
            (0, _view.setWorkspaceBounds)(true /* clipEmpty */);
            (0, _view.clampViewBounds)();
            // Fix incorrect paper canvas scale on browser zoom reset
            this.recalibrateSize();
            this.props.updateViewBounds(_paper2.default.view.matrix);
        }
    }, {
        key: 'recalibrateSize',
        value: function recalibrateSize(callback) {
            // Sets the size that Paper thinks the canvas is to the size the canvas element actually is.
            // When these are out of sync, the mouse events in the paint editor don't line up correctly.
            return window.setTimeout(function () {
                // If the component unmounts, the canvas will be removed from the page, detaching paper.view.
                // This could also be called before paper.view exists.
                // In either case, return early if so without running the callback.
                if (!_paper2.default.view) return;
                // Prevent blurriness caused if the "CSS size" of the element is a float--
                // setting canvas dimensions to floats floors them, but we need to round instead
                var elemSize = _paper2.default.DomElement.getSize(_paper2.default.view.element);
                elemSize.width = Math.round(elemSize.width);
                elemSize.height = Math.round(elemSize.height);
                _paper2.default.view.setViewSize(elemSize);

                if (callback) callback();
            }, 0);
        }
    }, {
        key: 'setCanvas',
        value: function setCanvas(canvas) {
            this.canvas = canvas;
            if (this.props.canvasRef) {
                this.props.canvasRef(canvas);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement('canvas', {
                className: _paperCanvas2.default.paperCanvas,
                ref: this.setCanvas,
                style: { cursor: this.props.cursor },
                resize: 'true'
            });
        }
    }]);

    return PaperCanvas;
}(_react2.default.Component);

PaperCanvas.propTypes = {
    canvasRef: _propTypes2.default.func,
    changeFormat: _propTypes2.default.func.isRequired,
    clearHoveredItem: _propTypes2.default.func.isRequired,
    clearPasteOffset: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    clearUndo: _propTypes2.default.func.isRequired,
    cursor: _propTypes2.default.string,
    format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
    image: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.instanceOf(HTMLImageElement)]),
    imageFormat: _propTypes2.default.string, // The incoming image's data format, used during import. The user could switch this.
    imageId: _propTypes2.default.string,
    rotationCenterX: _propTypes2.default.number,
    rotationCenterY: _propTypes2.default.number,
    saveZoomLevel: _propTypes2.default.func.isRequired,
    setZoomLevelId: _propTypes2.default.func.isRequired,
    undoSnapshot: _propTypes2.default.func.isRequired,
    updateViewBounds: _propTypes2.default.func.isRequired,
    zoomLevelId: _propTypes2.default.string,
    zoomLevels: _propTypes2.default.shape({
        currentZoomLevelId: _propTypes2.default.string
    })
};
var mapStateToProps = function mapStateToProps(state) {
    return {
        mode: state.scratchPaint.mode,
        cursor: state.scratchPaint.cursor,
        format: state.scratchPaint.format,
        zoomLevels: state.scratchPaint.zoomLevels
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        undoSnapshot: function undoSnapshot(snapshot) {
            dispatch((0, _undo2.undoSnapshot)(snapshot));
        },
        clearUndo: function clearUndo() {
            dispatch((0, _undo2.clearUndoState)());
        },
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        clearHoveredItem: function clearHoveredItem() {
            dispatch((0, _hover.clearHoveredItem)());
        },
        clearPasteOffset: function clearPasteOffset() {
            dispatch((0, _clipboard.clearPasteOffset)());
        },
        changeFormat: function changeFormat(format) {
            dispatch((0, _format3.changeFormat)(format));
        },
        saveZoomLevel: function saveZoomLevel() {
            dispatch((0, _zoomLevels.saveZoomLevel)(_paper2.default.view.matrix));
        },
        setZoomLevelId: function setZoomLevelId(zoomLevelId) {
            dispatch((0, _zoomLevels.setZoomLevelId)(zoomLevelId));
        },
        updateViewBounds: function updateViewBounds(matrix) {
            dispatch((0, _viewBounds.updateViewBounds)(matrix));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(PaperCanvas);

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(101);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".paper-canvas_paper-canvas_2biXB {\n    top: 1px; /* leave room for the border */\n    left: 1px;\n    width: calc(100% - 2px);\n    height: calc(100% - 2px);\n    margin: auto;\n    position: absolute;\n    background-color: #D9E3F2;\n}\n", ""]);
// Exports
exports.locals = {
	"paper-canvas": "paper-canvas_paper-canvas_2biXB",
	"paperCanvas": "paper-canvas_paper-canvas_2biXB"
};
module.exports = exports;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _scrollableCanvas = __webpack_require__(103);

var _scrollableCanvas2 = _interopRequireDefault(_scrollableCanvas);

var _view = __webpack_require__(22);

var _viewBounds = __webpack_require__(37);

var _selectedItems = __webpack_require__(7);

var _touchUtils = __webpack_require__(61);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ScrollableCanvas = function (_React$Component) {
    _inherits(ScrollableCanvas, _React$Component);

    _createClass(ScrollableCanvas, null, [{
        key: 'ZOOM_INCREMENT',
        get: function get() {
            return 0.5;
        }
    }]);

    function ScrollableCanvas(props) {
        _classCallCheck(this, ScrollableCanvas);

        var _this = _possibleConstructorReturn(this, (ScrollableCanvas.__proto__ || Object.getPrototypeOf(ScrollableCanvas)).call(this, props));

        (0, _lodash2.default)(_this, ['handleHorizontalScrollbarMouseDown', 'handleHorizontalScrollbarMouseMove', 'handleHorizontalScrollbarMouseUp', 'handleVerticalScrollbarMouseDown', 'handleVerticalScrollbarMouseMove', 'handleVerticalScrollbarMouseUp', 'handleWheel']);
        return _this;
    }

    _createClass(ScrollableCanvas, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.canvas) {
                this.props.canvas.addEventListener('wheel', this.handleWheel);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.canvas) {
                if (this.props.canvas) {
                    this.props.canvas.removeEventListener('wheel', this.handleWheel);
                }
                nextProps.canvas.addEventListener('wheel', this.handleWheel);
            }
        }
    }, {
        key: 'handleHorizontalScrollbarMouseDown',
        value: function handleHorizontalScrollbarMouseDown(event) {
            this.initialMouseX = (0, _touchUtils.getEventXY)(event).x;
            this.initialScreenX = _paper2.default.view.matrix.tx;
            window.addEventListener('mousemove', this.handleHorizontalScrollbarMouseMove);
            window.addEventListener('touchmove', this.handleHorizontalScrollbarMouseMove, { passive: false });
            window.addEventListener('mouseup', this.handleHorizontalScrollbarMouseUp);
            window.addEventListener('touchend', this.handleHorizontalScrollbarMouseUp);
            event.preventDefault();
        }
    }, {
        key: 'handleHorizontalScrollbarMouseMove',
        value: function handleHorizontalScrollbarMouseMove(event) {
            var dx = this.initialMouseX - (0, _touchUtils.getEventXY)(event).x;
            _paper2.default.view.matrix.tx = this.initialScreenX + dx * _paper2.default.view.zoom * 2;
            (0, _view.clampViewBounds)();
            this.props.updateViewBounds(_paper2.default.view.matrix);
            event.preventDefault();
        }
    }, {
        key: 'handleHorizontalScrollbarMouseUp',
        value: function handleHorizontalScrollbarMouseUp() {
            window.removeEventListener('mousemove', this.handleHorizontalScrollbarMouseMove);
            window.removeEventListener('touchmove', this.handleHorizontalScrollbarMouseMove, { passive: false });
            window.removeEventListener('mouseup', this.handleHorizontalScrollbarMouseUp);
            window.removeEventListener('touchend', this.handleHorizontalScrollbarMouseUp);
            this.initialMouseX = null;
            this.initialScreenX = null;
            event.preventDefault();
        }
    }, {
        key: 'handleVerticalScrollbarMouseDown',
        value: function handleVerticalScrollbarMouseDown(event) {
            this.initialMouseY = (0, _touchUtils.getEventXY)(event).y;
            this.initialScreenY = _paper2.default.view.matrix.ty;
            window.addEventListener('mousemove', this.handleVerticalScrollbarMouseMove);
            window.addEventListener('touchmove', this.handleVerticalScrollbarMouseMove, { passive: false });
            window.addEventListener('mouseup', this.handleVerticalScrollbarMouseUp);
            window.addEventListener('touchend', this.handleVerticalScrollbarMouseUp);
            event.preventDefault();
        }
    }, {
        key: 'handleVerticalScrollbarMouseMove',
        value: function handleVerticalScrollbarMouseMove(event) {
            var dy = this.initialMouseY - (0, _touchUtils.getEventXY)(event).y;
            _paper2.default.view.matrix.ty = this.initialScreenY + dy * _paper2.default.view.zoom * 2;
            (0, _view.clampViewBounds)();
            this.props.updateViewBounds(_paper2.default.view.matrix);
            event.preventDefault();
        }
    }, {
        key: 'handleVerticalScrollbarMouseUp',
        value: function handleVerticalScrollbarMouseUp(event) {
            window.removeEventListener('mousemove', this.handleVerticalScrollbarMouseMove);
            window.removeEventListener('touchmove', this.handleVerticalScrollbarMouseMove, { passive: false });
            window.removeEventListener('mouseup', this.handleVerticalScrollbarMouseUp);
            window.removeEventListener('touchend', this.handleVerticalScrollbarMouseUp);
            this.initialMouseY = null;
            this.initialScreenY = null;
            event.preventDefault();
        }
    }, {
        key: 'handleWheel',
        value: function handleWheel(event) {
            // Multiplier variable, so that non-pixel-deltaModes are supported. Needed for Firefox.
            // See #529 (or LLK/scratch-blocks#1190).
            var multiplier = event.deltaMode === 0x1 ? 15 : 1;
            var deltaX = event.deltaX * multiplier;
            var deltaY = event.deltaY * multiplier;
            var canvasRect = this.props.canvas.getBoundingClientRect();
            var offsetX = event.clientX - canvasRect.left;
            var offsetY = event.clientY - canvasRect.top;
            var fixedPoint = _paper2.default.view.viewToProject(new _paper2.default.Point(offsetX, offsetY));
            if (event.metaKey || event.ctrlKey) {
                // Zoom keeping mouse location fixed
                (0, _view.zoomOnFixedPoint)(-deltaY / 1000, fixedPoint);
                this.props.updateViewBounds(_paper2.default.view.matrix);
                this.props.redrawSelectionBox(); // Selection handles need to be resized after zoom
            } else if (event.shiftKey && event.deltaX === 0) {
                // Scroll horizontally (based on vertical scroll delta)
                // This is needed as for some browser/system combinations which do not set deltaX.
                // See #156.
                var dx = deltaY / _paper2.default.view.zoom;
                (0, _view.pan)(dx, 0);
                this.props.updateViewBounds(_paper2.default.view.matrix);
            } else {
                var _dx = deltaX / _paper2.default.view.zoom;
                var dy = deltaY / _paper2.default.view.zoom;
                (0, _view.pan)(_dx, dy);
                this.props.updateViewBounds(_paper2.default.view.matrix);
                if (_paper2.default.tool) {
                    _paper2.default.tool.view._handleMouseEvent('mousemove', event, fixedPoint);
                }
            }
            event.preventDefault();
        }
    }, {
        key: 'render',
        value: function render() {
            var widthPercent = 0;
            var heightPercent = 0;
            var topPercent = 0;
            var leftPercent = 0;
            if (_paper2.default.project) {
                var bounds = (0, _view.getWorkspaceBounds)();
                var _paper$view$bounds = _paper2.default.view.bounds,
                    x = _paper$view$bounds.x,
                    y = _paper$view$bounds.y,
                    width = _paper$view$bounds.width,
                    height = _paper$view$bounds.height;

                widthPercent = Math.min(100, 100 * width / bounds.width);
                heightPercent = Math.min(100, 100 * height / bounds.height);
                var centerX = (x + width / 2 - bounds.x) / bounds.width;
                var centerY = (y + height / 2 - bounds.y) / bounds.height;
                topPercent = Math.max(0, 100 * centerY - heightPercent / 2);
                leftPercent = Math.max(0, 100 * centerX - widthPercent / 2);
            }
            return _react2.default.createElement(
                _scrollableCanvas2.default,
                {
                    hideScrollbars: this.props.hideScrollbars,
                    horizontalScrollLengthPercent: widthPercent,
                    horizontalScrollStartPercent: leftPercent,
                    style: this.props.style,
                    verticalScrollLengthPercent: heightPercent,
                    verticalScrollStartPercent: topPercent,
                    onHorizontalScrollbarMouseDown: this.handleHorizontalScrollbarMouseDown,
                    onVerticalScrollbarMouseDown: this.handleVerticalScrollbarMouseDown
                },
                this.props.children
            );
        }
    }]);

    return ScrollableCanvas;
}(_react2.default.Component);

ScrollableCanvas.propTypes = {
    canvas: _propTypes2.default.instanceOf(Element),
    children: _propTypes2.default.node.isRequired,
    hideScrollbars: _propTypes2.default.bool,
    redrawSelectionBox: _propTypes2.default.func.isRequired,
    style: _propTypes2.default.string,
    updateViewBounds: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        viewBounds: state.scratchPaint.viewBounds
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        redrawSelectionBox: function redrawSelectionBox() {
            dispatch((0, _selectedItems.redrawSelectionBox)());
        },
        updateViewBounds: function updateViewBounds(matrix) {
            dispatch((0, _viewBounds.updateViewBounds)(matrix));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(ScrollableCanvas);

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _scrollableCanvas = __webpack_require__(104);

var _scrollableCanvas2 = _interopRequireDefault(_scrollableCanvas);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ScrollableCanvasComponent = function ScrollableCanvasComponent(props) {
    return _react2.default.createElement(
        'div',
        {
            className: props.style
        },
        props.children,
        _react2.default.createElement(
            'div',
            {
                className: _scrollableCanvas2.default.horizontalScrollbarWrapper,
                style: { pointerEvents: 'none' }
            },
            _react2.default.createElement(
                'div',
                {
                    className: _scrollableCanvas2.default.horizontalScrollbarHitbox,
                    style: {
                        width: props.horizontalScrollLengthPercent + '%',
                        left: props.horizontalScrollStartPercent + '%',
                        pointerEvents: 'auto',
                        display: '' + (props.hideScrollbars || Math.abs(props.horizontalScrollLengthPercent - 100) < 1e-8 ? 'none' : 'block')
                    },
                    onMouseDown: props.onHorizontalScrollbarMouseDown,
                    onTouchStart: props.onHorizontalScrollbarMouseDown
                },
                _react2.default.createElement('div', {
                    className: _scrollableCanvas2.default.horizontalScrollbar
                })
            )
        ),
        _react2.default.createElement(
            'div',
            {
                className: _scrollableCanvas2.default.verticalScrollbarWrapper,
                style: { pointerEvents: 'none' }
            },
            _react2.default.createElement(
                'div',
                {
                    className: _scrollableCanvas2.default.verticalScrollbarHitbox,
                    style: {
                        height: props.verticalScrollLengthPercent + '%',
                        top: props.verticalScrollStartPercent + '%',
                        pointerEvents: 'auto',
                        display: '' + (props.hideScrollbars || Math.abs(props.verticalScrollLengthPercent - 100) < 1e-8 ? 'none' : 'block')
                    },
                    onMouseDown: props.onVerticalScrollbarMouseDown,
                    onTouchStart: props.onVerticalScrollbarMouseDown
                },
                _react2.default.createElement('div', {
                    className: _scrollableCanvas2.default.verticalScrollbar
                })
            )
        )
    );
};

ScrollableCanvasComponent.propTypes = {
    children: _propTypes2.default.node.isRequired,
    hideScrollbars: _propTypes2.default.bool,
    horizontalScrollLengthPercent: _propTypes2.default.number,
    horizontalScrollStartPercent: _propTypes2.default.number,
    onHorizontalScrollbarMouseDown: _propTypes2.default.func.isRequired,
    onVerticalScrollbarMouseDown: _propTypes2.default.func.isRequired,
    style: _propTypes2.default.string,
    verticalScrollLengthPercent: _propTypes2.default.number,
    verticalScrollStartPercent: _propTypes2.default.number
};

exports.default = ScrollableCanvasComponent;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(105);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".scrollable-canvas_vertical-scrollbar_gyXyM, .scrollable-canvas_horizontal-scrollbar_OBOUt {\n    background: rgba(190, 190, 190, 0.8);\n    border-radius: calc(8px / 2);\n    width: 100%;\n    height: 100%;\n}\n.scrollable-canvas_vertical-scrollbar-wrapper_1cMNm {\n    position: absolute;\n    width: calc(8px + 4px);\n    right: 0;\n    top: 4px;\n    height: calc(100% - 8px - 2 * 4px);\n}\n.scrollable-canvas_horizontal-scrollbar-wrapper_2BUMa {\n    position: absolute;\n    height: calc(8px + 4px);\n    left: 4px;\n    bottom: 0;\n    width: calc(100% - 8px - 2 * 4px);\n}\n.scrollable-canvas_vertical-scrollbar-hitbox_2QprH, .scrollable-canvas_horizontal-scrollbar-hitbox_EBg8r {\n    position: absolute;\n    cursor: pointer;\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n}\n.scrollable-canvas_vertical-scrollbar-hitbox_2QprH {\n    width: calc(8px + 4px);\n    padding-right: 4px;\n}\n.scrollable-canvas_horizontal-scrollbar-hitbox_EBg8r {\n    height: calc(8px + 4px);\n    padding-bottom: 4px;\n}\n", ""]);
// Exports
exports.locals = {
	"vertical-scrollbar": "scrollable-canvas_vertical-scrollbar_gyXyM",
	"verticalScrollbar": "scrollable-canvas_vertical-scrollbar_gyXyM",
	"horizontal-scrollbar": "scrollable-canvas_horizontal-scrollbar_OBOUt",
	"horizontalScrollbar": "scrollable-canvas_horizontal-scrollbar_OBOUt",
	"vertical-scrollbar-wrapper": "scrollable-canvas_vertical-scrollbar-wrapper_1cMNm",
	"verticalScrollbarWrapper": "scrollable-canvas_vertical-scrollbar-wrapper_1cMNm",
	"horizontal-scrollbar-wrapper": "scrollable-canvas_horizontal-scrollbar-wrapper_2BUMa",
	"horizontalScrollbarWrapper": "scrollable-canvas_horizontal-scrollbar-wrapper_2BUMa",
	"vertical-scrollbar-hitbox": "scrollable-canvas_vertical-scrollbar-hitbox_2QprH",
	"verticalScrollbarHitbox": "scrollable-canvas_vertical-scrollbar-hitbox_2QprH",
	"horizontal-scrollbar-hitbox": "scrollable-canvas_horizontal-scrollbar-hitbox_EBg8r",
	"horizontalScrollbarHitbox": "scrollable-canvas_horizontal-scrollbar-hitbox_EBg8r"
};
module.exports = exports;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _stylePath = __webpack_require__(9);

var _fillStyle = __webpack_require__(18);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _selection = __webpack_require__(3);

var _bitBrushMode = __webpack_require__(107);

var _bitBrushMode2 = _interopRequireDefault(_bitBrushMode);

var _brushTool = __webpack_require__(64);

var _brushTool2 = _interopRequireDefault(_brushTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BitBrushMode = function (_React$Component) {
    _inherits(BitBrushMode, _React$Component);

    function BitBrushMode(props) {
        _classCallCheck(this, BitBrushMode);

        var _this = _possibleConstructorReturn(this, (BitBrushMode.__proto__ || Object.getPrototypeOf(BitBrushMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(BitBrushMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isBitBrushModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool && nextProps.color !== this.props.color) {
                this.tool.setColor(nextProps.color);
            }
            if (this.tool && nextProps.bitBrushSize !== this.props.bitBrushSize) {
                this.tool.setBrushSize(nextProps.bitBrushSize);
            }

            if (nextProps.isBitBrushModeActive && !this.props.isBitBrushModeActive) {
                this.activateTool();
            } else if (!nextProps.isBitBrushModeActive && this.props.isBitBrushModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isBitBrushModeActive !== this.props.isBitBrushModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            (0, _selection.clearSelection)(this.props.clearSelectedItems);
            this.props.clearGradient();
            // Force the default brush color if fill is MIXED or transparent
            var color = this.props.color;
            if (!color || color === _stylePath.MIXED) {
                this.props.onChangeFillColor(_fillStyle.DEFAULT_COLOR);
                color = _fillStyle.DEFAULT_COLOR;
            }
            this.tool = new _brushTool2.default(this.props.onUpdateImage);
            this.tool.setColor(color);
            this.tool.setBrushSize(this.props.bitBrushSize);

            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_bitBrushMode2.default, {
                isSelected: this.props.isBitBrushModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return BitBrushMode;
}(_react2.default.Component);

BitBrushMode.propTypes = {
    bitBrushSize: _propTypes2.default.number.isRequired,
    clearGradient: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    color: _propTypes2.default.string,
    handleMouseDown: _propTypes2.default.func.isRequired,
    isBitBrushModeActive: _propTypes2.default.bool.isRequired,
    onChangeFillColor: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        bitBrushSize: state.scratchPaint.bitBrushSize,
        color: state.scratchPaint.color.fillColor.primary,
        isBitBrushModeActive: state.scratchPaint.mode === _modes2.default.BIT_BRUSH
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        clearGradient: function clearGradient() {
            dispatch((0, _fillStyle.clearFillGradient)());
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.BIT_BRUSH));
        },
        onChangeFillColor: function onChangeFillColor(fillColor) {
            dispatch((0, _fillStyle.changeFillColor)(fillColor));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(BitBrushMode);

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _brush = __webpack_require__(63);

var _brush2 = _interopRequireDefault(_brush);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BitBrushModeComponent = function BitBrushModeComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.brush,
        imgSrc: _brush2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

BitBrushModeComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = BitBrushModeComponent;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(109);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n.button_button_lmpwR {\n    background: none;\n    cursor: pointer;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n\n.button_button_lmpwR:active {\n    background-color: hsla(215, 100%, 65%, 0.20); \n}\n\n.button_highlighted_2c0Ir.button_button_lmpwR {\n    background-color: hsla(215, 100%, 65%, 0.20); \n}\n\n.button_mod-disabled_CFsZ2 {\n    cursor: auto;\n    opacity: .5;\n}\n\n.button_mod-disabled_CFsZ2:active {\n    background: none;\n}\n", ""]);
// Exports
exports.locals = {
	"button": "button_button_lmpwR",
	"highlighted": "button_highlighted_2c0Ir",
	"mod-disabled": "button_mod-disabled_CFsZ2",
	"modDisabled": "button_mod-disabled_CFsZ2"
};
module.exports = exports;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(111);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n.tool-select-base_mod-tool-select_1RQKn {\n    display: inline-block;\n    margin: .25rem;\n    border: none;\n    border-radius: .25rem;\n    outline: none;\n    background: none;\n    padding: .25rem;\n    font-size: 0.85rem;\n    -webkit-transition: 0.2s;\n    -o-transition: 0.2s;\n    transition: 0.2s;\n}\n\n.tool-select-base_mod-tool-select_1RQKn.tool-select-base_is-selected_3Le38 {\n    background-color: #4C97FF;\n}\n\n.tool-select-base_mod-tool-select_1RQKn:focus {\n    outline: none;\n}\n\nimg.tool-select-base_tool-select-icon_2TT3t {\n    width: 2rem;\n    height: 2rem;\n    -webkit-box-flex: 1;\n    -webkit-flex-grow: 1;\n        -ms-flex-positive: 1;\n            flex-grow: 1;\n    vertical-align: middle;\n}\n\n.tool-select-base_mod-tool-select_1RQKn.tool-select-base_is-selected_3Le38 .tool-select-base_tool-select-icon_2TT3t {\n    /* Make the tool icons white while selected by making them black and inverting */\n    -webkit-filter: brightness(0) invert(1);\n            filter: brightness(0) invert(1);\n}\n\n@media only screen and (max-width: 1256px) {\n    .tool-select-base_mod-tool-select_1RQKn {\n        margin: 0;\n    }\n}\n", ""]);
// Exports
exports.locals = {
	"mod-tool-select": "tool-select-base_mod-tool-select_1RQKn",
	"modToolSelect": "tool-select-base_mod-tool-select_1RQKn",
	"is-selected": "tool-select-base_is-selected_3Le38",
	"isSelected": "tool-select-base_is-selected_3Le38",
	"tool-select-icon": "tool-select-base_tool-select-icon_2TT3t",
	"toolSelectIcon": "tool-select-base_tool-select-icon_2TT3t"
};
module.exports = exports;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _stylePath = __webpack_require__(9);

var _fillStyle = __webpack_require__(18);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _selection = __webpack_require__(3);

var _bitLineMode = __webpack_require__(113);

var _bitLineMode2 = _interopRequireDefault(_bitLineMode);

var _lineTool = __webpack_require__(114);

var _lineTool2 = _interopRequireDefault(_lineTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BitLineMode = function (_React$Component) {
    _inherits(BitLineMode, _React$Component);

    function BitLineMode(props) {
        _classCallCheck(this, BitLineMode);

        var _this = _possibleConstructorReturn(this, (BitLineMode.__proto__ || Object.getPrototypeOf(BitLineMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(BitLineMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isBitLineModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool && nextProps.color !== this.props.color) {
                this.tool.setColor(nextProps.color);
            }
            if (this.tool && nextProps.bitBrushSize !== this.props.bitBrushSize) {
                this.tool.setLineSize(nextProps.bitBrushSize);
            }

            if (nextProps.isBitLineModeActive && !this.props.isBitLineModeActive) {
                this.activateTool();
            } else if (!nextProps.isBitLineModeActive && this.props.isBitLineModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isBitLineModeActive !== this.props.isBitLineModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            (0, _selection.clearSelection)(this.props.clearSelectedItems);
            this.props.clearGradient();
            // Force the default line color if fill is MIXED or transparent
            var color = this.props.color;
            if (!color || color === _stylePath.MIXED) {
                this.props.onChangeFillColor(_fillStyle.DEFAULT_COLOR);
                color = _fillStyle.DEFAULT_COLOR;
            }
            this.tool = new _lineTool2.default(this.props.onUpdateImage);
            this.tool.setColor(color);
            this.tool.setLineSize(this.props.bitBrushSize);

            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_bitLineMode2.default, {
                isSelected: this.props.isBitLineModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return BitLineMode;
}(_react2.default.Component);

BitLineMode.propTypes = {
    bitBrushSize: _propTypes2.default.number.isRequired,
    clearGradient: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    color: _propTypes2.default.string,
    handleMouseDown: _propTypes2.default.func.isRequired,
    isBitLineModeActive: _propTypes2.default.bool.isRequired,
    onChangeFillColor: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        bitBrushSize: state.scratchPaint.bitBrushSize,
        color: state.scratchPaint.color.fillColor.primary,
        isBitLineModeActive: state.scratchPaint.mode === _modes2.default.BIT_LINE
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        clearGradient: function clearGradient() {
            dispatch((0, _fillStyle.clearFillGradient)());
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.BIT_LINE));
        },
        onChangeFillColor: function onChangeFillColor(fillColor) {
            dispatch((0, _fillStyle.changeFillColor)(fillColor));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(BitLineMode);

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _line = __webpack_require__(65);

var _line2 = _interopRequireDefault(_line);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BitLineComponent = function BitLineComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.line,
        imgSrc: _line2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

BitLineComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = BitLineComponent;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _layer = __webpack_require__(12);

var _bitmap = __webpack_require__(21);

var _view = __webpack_require__(22);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tool for drawing lines with the bitmap brush.
 */
var LineTool = function (_paper$Tool) {
    _inherits(LineTool, _paper$Tool);

    /**
     * @param {!function} onUpdateImage A callback to call when the image visibly changes
     */
    function LineTool(onUpdateImage) {
        _classCallCheck(this, LineTool);

        var _this = _possibleConstructorReturn(this, (LineTool.__proto__ || Object.getPrototypeOf(LineTool)).call(this));

        _this.onUpdateImage = onUpdateImage;

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseMove = _this.handleMouseMove;
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseDrag = _this.handleMouseDrag;
        _this.onMouseUp = _this.handleMouseUp;

        _this.colorState = null;
        _this.active = false;
        _this.startPoint = null;
        _this.cursorPreview = null;
        // Raster to which to draw
        _this.drawTarget = null;
        return _this;
    }

    _createClass(LineTool, [{
        key: 'setColor',
        value: function setColor(color) {
            this.color = color;
            this.tmpCanvas = (0, _bitmap.getBrushMark)(this.size, this.color);
        }
    }, {
        key: 'setLineSize',
        value: function setLineSize(size) {
            // For performance, make sure this is an integer
            this.size = Math.max(1, ~~size);
            this.tmpCanvas = (0, _bitmap.getBrushMark)(this.size, this.color);
        }
        // Draw a brush mark at the given point

    }, {
        key: 'draw',
        value: function draw(x, y) {
            var roundedUpRadius = Math.ceil(this.size / 2);
            this.drawTarget.drawImage(this.tmpCanvas, new _paper2.default.Point(~~x - roundedUpRadius, ~~y - roundedUpRadius));
        }
    }, {
        key: 'updateCursorIfNeeded',
        value: function updateCursorIfNeeded() {
            if (!this.size) {
                return;
            }
            // The cursor preview was unattached from the view by an outside process,
            // such as changing costumes or undo.
            if (this.cursorPreview && !this.cursorPreview.parent) {
                this.cursorPreview = null;
            }

            if (!this.cursorPreview || !(this.lastSize === this.size && this.lastColor === this.color)) {
                if (this.cursorPreview) {
                    this.cursorPreview.remove();
                }

                this.tmpCanvas = (0, _bitmap.getBrushMark)(this.size, this.color);
                this.cursorPreview = new _paper2.default.Raster(this.tmpCanvas);
                this.cursorPreview.guide = true;
                this.cursorPreview.parent = (0, _layer.getGuideLayer)();
                this.cursorPreview.data.isHelperItem = true;
            }
            this.lastSize = this.size;
            this.lastColor = this.color;
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            this.updateCursorIfNeeded();
            this.cursorPreview.position = new _paper2.default.Point(~~event.point.x, ~~event.point.y);
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;

            if (this.cursorPreview) this.cursorPreview.remove();

            var tmpCanvas = (0, _layer.createCanvas)();
            this.drawTarget = new _paper2.default.Raster(tmpCanvas);
            this.drawTarget.parent = (0, _layer.getGuideLayer)();
            this.drawTarget.guide = true;
            this.drawTarget.locked = true;
            this.drawTarget.position = (0, _layer.getRaster)().position;

            this.draw(event.point.x, event.point.y);
            this.startPoint = event.point;
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            // Clear
            var context = this.drawTarget.canvas.getContext('2d');
            context.clearRect(0, 0, _view.ART_BOARD_WIDTH, _view.ART_BOARD_HEIGHT);

            (0, _bitmap.forEachLinePoint)(this.startPoint, event.point, this.draw.bind(this));
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            this.drawTarget.remove();
            this.drawTarget = (0, _layer.getRaster)();
            (0, _bitmap.forEachLinePoint)(this.startPoint, event.point, this.draw.bind(this));
            this.drawTarget = null;
            this.onUpdateImage();

            this.lastPoint = null;
            this.active = false;

            this.updateCursorIfNeeded();
            this.cursorPreview.position = new _paper2.default.Point(~~event.point.x, ~~event.point.y);
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.active = false;
            this.tmpCanvas = null;
            if (this.cursorPreview) {
                this.cursorPreview.remove();
                this.cursorPreview = null;
            }
        }
    }]);

    return LineTool;
}(_paper2.default.Tool);

exports.default = LineTool;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _colorStyleProptype = __webpack_require__(28);

var _colorStyleProptype2 = _interopRequireDefault(_colorStyleProptype);

var _stylePath = __webpack_require__(9);

var _fillStyle = __webpack_require__(18);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _cursor = __webpack_require__(25);

var _selection = __webpack_require__(3);

var _ovalTool = __webpack_require__(116);

var _ovalTool2 = _interopRequireDefault(_ovalTool);

var _bitOvalMode = __webpack_require__(119);

var _bitOvalMode2 = _interopRequireDefault(_bitOvalMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BitOvalMode = function (_React$Component) {
    _inherits(BitOvalMode, _React$Component);

    function BitOvalMode(props) {
        _classCallCheck(this, BitOvalMode);

        var _this = _possibleConstructorReturn(this, (BitOvalMode.__proto__ || Object.getPrototypeOf(BitOvalMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(BitOvalMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isOvalModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool) {
                if (nextProps.color !== this.props.color) {
                    this.tool.setColor(nextProps.color);
                }
                if (nextProps.selectedItems !== this.props.selectedItems) {
                    this.tool.onSelectionChanged(nextProps.selectedItems);
                }
                if (nextProps.filled !== this.props.filled) {
                    this.tool.setFilled(nextProps.filled);
                }
                if (nextProps.thickness !== this.props.thickness || nextProps.zoom !== this.props.zoom) {
                    this.tool.setThickness(nextProps.thickness);
                }
            }

            if (nextProps.isOvalModeActive && !this.props.isOvalModeActive) {
                this.activateTool();
            } else if (!nextProps.isOvalModeActive && this.props.isOvalModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isOvalModeActive !== this.props.isOvalModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            (0, _selection.clearSelection)(this.props.clearSelectedItems);
            // Force the default brush color if fill is MIXED or transparent
            var fillColorPresent = this.props.color.primary !== _stylePath.MIXED && this.props.color.primary !== null;
            if (!fillColorPresent) {
                this.props.onChangeFillColor(_fillStyle.DEFAULT_COLOR);
            }
            this.tool = new _ovalTool2.default(this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage);
            this.tool.setColor(this.props.color);
            this.tool.setFilled(this.props.filled);
            this.tool.setThickness(this.props.thickness);
            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_bitOvalMode2.default, {
                isSelected: this.props.isOvalModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return BitOvalMode;
}(_react2.default.Component);

BitOvalMode.propTypes = {
    clearSelectedItems: _propTypes2.default.func.isRequired,
    color: _colorStyleProptype2.default,
    filled: _propTypes2.default.bool,
    handleMouseDown: _propTypes2.default.func.isRequired,
    isOvalModeActive: _propTypes2.default.bool.isRequired,
    onChangeFillColor: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    selectedItems: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_paper2.default.Item)),
    setCursor: _propTypes2.default.func.isRequired,
    setSelectedItems: _propTypes2.default.func.isRequired,
    thickness: _propTypes2.default.number.isRequired,
    zoom: _propTypes2.default.number.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        color: state.scratchPaint.color.fillColor,
        filled: state.scratchPaint.fillBitmapShapes,
        isOvalModeActive: state.scratchPaint.mode === _modes2.default.BIT_OVAL,
        selectedItems: state.scratchPaint.selectedItems,
        thickness: state.scratchPaint.bitBrushSize,
        zoom: state.scratchPaint.viewBounds.scaling.x
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        setCursor: function setCursor(cursorString) {
            dispatch((0, _cursor.setCursor)(cursorString));
        },
        setSelectedItems: function setSelectedItems() {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), true /* bitmapMode */));
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.BIT_OVAL));
        },
        onChangeFillColor: function onChangeFillColor(fillColor) {
            dispatch((0, _fillStyle.changeFillColor)(fillColor));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(BitOvalMode);

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _stylePath = __webpack_require__(9);

var _bitmap = __webpack_require__(21);

var _layer = __webpack_require__(12);

var _selection = __webpack_require__(3);

var _math = __webpack_require__(20);

var _boundingBoxTool = __webpack_require__(29);

var _boundingBoxTool2 = _interopRequireDefault(_boundingBoxTool);

var _nudgeTool = __webpack_require__(30);

var _nudgeTool2 = _interopRequireDefault(_nudgeTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tool for drawing ovals.
 */
var OvalTool = function (_paper$Tool) {
    _inherits(OvalTool, _paper$Tool);

    _createClass(OvalTool, null, [{
        key: 'TOLERANCE',
        get: function get() {
            return 2;
        }
        /**
         * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
         * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
         * @param {function} setCursor Callback to set the visible mouse cursor
         * @param {!function} onUpdateImage A callback to call when the image visibly changes
         */

    }]);

    function OvalTool(setSelectedItems, clearSelectedItems, setCursor, onUpdateImage) {
        _classCallCheck(this, OvalTool);

        var _this = _possibleConstructorReturn(this, (OvalTool.__proto__ || Object.getPrototypeOf(OvalTool)).call(this));

        _this.setSelectedItems = setSelectedItems;
        _this.clearSelectedItems = clearSelectedItems;
        _this.onUpdateImage = onUpdateImage;
        _this.boundingBoxTool = new _boundingBoxTool2.default(_modes2.default.BIT_OVAL, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);
        var nudgeTool = new _nudgeTool2.default(_modes2.default.BIT_OVAL, _this.boundingBoxTool, onUpdateImage);

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseDrag = _this.handleMouseDrag;
        _this.onMouseMove = _this.handleMouseMove;
        _this.onMouseUp = _this.handleMouseUp;
        _this.onKeyUp = nudgeTool.onKeyUp;
        _this.onKeyDown = nudgeTool.onKeyDown;

        _this.oval = null;
        _this.color = null;
        _this.active = false;
        return _this;
    }

    _createClass(OvalTool, [{
        key: 'getHitOptions',
        value: function getHitOptions() {
            return {
                segments: false,
                stroke: true,
                curves: false,
                fill: true,
                guide: false,
                match: function match(hitResult) {
                    return hitResult.item.data && (hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle) || hitResult.item.selected;
                }, // Allow hits on bounding box and selected only
                tolerance: OvalTool.TOLERANCE / _paper2.default.view.zoom
            };
        }
        /**
         * Should be called if the selection changes to update the bounds of the bounding box.
         * @param {Array<paper.Item>} selectedItems Array of selected items.
         */

    }, {
        key: 'onSelectionChanged',
        value: function onSelectionChanged(selectedItems) {
            this.boundingBoxTool.onSelectionChanged(selectedItems);
            if ((!this.oval || !this.oval.isInserted()) && selectedItems && selectedItems.length === 1 && selectedItems[0].shape === 'ellipse') {
                // Infer that an undo occurred and get back the active oval
                this.oval = selectedItems[0];
                if (this.oval.data.zoomLevel !== _paper2.default.view.zoom) {
                    this.oval.strokeWidth = this.oval.strokeWidth / this.oval.data.zoomLevel * _paper2.default.view.zoom;
                    this.oval.data.zoomLevel = _paper2.default.view.zoom;
                    this.thickness = this.oval.strokeWidth;
                }
                this.filled = this.oval.strokeWidth === 0;
                // We don't need to set our color from the selected oval's color because the color state reducers will
                // do that for us every time the selection changes.
            } else if (this.oval && this.oval.isInserted() && !this.oval.selected) {
                // Oval got deselected
                this.commitOval();
            }
        }
    }, {
        key: 'styleOval',
        value: function styleOval() {
            (0, _stylePath.styleShape)(this.oval, {
                fillColor: this.filled ? this.color : null,
                strokeColor: this.filled ? null : this.color,
                strokeWidth: this.filled ? 0 : this.thickness
            });
        }
    }, {
        key: 'setColor',
        value: function setColor(color) {
            this.color = color;
            if (this.oval) this.styleOval();
        }
    }, {
        key: 'setFilled',
        value: function setFilled(filled) {
            if (this.filled === filled) return;
            this.filled = filled;
            if (this.oval && this.oval.isInserted()) {
                this.styleOval();
                this.onUpdateImage();
            }
        }
    }, {
        key: 'setThickness',
        value: function setThickness(thickness) {
            if (this.thickness === thickness * _paper2.default.view.zoom) return;
            this.thickness = thickness * _paper2.default.view.zoom;
            if (this.oval && this.oval.isInserted() && !this.filled) {
                this.oval.strokeWidth = this.thickness;
            }
            if (this.oval && this.oval.isInserted()) {
                this.oval.data.zoomLevel = _paper2.default.view.zoom;
                this.onUpdateImage();
            }
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;

            if (this.boundingBoxTool.onMouseDown(event, false /* clone */, false /* multiselect */, false /* doubleClicked */, this.getHitOptions())) {
                this.isBoundingBoxMode = true;
            } else {
                this.isBoundingBoxMode = false;
                (0, _selection.clearSelection)(this.clearSelectedItems);
                this.commitOval();
                this.oval = new _paper2.default.Shape.Ellipse({
                    point: event.downPoint,
                    size: 0,
                    strokeScaling: false
                });
                this.styleOval();
                this.oval.data = { zoomLevel: _paper2.default.view.zoom };
            }
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.isBoundingBoxMode) {
                this.boundingBoxTool.onMouseDrag(event);
                return;
            }

            var downPoint = new _paper2.default.Point(event.downPoint.x, event.downPoint.y);
            var point = new _paper2.default.Point(event.point.x, event.point.y);
            var squareDimensions = (0, _math.getSquareDimensions)(event.downPoint, event.point);
            if (event.modifiers.shift) {
                this.oval.size = squareDimensions.size.abs();
            } else {
                this.oval.size = downPoint.subtract(point);
            }

            if (event.modifiers.alt) {
                this.oval.position = downPoint;
            } else if (event.modifiers.shift) {
                this.oval.position = squareDimensions.position;
            } else {
                this.oval.position = downPoint.subtract(this.oval.size.multiply(0.5));
            }
            this.styleOval();
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            this.boundingBoxTool.onMouseMove(event, this.getHitOptions());
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.isBoundingBoxMode) {
                this.boundingBoxTool.onMouseUp(event);
                this.isBoundingBoxMode = null;
                return;
            }

            if (this.oval) {
                if (Math.abs(this.oval.size.width * this.oval.size.height) < OvalTool.TOLERANCE / _paper2.default.view.zoom) {
                    // Tiny oval created unintentionally?
                    this.oval.remove();
                    this.oval = null;
                } else {
                    // Hit testing does not work correctly unless the width and height are positive
                    this.oval.size = new _paper2.default.Point(Math.abs(this.oval.size.width), Math.abs(this.oval.size.height));
                    this.oval.selected = true;
                    this.styleOval();
                    this.setSelectedItems();
                }
            }
            this.active = false;
            this.onUpdateImage();
        }
    }, {
        key: 'commitOval',
        value: function commitOval() {
            if (!this.oval || !this.oval.isInserted()) return;

            (0, _bitmap.commitOvalToBitmap)(this.oval, (0, _layer.getRaster)());
            this.oval.remove();
            this.oval = null;
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.commitOval();
            this.boundingBoxTool.deactivateTool();
        }
    }]);

    return OvalTool;
}(_paper2.default.Tool);

exports.default = OvalTool;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _selection = __webpack_require__(3);

var _view = __webpack_require__(22);

var _modes = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MIN_SCALE_FACTOR = 0.0001;

/**
 * Tool to handle scaling items by pulling on the handles around the edges of the bounding
 * box when in the bounding box tool.
 */

var ScaleTool = function () {
    /**
     * @param {Mode} mode Paint editor mode
     * @param {!function} onUpdateImage A callback to call when the image visibly changes
     */
    function ScaleTool(mode, onUpdateImage) {
        _classCallCheck(this, ScaleTool);

        this.isBitmap = mode in _modes.BitmapModes;
        this.active = false;
        this.boundsPath = null;
        this.pivot = null;
        this.origPivot = null;
        this.corner = null;
        this.origSize = null;
        this.origCenter = null;
        this.itemGroup = null;
        // Lowest item above all scale items in z index
        this.itemToInsertBelow = null;
        this.lastPoint = null;
        this.onUpdateImage = onUpdateImage;
    }

    /**
     * @param {!paper.HitResult} hitResult Data about the location of the mouse click
     * @param {!object} boundsPath Where the boundaries of the hit item are
     * @param {!Array.<paper.Item>} selectedItems Set of selected paper.Items
     */


    _createClass(ScaleTool, [{
        key: 'onMouseDown',
        value: function onMouseDown(hitResult, boundsPath, selectedItems) {
            if (this.active) return;
            this.active = true;

            var index = hitResult.item.data.index;
            this.pivot = boundsPath.bounds[this._getOpposingRectCornerNameByIndex(index)].clone();
            this.origPivot = boundsPath.bounds[this._getOpposingRectCornerNameByIndex(index)].clone();
            this.corner = boundsPath.bounds[this._getRectCornerNameByIndex(index)].clone();
            this.selectionAnchor = boundsPath.selectionAnchor;
            this.origSize = this.corner.subtract(this.pivot);
            this.origCenter = boundsPath.bounds.center;
            this.isCorner = this._isCorner(index);
            this.centered = false;
            this.lastSx = 1;
            this.lastSy = 1;
            this.boundsPath = boundsPath;

            // Set itemGroup
            // get item to insert below so that scaled items stay in same z position
            var items = (0, _selection.getItems)({
                match: function match(item) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = selectedItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var scaleItem = _step.value;

                            if (!scaleItem.isBelow(item)) {
                                return false;
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    return true;
                }
            });
            if (items.length > 0) {
                this.itemToInsertBelow = items[0];
            }

            this.itemGroup = new _paper2.default.Group(selectedItems);
            this.itemGroup.addChild(boundsPath);
            this.itemGroup.insertBelow(this.itemToInsertBelow);
            this.itemGroup.data.isHelperItem = true;
        }
    }, {
        key: 'onMouseDrag',
        value: function onMouseDrag(event) {
            if (!this.active) return;
            var point = event.point;
            var bounds = (0, _view.getActionBounds)(this.isBitmap);
            point.x = Math.max(bounds.left, Math.min(point.x, bounds.right));
            point.y = Math.max(bounds.top, Math.min(point.y, bounds.bottom));

            if (!this.lastPoint) this.lastPoint = event.lastPoint;
            var delta = point.subtract(this.lastPoint);
            this.lastPoint = point;

            if (event.modifiers.alt) {
                this.centered = true;
                this.itemGroup.position = this.origCenter;
                this.pivot = this.origCenter;
            } else {
                if (this.centered) {
                    // Reset position if we were just in alt
                    this.centered = false;
                    this.itemGroup.scale(1 / this.lastSx, 1 / this.lastSy, this.pivot);
                    if (this.selectionAnchor) {
                        this.selectionAnchor.scale(this.lastSx, this.lastSy);
                    }
                    this.lastSx = 1;
                    this.lastSy = 1;
                }
                this.pivot = this.origPivot;
            }

            this.corner = this.corner.add(delta);
            var size = this.corner.subtract(this.pivot);
            if (event.modifiers.alt) {
                size = size.multiply(2);
            }
            var sx = 1.0;
            var sy = 1.0;
            if (Math.abs(this.origSize.x) > 0.0000001) {
                sx = size.x / this.origSize.x;
            }
            if (Math.abs(this.origSize.y) > 0.0000001) {
                sy = size.y / this.origSize.y;
            }

            var signx = sx > 0 ? 1 : -1;
            var signy = sy > 0 ? 1 : -1;
            if (this.isCorner && !event.modifiers.shift) {
                sx = sy = Math.max(Math.abs(sx), Math.abs(sy));
                sx *= signx;
                sy *= signy;
            }
            sx = signx * Math.max(Math.abs(sx), MIN_SCALE_FACTOR);
            sy = signy * Math.max(Math.abs(sy), MIN_SCALE_FACTOR);
            this.itemGroup.scale(sx / this.lastSx, sy / this.lastSy, this.pivot);
            if (this.selectionAnchor) {
                this.selectionAnchor.scale(this.lastSx / sx, this.lastSy / sy);
            }
            this.lastSx = sx;
            this.lastSy = sy;
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp() {
            if (!this.active) return;
            this.lastPoint = null;

            this.pivot = null;
            this.origPivot = null;
            this.corner = null;
            this.origSize = null;
            this.origCenter = null;
            this.lastSx = 1;
            this.lastSy = 1;
            this.centered = false;

            if (!this.itemGroup) {
                return;
            }
            this.boundsPath.remove();
            this.boundsPath = null;

            // mark text items as scaled (for later use on font size calc)
            for (var i = 0; i < this.itemGroup.children.length; i++) {
                var child = this.itemGroup.children[i];
                if (child.data.isPGTextItem) {
                    child.data.wasScaled = true;
                }
            }

            if (this.itemToInsertBelow) {
                // No increment step because itemGroup.children is getting depleted
                for (var _i = 0; _i < this.itemGroup.children.length;) {
                    this.itemGroup.children[_i].insertBelow(this.itemToInsertBelow);
                }
                this.itemToInsertBelow = null;
            } else if (this.itemGroup.layer) {
                this.itemGroup.layer.addChildren(this.itemGroup.children);
            }
            this.itemGroup.remove();

            this.onUpdateImage();
            this.active = false;
        }
    }, {
        key: '_getRectCornerNameByIndex',
        value: function _getRectCornerNameByIndex(index) {
            switch (index) {
                case 0:
                    return 'bottomLeft';
                case 1:
                    return 'leftCenter';
                case 2:
                    return 'topLeft';
                case 3:
                    return 'topCenter';
                case 4:
                    return 'topRight';
                case 5:
                    return 'rightCenter';
                case 6:
                    return 'bottomRight';
                case 7:
                    return 'bottomCenter';
            }
        }
    }, {
        key: '_getOpposingRectCornerNameByIndex',
        value: function _getOpposingRectCornerNameByIndex(index) {
            switch (index) {
                case 0:
                    return 'topRight';
                case 1:
                    return 'rightCenter';
                case 2:
                    return 'bottomRight';
                case 3:
                    return 'bottomCenter';
                case 4:
                    return 'bottomLeft';
                case 5:
                    return 'leftCenter';
                case 6:
                    return 'topLeft';
                case 7:
                    return 'topCenter';
            }
        }
    }, {
        key: '_isCorner',
        value: function _isCorner(index) {
            switch (index) {
                case 0:
                case 2:
                case 4:
                case 6:
                    return true;
                default:
                    return false;
            }
        }
    }]);

    return ScaleTool;
}();

exports.default = ScaleTool;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tool to handle rotation when dragging the rotation handle in the bounding box tool.
 */
var RotateTool = function () {
    /**
     * @param {!function} onUpdateImage A callback to call when the image visibly changes
     */
    function RotateTool(onUpdateImage) {
        _classCallCheck(this, RotateTool);

        this.rotItems = [];
        this.rotGroupPivot = null;
        this.prevRot = 90;
        this.onUpdateImage = onUpdateImage;
    }

    /**
     * @param {!paper.HitResult} hitResult Data about the location of the mouse click
     * @param {!object} boundsPath Where the boundaries of the hit item are
     * @param {!Array.<paper.Item>} selectedItems Set of selected paper.Items
     */


    _createClass(RotateTool, [{
        key: 'onMouseDown',
        value: function onMouseDown(hitResult, boundsPath, selectedItems) {
            this.rotGroupPivot = boundsPath.bounds.center;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = selectedItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var item = _step.value;

                    // Rotate only root items
                    if (item.parent instanceof _paper2.default.Layer) {
                        this.rotItems.push(item);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.prevRot = 90;
        }
    }, {
        key: 'onMouseDrag',
        value: function onMouseDrag(event) {
            var rotAngle = event.point.subtract(this.rotGroupPivot).angle;
            if (event.modifiers.shift) {
                rotAngle = Math.round(rotAngle / 45) * 45;
            }

            for (var i = 0; i < this.rotItems.length; i++) {
                var item = this.rotItems[i];

                item.rotate(rotAngle - this.prevRot, this.rotGroupPivot);
            }

            this.prevRot = rotAngle;
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp(event) {
            if (event.event.button > 0) return; // only first mouse button

            this.rotItems.length = 0;
            this.rotGroupPivot = null;
            this.prevRot = 90;

            this.onUpdateImage();
        }
    }]);

    return RotateTool;
}();

exports.default = RotateTool;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _oval = __webpack_require__(68);

var _oval2 = _interopRequireDefault(_oval);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BitOvalComponent = function BitOvalComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.oval,
        imgSrc: _oval2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

BitOvalComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = BitOvalComponent;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _colorStyleProptype = __webpack_require__(28);

var _colorStyleProptype2 = _interopRequireDefault(_colorStyleProptype);

var _stylePath = __webpack_require__(9);

var _fillStyle = __webpack_require__(18);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _cursor = __webpack_require__(25);

var _selection = __webpack_require__(3);

var _rectTool = __webpack_require__(121);

var _rectTool2 = _interopRequireDefault(_rectTool);

var _bitRectMode = __webpack_require__(122);

var _bitRectMode2 = _interopRequireDefault(_bitRectMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BitRectMode = function (_React$Component) {
    _inherits(BitRectMode, _React$Component);

    function BitRectMode(props) {
        _classCallCheck(this, BitRectMode);

        var _this = _possibleConstructorReturn(this, (BitRectMode.__proto__ || Object.getPrototypeOf(BitRectMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(BitRectMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isRectModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool) {
                if (nextProps.color !== this.props.color) {
                    this.tool.setColor(nextProps.color);
                }
                if (nextProps.selectedItems !== this.props.selectedItems) {
                    this.tool.onSelectionChanged(nextProps.selectedItems);
                }
                if (nextProps.filled !== this.props.filled) {
                    this.tool.setFilled(nextProps.filled);
                }
                if (nextProps.thickness !== this.props.thickness || nextProps.zoom !== this.props.zoom) {
                    this.tool.setThickness(nextProps.thickness);
                }
            }

            if (nextProps.isRectModeActive && !this.props.isRectModeActive) {
                this.activateTool();
            } else if (!nextProps.isRectModeActive && this.props.isRectModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isRectModeActive !== this.props.isRectModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            (0, _selection.clearSelection)(this.props.clearSelectedItems);
            // Force the default brush color if fill is MIXED or transparent
            var fillColorPresent = this.props.color.primary !== _stylePath.MIXED && this.props.color.primary !== null;
            if (!fillColorPresent) {
                this.props.onChangeFillColor(_fillStyle.DEFAULT_COLOR);
            }
            this.tool = new _rectTool2.default(this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage);
            this.tool.setColor(this.props.color);
            this.tool.setFilled(this.props.filled);
            this.tool.setThickness(this.props.thickness);
            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_bitRectMode2.default, {
                isSelected: this.props.isRectModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return BitRectMode;
}(_react2.default.Component);

BitRectMode.propTypes = {
    clearSelectedItems: _propTypes2.default.func.isRequired,
    color: _colorStyleProptype2.default,
    filled: _propTypes2.default.bool,
    handleMouseDown: _propTypes2.default.func.isRequired,
    isRectModeActive: _propTypes2.default.bool.isRequired,
    onChangeFillColor: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    selectedItems: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_paper2.default.Item)),
    setCursor: _propTypes2.default.func.isRequired,
    setSelectedItems: _propTypes2.default.func.isRequired,
    thickness: _propTypes2.default.number.isRequired,
    zoom: _propTypes2.default.number.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        color: state.scratchPaint.color.fillColor,
        filled: state.scratchPaint.fillBitmapShapes,
        isRectModeActive: state.scratchPaint.mode === _modes2.default.BIT_RECT,
        selectedItems: state.scratchPaint.selectedItems,
        thickness: state.scratchPaint.bitBrushSize,
        zoom: state.scratchPaint.viewBounds.scaling.x
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        setCursor: function setCursor(cursorString) {
            dispatch((0, _cursor.setCursor)(cursorString));
        },
        setSelectedItems: function setSelectedItems() {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), true /* bitmapMode */));
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.BIT_RECT));
        },
        onChangeFillColor: function onChangeFillColor(fillColor) {
            dispatch((0, _fillStyle.changeFillColor)(fillColor));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(BitRectMode);

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _stylePath = __webpack_require__(9);

var _bitmap = __webpack_require__(21);

var _layer = __webpack_require__(12);

var _selection = __webpack_require__(3);

var _math = __webpack_require__(20);

var _boundingBoxTool = __webpack_require__(29);

var _boundingBoxTool2 = _interopRequireDefault(_boundingBoxTool);

var _nudgeTool = __webpack_require__(30);

var _nudgeTool2 = _interopRequireDefault(_nudgeTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tool for drawing rects.
 */
var RectTool = function (_paper$Tool) {
    _inherits(RectTool, _paper$Tool);

    _createClass(RectTool, null, [{
        key: 'TOLERANCE',
        get: function get() {
            return 2;
        }
        /**
         * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
         * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
         * @param {function} setCursor Callback to set the visible mouse cursor
         * @param {!function} onUpdateImage A callback to call when the image visibly changes
         */

    }]);

    function RectTool(setSelectedItems, clearSelectedItems, setCursor, onUpdateImage) {
        _classCallCheck(this, RectTool);

        var _this = _possibleConstructorReturn(this, (RectTool.__proto__ || Object.getPrototypeOf(RectTool)).call(this));

        _this.setSelectedItems = setSelectedItems;
        _this.clearSelectedItems = clearSelectedItems;
        _this.onUpdateImage = onUpdateImage;
        _this.boundingBoxTool = new _boundingBoxTool2.default(_modes2.default.BIT_RECT, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);
        var nudgeTool = new _nudgeTool2.default(_modes2.default.BIT_RECT, _this.boundingBoxTool, onUpdateImage);

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseDrag = _this.handleMouseDrag;
        _this.onMouseMove = _this.handleMouseMove;
        _this.onMouseUp = _this.handleMouseUp;
        _this.onKeyUp = nudgeTool.onKeyUp;
        _this.onKeyDown = nudgeTool.onKeyDown;

        _this.rect = null;
        _this.color = null;
        _this.active = false;
        return _this;
    }

    _createClass(RectTool, [{
        key: 'getHitOptions',
        value: function getHitOptions() {
            return {
                segments: false,
                stroke: true,
                curves: false,
                fill: true,
                guide: false,
                match: function match(hitResult) {
                    return hitResult.item.data && (hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle) || hitResult.item.selected;
                }, // Allow hits on bounding box and selected only
                tolerance: RectTool.TOLERANCE / _paper2.default.view.zoom
            };
        }
        /**
         * Should be called if the selection changes to update the bounds of the bounding box.
         * @param {Array<paper.Item>} selectedItems Array of selected items.
         */

    }, {
        key: 'onSelectionChanged',
        value: function onSelectionChanged(selectedItems) {
            this.boundingBoxTool.onSelectionChanged(selectedItems);
            if ((!this.rect || !this.rect.isInserted()) && selectedItems && selectedItems.length === 1 && selectedItems[0].shape === 'rectangle') {
                // Infer that an undo occurred and get back the active rect
                this.rect = selectedItems[0];
                if (this.rect.data.zoomLevel !== _paper2.default.view.zoom) {
                    this.rect.strokeWidth = this.rect.strokeWidth / this.rect.data.zoomLevel * _paper2.default.view.zoom;
                    this.rect.data.zoomLevel = _paper2.default.view.zoom;
                    this.thickness = this.rect.strokeWidth;
                }
                this.filled = this.rect.strokeWidth === 0;
            } else if (this.rect && this.rect.isInserted() && !this.rect.selected) {
                // Rectangle got deselected
                this.commitRect();
            }
        }
    }, {
        key: 'styleRect',
        value: function styleRect() {
            (0, _stylePath.styleShape)(this.rect, {
                fillColor: this.filled ? this.color : null,
                strokeColor: this.filled ? null : this.color,
                strokeWidth: this.filled ? 0 : this.thickness
            });
        }
    }, {
        key: 'setColor',
        value: function setColor(color) {
            this.color = color;
            if (this.rect) this.styleRect();
        }
    }, {
        key: 'setFilled',
        value: function setFilled(filled) {
            if (this.filled === filled) return;
            this.filled = filled;
            if (this.rect && this.rect.isInserted()) {
                this.styleRect();
                this.onUpdateImage();
            }
        }
    }, {
        key: 'setThickness',
        value: function setThickness(thickness) {
            if (this.thickness === thickness * _paper2.default.view.zoom) return;
            this.thickness = thickness * _paper2.default.view.zoom;
            if (this.rect && this.rect.isInserted() && !this.filled) {
                this.rect.strokeWidth = this.thickness;
            }
            if (this.rect && this.rect.isInserted()) {
                this.rect.data.zoomLevel = _paper2.default.view.zoom;
                this.onUpdateImage();
            }
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;

            if (this.boundingBoxTool.onMouseDown(event, false /* clone */, false /* multiselect */, false /* doubleClicked */, this.getHitOptions())) {
                this.isBoundingBoxMode = true;
            } else {
                this.isBoundingBoxMode = false;
                (0, _selection.clearSelection)(this.clearSelectedItems);
                this.commitRect();
            }
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.isBoundingBoxMode) {
                this.boundingBoxTool.onMouseDrag(event);
                return;
            }

            var dimensions = event.point.subtract(event.downPoint);
            var baseRect = new _paper2.default.Rectangle(event.downPoint, event.point);
            var squareDimensions = (0, _math.getSquareDimensions)(event.downPoint, event.point);
            if (event.modifiers.shift) {
                baseRect.size = squareDimensions.size.abs();
            }

            if (this.rect) this.rect.remove();
            this.rect = new _paper2.default.Shape.Rectangle(baseRect);
            this.rect.strokeJoin = 'round';
            this.rect.strokeScaling = false;
            this.rect.data = { zoomLevel: _paper2.default.view.zoom };
            this.styleRect();

            if (event.modifiers.alt) {
                this.rect.position = event.downPoint;
            } else if (event.modifiers.shift) {
                this.rect.position = squareDimensions.position;
            } else {
                this.rect.position = event.downPoint.add(dimensions.multiply(.5));
            }
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            this.boundingBoxTool.onMouseMove(event, this.getHitOptions());
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.isBoundingBoxMode) {
                this.boundingBoxTool.onMouseUp(event);
                this.isBoundingBoxMode = null;
                return;
            }

            if (this.rect) {
                if (Math.abs(this.rect.size.width * this.rect.size.height) < RectTool.TOLERANCE / _paper2.default.view.zoom) {
                    // Tiny shape created unintentionally?
                    this.rect.remove();
                    this.rect = null;
                } else {
                    // Hit testing does not work correctly unless the width and height are positive
                    this.rect.size = new _paper2.default.Point(Math.abs(this.rect.size.width), Math.abs(this.rect.size.height));
                    this.rect.selected = true;
                    this.styleRect();
                    this.setSelectedItems();
                }
            }
            this.active = false;
            this.onUpdateImage();
        }
    }, {
        key: 'commitRect',
        value: function commitRect() {
            if (!this.rect || !this.rect.isInserted()) return;

            (0, _bitmap.commitRectToBitmap)(this.rect, (0, _layer.getRaster)());

            this.rect.remove();
            this.rect = null;
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.commitRect();
            this.boundingBoxTool.deactivateTool();
        }
    }]);

    return RectTool;
}(_paper2.default.Tool);

exports.default = RectTool;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _rectangle = __webpack_require__(69);

var _rectangle2 = _interopRequireDefault(_rectangle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BitRectComponent = function BitRectComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.rect,
        imgSrc: _rectangle2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

BitRectComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = BitRectComponent;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _bitFillMode = __webpack_require__(124);

var _bitFillMode2 = _interopRequireDefault(_bitFillMode);

var _fillStyle = __webpack_require__(18);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _fillModeGradientType = __webpack_require__(41);

var _selection = __webpack_require__(3);

var _fillTool = __webpack_require__(126);

var _fillTool2 = _interopRequireDefault(_fillTool);

var _stylePath = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BitFillMode = function (_React$Component) {
    _inherits(BitFillMode, _React$Component);

    function BitFillMode(props) {
        _classCallCheck(this, BitFillMode);

        var _this = _possibleConstructorReturn(this, (BitFillMode.__proto__ || Object.getPrototypeOf(BitFillMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(BitFillMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isFillModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool) {
                if (nextProps.color !== this.props.color) {
                    this.tool.setColor(nextProps.color);
                }
                if (nextProps.color2 !== this.props.color2) {
                    this.tool.setColor2(nextProps.color2);
                }
                if (nextProps.fillModeGradientType !== this.props.fillModeGradientType) {
                    this.tool.setGradientType(nextProps.fillModeGradientType);
                }
            }

            if (nextProps.isFillModeActive && !this.props.isFillModeActive) {
                this.activateTool();
            } else if (!nextProps.isFillModeActive && this.props.isFillModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isFillModeActive !== this.props.isFillModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            (0, _selection.clearSelection)(this.props.clearSelectedItems);

            // Force the default brush color if fill is MIXED or transparent
            var color = this.props.color;
            if (this.props.color === _stylePath.MIXED) {
                color = _fillStyle.DEFAULT_COLOR;
                this.props.onChangeFillColor(_fillStyle.DEFAULT_COLOR, 0);
            }
            var gradientType = this.props.fillModeGradientType ? this.props.fillModeGradientType : this.props.styleGradientType;
            var color2 = this.props.color2;
            if (gradientType !== this.props.styleGradientType) {
                if (this.props.styleGradientType === _gradientTypes2.default.SOLID) {
                    color2 = (0, _stylePath.generateSecondaryColor)(color);
                    this.props.onChangeFillColor(color2, 1);
                }
                this.props.changeGradientType(gradientType);
            }
            if (this.props.color2 === _stylePath.MIXED) {
                color2 = (0, _stylePath.generateSecondaryColor)();
                this.props.onChangeFillColor(color2, 1);
            }
            this.tool = new _fillTool2.default(this.props.onUpdateImage);
            this.tool.setColor(color);
            this.tool.setColor2(color2);
            this.tool.setGradientType(gradientType);
            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_bitFillMode2.default, {
                isSelected: this.props.isFillModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return BitFillMode;
}(_react2.default.Component);

BitFillMode.propTypes = {
    changeGradientType: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    color: _propTypes2.default.string,
    color2: _propTypes2.default.string,
    styleGradientType: _propTypes2.default.oneOf(Object.keys(_gradientTypes2.default)).isRequired,
    fillModeGradientType: _propTypes2.default.oneOf(Object.keys(_gradientTypes2.default)),
    handleMouseDown: _propTypes2.default.func.isRequired,
    isFillModeActive: _propTypes2.default.bool.isRequired,
    onChangeFillColor: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        fillModeGradientType: state.scratchPaint.fillMode.gradientType, // Last user-selected gradient type
        color: state.scratchPaint.color.fillColor.primary,
        color2: state.scratchPaint.color.fillColor.secondary,
        styleGradientType: state.scratchPaint.color.fillColor.gradientType,
        isFillModeActive: state.scratchPaint.mode === _modes2.default.BIT_FILL
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        changeGradientType: function changeGradientType(gradientType) {
            dispatch((0, _fillModeGradientType.changeGradientType)(gradientType));
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.BIT_FILL));
        },
        onChangeFillColor: function onChangeFillColor(fillColor, index) {
            if (index === 0) {
                dispatch((0, _fillStyle.changeFillColor)(fillColor));
            } else if (index === 1) {
                dispatch((0, _fillStyle.changeFillColor2)(fillColor));
            }
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(BitFillMode);

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _fill = __webpack_require__(125);

var _fill2 = _interopRequireDefault(_fill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BitFillComponent = function BitFillComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.fill,
        imgSrc: _fill2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

BitFillComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = BitFillComponent;

/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Efill%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='fill' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cpath d='M10.7000634,5.80137446 L9.29979614,5.80137446 L9.29979614,8.59994895 L7.89980891,8.59994895 L7.89980891,4.39998724 L6.49982167,4.39998724 L6.49982167,5.80137446 L5.09983443,5.80137446 L5.09983443,3 L9.29979614,3 L9.29979614,4.39998724 L10.7011834,4.39998724 L10.7011834,5.80123446 L12.1000506,5.80123446 L12.1000506,7.2012217 L10.7000634,7.2012217 L10.7000634,5.80137446 Z M5.10011443,8.60120894 L5.10011443,7.2012217 L6.50010167,7.2012217 L6.50010167,8.60120894 L5.10011443,8.60120894 Z M16.3000123,16.9997324 L16.3000123,10.0011962 L17.6999996,10.0011962 L17.6999996,16.9997324 L16.3000123,16.9997324 Z M12.1003306,7.20080171 L13.5003179,7.20080171 L13.5003179,8.60078894 L16.3002923,8.60078894 L16.3002923,10.0007762 L14.9003051,10.0007762 L14.9003051,11.3573638 L13.5003179,11.3573638 L13.5003179,12.758751 L12.1003306,12.758751 L12.1003306,14.1587383 L10.7003434,14.1587383 L10.7003434,15.5587255 L9.29895615,15.5587255 L9.29895615,16.9587128 L7.89896891,16.9587128 L7.89896891,15.5587255 L6.49898168,15.5587255 L6.49898168,14.1587383 L5.10039442,14.1587383 L5.10039442,12.758751 L3.70040719,12.758751 L3.70040719,11.3573638 L6.49898168,11.3573638 L6.49898168,11.3713637 L9.29895615,11.3713637 L9.29895615,10.0007762 L12.1003306,10.0007762 L12.1003306,7.20080171 Z M3.69998719,8.60064895 L5.09997443,8.60064895 L5.09997443,10.0006362 L3.69998719,10.0006362 L3.69998719,11.3572238 L2.29999995,11.3572238 L2.29999995,9.95723658 L3.69998719,9.95723658 L3.69998719,8.60064895 Z' id='Combined-Shape' fill='%23575E75'%3E%3C/path%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _bitmap = __webpack_require__(21);

var _stylePath = __webpack_require__(9);

var _layer = __webpack_require__(12);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TRANSPARENT = 'rgba(0,0,0,0)';
/**
 * Tool for drawing fills.
 */

var FillTool = function (_paper$Tool) {
    _inherits(FillTool, _paper$Tool);

    /**
     * @param {!function} onUpdateImage A callback to call when the image visibly changes
     */
    function FillTool(onUpdateImage) {
        _classCallCheck(this, FillTool);

        var _this = _possibleConstructorReturn(this, (FillTool.__proto__ || Object.getPrototypeOf(FillTool)).call(this));

        _this.onUpdateImage = onUpdateImage;

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseDrag = _this.handleMouseDrag;

        _this.color = null;
        _this.color2 = null;
        _this.gradientType = null;
        _this.active = false;
        return _this;
    }

    _createClass(FillTool, [{
        key: 'setColor',
        value: function setColor(color) {
            this.color = color;
        }
    }, {
        key: 'setColor2',
        value: function setColor2(color2) {
            this.color2 = color2;
        }
    }, {
        key: 'setGradientType',
        value: function setGradientType(gradientType) {
            this.gradientType = gradientType;
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            this.paint(event);
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            this.paint(event);
        }
    }, {
        key: 'paint',
        value: function paint(event) {
            var _this2 = this;

            var sourceContext = (0, _layer.getRaster)().getContext('2d');
            var destContext = sourceContext;
            var color = this.color;
            // Paint to a mask instead of the original canvas when drawing
            if (this.gradientType !== _gradientTypes2.default.SOLID) {
                var tmpCanvas = (0, _layer.createCanvas)();
                destContext = tmpCanvas.getContext('2d');
                color = 'black';
            } else if (!color) {
                // Null color means transparent because that is the standard in vector
                color = TRANSPARENT;
            }
            var changed = false;
            if (event.event.shiftKey) {
                changed = (0, _bitmap.floodFillAll)(event.point.x, event.point.y, color, sourceContext, destContext);
            } else {
                changed = (0, _bitmap.floodFill)(event.point.x, event.point.y, color, sourceContext, destContext);
            }
            if (changed && this.gradientType !== _gradientTypes2.default.SOLID) {
                var raster = new _paper2.default.Raster({ insert: false });
                raster.canvas = destContext.canvas;
                raster.onLoad = function () {
                    raster.position = (0, _layer.getRaster)().position;
                    // Erase what's already there
                    (0, _layer.getRaster)().getContext().globalCompositeOperation = 'destination-out';
                    (0, _layer.getRaster)().drawImage(raster.canvas, new _paper2.default.Point());
                    (0, _layer.getRaster)().getContext().globalCompositeOperation = 'source-over';

                    // Create the gradient to be masked
                    var hitBounds = (0, _bitmap.getHitBounds)(raster);
                    if (!hitBounds.area) return;
                    var gradient = new _paper2.default.Shape.Rectangle({
                        insert: false,
                        rectangle: {
                            topLeft: hitBounds.topLeft,
                            bottomRight: hitBounds.bottomRight
                        }
                    });
                    gradient.fillColor = (0, _stylePath.createGradientObject)(_this2.color, _this2.color2, _this2.gradientType, gradient.bounds, event.point);
                    var rasterGradient = gradient.rasterize((0, _layer.getRaster)().resolution.width, false /* insert */);

                    // Mask gradient
                    raster.getContext().globalCompositeOperation = 'source-in';
                    raster.drawImage(rasterGradient.canvas, rasterGradient.bounds.topLeft);

                    // Draw masked gradient into raster layer
                    (0, _layer.getRaster)().drawImage(raster.canvas, new _paper2.default.Point());
                    _this2.onUpdateImage();
                };
            } else if (changed) {
                this.onUpdateImage();
            }
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {}
    }]);

    return FillTool;
}(_paper2.default.Tool);

exports.default = FillTool;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _selection = __webpack_require__(3);

var _bitEraserMode = __webpack_require__(128);

var _bitEraserMode2 = _interopRequireDefault(_bitEraserMode);

var _brushTool = __webpack_require__(64);

var _brushTool2 = _interopRequireDefault(_brushTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BitEraserMode = function (_React$Component) {
    _inherits(BitEraserMode, _React$Component);

    function BitEraserMode(props) {
        _classCallCheck(this, BitEraserMode);

        var _this = _possibleConstructorReturn(this, (BitEraserMode.__proto__ || Object.getPrototypeOf(BitEraserMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(BitEraserMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isBitEraserModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool && nextProps.bitEraserSize !== this.props.bitEraserSize) {
                this.tool.setBrushSize(nextProps.bitEraserSize);
            }

            if (nextProps.isBitEraserModeActive && !this.props.isBitEraserModeActive) {
                this.activateTool();
            } else if (!nextProps.isBitEraserModeActive && this.props.isBitEraserModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isBitEraserModeActive !== this.props.isBitEraserModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            (0, _selection.clearSelection)(this.props.clearSelectedItems);
            this.tool = new _brushTool2.default(this.props.onUpdateImage, true /* isEraser */
            );
            this.tool.setBrushSize(this.props.bitEraserSize);

            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_bitEraserMode2.default, {
                isSelected: this.props.isBitEraserModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return BitEraserMode;
}(_react2.default.Component);

BitEraserMode.propTypes = {
    bitEraserSize: _propTypes2.default.number.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    handleMouseDown: _propTypes2.default.func.isRequired,
    isBitEraserModeActive: _propTypes2.default.bool.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        bitEraserSize: state.scratchPaint.bitEraserSize,
        isBitEraserModeActive: state.scratchPaint.mode === _modes2.default.BIT_ERASER
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.BIT_ERASER));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(BitEraserMode);

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _eraser = __webpack_require__(70);

var _eraser2 = _interopRequireDefault(_eraser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BitEraserComponent = function BitEraserComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.eraser,
        imgSrc: _eraser2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

BitEraserComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = BitEraserComponent;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _fillStyle = __webpack_require__(18);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _cursor = __webpack_require__(25);

var _selection = __webpack_require__(3);

var _selectTool = __webpack_require__(130);

var _selectTool2 = _interopRequireDefault(_selectTool);

var _bitSelectMode = __webpack_require__(131);

var _bitSelectMode2 = _interopRequireDefault(_bitSelectMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BitSelectMode = function (_React$Component) {
    _inherits(BitSelectMode, _React$Component);

    function BitSelectMode(props) {
        _classCallCheck(this, BitSelectMode);

        var _this = _possibleConstructorReturn(this, (BitSelectMode.__proto__ || Object.getPrototypeOf(BitSelectMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(BitSelectMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isSelectModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool && nextProps.selectedItems !== this.props.selectedItems) {
                this.tool.onSelectionChanged(nextProps.selectedItems);
            }

            if (nextProps.isSelectModeActive && !this.props.isSelectModeActive) {
                this.activateTool();
            } else if (!nextProps.isSelectModeActive && this.props.isSelectModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isSelectModeActive !== this.props.isSelectModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            this.props.clearGradient();
            this.tool = new _selectTool2.default(this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage);
            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_bitSelectMode2.default, {
                isSelected: this.props.isSelectModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return BitSelectMode;
}(_react2.default.Component);

BitSelectMode.propTypes = {
    clearGradient: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    handleMouseDown: _propTypes2.default.func.isRequired,
    isSelectModeActive: _propTypes2.default.bool.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    selectedItems: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_paper2.default.Item)),
    setCursor: _propTypes2.default.func.isRequired,
    setSelectedItems: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        isSelectModeActive: state.scratchPaint.mode === _modes2.default.BIT_SELECT,
        selectedItems: state.scratchPaint.selectedItems
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearGradient: function clearGradient() {
            dispatch((0, _fillStyle.clearFillGradient)());
        },
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        setCursor: function setCursor(cursorType) {
            dispatch((0, _cursor.setCursor)(cursorType));
        },
        setSelectedItems: function setSelectedItems() {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)()));
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.BIT_SELECT));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(BitSelectMode);

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _layer = __webpack_require__(12);

var _bitmap = __webpack_require__(21);

var _boundingBoxTool = __webpack_require__(29);

var _boundingBoxTool2 = _interopRequireDefault(_boundingBoxTool);

var _nudgeTool = __webpack_require__(30);

var _nudgeTool2 = _interopRequireDefault(_nudgeTool);

var _selectionBoxTool = __webpack_require__(50);

var _selectionBoxTool2 = _interopRequireDefault(_selectionBoxTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * paper.Tool that handles select mode in bitmap. This is made up of 2 subtools.
 * - The selection box tool is active when the user clicks an empty space and drags.
 *   It selects all items in the rectangle.
 * - The bounding box tool is active if the user clicks on a non-empty space. It handles
 *   reshaping the selection.
 */
var SelectTool = function (_paper$Tool) {
    _inherits(SelectTool, _paper$Tool);

    _createClass(SelectTool, null, [{
        key: 'TOLERANCE',

        /** The distance within which mouse events count as a hit against an item */
        get: function get() {
            return 2;
        }
        /**
         * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
         * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
         * @param {function} setCursor Callback to set the visible mouse cursor
         * @param {!function} onUpdateImage A callback to call when the image visibly changes
         */

    }]);

    function SelectTool(setSelectedItems, clearSelectedItems, setCursor, onUpdateImage) {
        _classCallCheck(this, SelectTool);

        var _this = _possibleConstructorReturn(this, (SelectTool.__proto__ || Object.getPrototypeOf(SelectTool)).call(this));

        _this.onUpdateImage = onUpdateImage;
        _this.boundingBoxTool = new _boundingBoxTool2.default(_modes2.default.BIT_SELECT, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);
        var nudgeTool = new _nudgeTool2.default(_modes2.default.BIT_SELECT, _this.boundingBoxTool, onUpdateImage);
        _this.selectionBoxTool = new _selectionBoxTool2.default(_modes2.default.BIT_SELECT, setSelectedItems, clearSelectedItems);
        _this.selectionBoxMode = false;
        _this.selection = null;
        _this.active = false;

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseDrag = _this.handleMouseDrag;
        _this.onMouseMove = _this.handleMouseMove;
        _this.onMouseUp = _this.handleMouseUp;
        _this.onKeyUp = nudgeTool.onKeyUp;
        _this.onKeyDown = nudgeTool.onKeyDown;

        _this.boundingBoxTool.setSelectionBounds();
        return _this;
    }
    /**
     * Should be called if the selection changes to update the bounds of the bounding box.
     * @param {Array<paper.Item>} selectedItems Array of selected items.
     */


    _createClass(SelectTool, [{
        key: 'onSelectionChanged',
        value: function onSelectionChanged(selectedItems) {
            this.boundingBoxTool.onSelectionChanged(selectedItems);
            if (this.selection && this.selection.parent && !this.selection.selected) {
                // Selection got deselected
                this.commitSelection();
            }
            if ((!this.selection || !this.selection.parent) && selectedItems && selectedItems.length === 1 && selectedItems[0] instanceof _paper2.default.Raster) {
                // Track the new active selection. This may happen via undo, paste, or drag to select.
                this.selection = selectedItems[0];
            }
        }
        /**
         * Returns the hit options to use when conducting hit tests.
         * @return {object} See paper.Item.hitTest for definition of options
         */

    }, {
        key: 'getHitOptions',
        value: function getHitOptions() {
            // Tolerance needs to be scaled when the view is zoomed in in order to represent the same
            // distance for the user to move the mouse.
            return {
                segments: true,
                stroke: true,
                curves: true,
                fill: true,
                guide: false,
                tolerance: SelectTool.TOLERANCE / _paper2.default.view.zoom,
                match: function match(hitResult) {
                    // Don't match helper items, unless they are handles.
                    if (!hitResult.item.data || !hitResult.item.data.isHelperItem) return true;
                    return hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle;
                }
            };
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;

            // If bounding box tool does not find an item that was hit, rasterize the old selection,
            // then use selection box tool.
            if (!this.boundingBoxTool.onMouseDown(event, event.modifiers.alt, event.modifiers.shift, false /* doubleClicked */
            , this.getHitOptions())) {
                this.commitSelection();
                this.selectionBoxMode = true;
                this.selectionBoxTool.onMouseDown(event.modifiers.shift);
            }
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.selectionBoxMode) {
                this.selectionBoxTool.onMouseDrag(event);
            } else {
                this.boundingBoxTool.onMouseDrag(event);
            }
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            this.boundingBoxTool.onMouseMove(event, this.getHitOptions());
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.selectionBoxMode) {
                this.selectionBoxTool.onMouseUpBitmap(event);
            } else {
                this.boundingBoxTool.onMouseUp(event);
            }
            this.selectionBoxMode = false;
            this.active = false;
        }
    }, {
        key: 'commitSelection',
        value: function commitSelection() {
            if (!this.selection || !this.selection.parent) return;

            (0, _bitmap.commitSelectionToBitmap)(this.selection, (0, _layer.getRaster)());
            this.selection.remove();
            this.selection = null;
            this.onUpdateImage();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.commitSelection();
            this.boundingBoxTool.deactivateTool();
            this.boundingBoxTool = null;
            this.selectionBoxTool = null;
        }
    }]);

    return SelectTool;
}(_paper2.default.Tool);

exports.default = SelectTool;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _marquee = __webpack_require__(132);

var _marquee2 = _interopRequireDefault(_marquee);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BitSelectComponent = function BitSelectComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.select,
        imgSrc: _marquee2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

BitSelectComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = BitSelectComponent;

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Emarquee%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='marquee' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cpath d='M4.5,4.18186116 L4.5,3 L5.68186116,3 L5.68186116,4.18186116 L4.5,4.18186116 Z M11.591167,4.18186116 L11.591167,3 L12.7730281,3 L12.7730281,4.18186116 L11.591167,4.18186116 Z M4.5,13.6367504 L4.5,12.4537074 L5.68186116,12.4537074 L5.68186116,13.6367504 L4.5,13.6367504 Z M9.22697189,6.54570166 L10.4100149,6.54570166 L10.4100149,7.72756282 L11.5918761,7.72756282 L11.5918761,8.90942398 L12.7737372,8.90942398 L12.7737372,10.0912851 L13.9555984,10.0912851 L13.9555984,11.2731463 L15.1362777,11.2731463 L15.1362777,12.4538256 L16.3181388,12.4538256 L16.3181388,13.6368686 L17.5,13.6368686 L17.5,14.8187298 L12.7737372,14.8187298 L12.7737372,16.0005909 L11.5918761,16.0005909 L11.5918761,17.1824521 L10.4100149,17.1824521 L10.4100149,18.3643132 L9.22697189,18.3643132 L9.22697189,6.54570166 Z M13.9548893,8.90930579 L13.9548893,7.72744463 L15.1367504,7.72744463 L15.1367504,8.90930579 L13.9548893,8.90930579 Z M6.86372232,4.18186116 L6.86372232,3 L8.04558348,3 L8.04558348,4.18186116 L6.86372232,4.18186116 Z M4.5,11.2730281 L4.5,10.091167 L5.68186116,10.091167 L5.68186116,11.2730281 L4.5,11.2730281 Z M13.9548893,4.18186116 L13.9548893,3 L15.1367504,3 L15.1367504,4.18186116 L13.9548893,4.18186116 Z M9.22744463,4.18186116 L9.22744463,3 L10.4104877,3 L10.4104877,4.18186116 L9.22744463,4.18186116 Z M4.5,8.90930579 L4.5,7.72744463 L5.68186116,7.72744463 L5.68186116,8.90930579 L4.5,8.90930579 Z M4.5,6.54558348 L4.5,5.36372232 L5.68186116,5.36372232 L5.68186116,6.54558348 L4.5,6.54558348 Z M13.9548893,6.54558348 L13.9548893,5.36372232 L15.1367504,5.36372232 L15.1367504,6.54558348 L13.9548893,6.54558348 Z M6.86372232,13.6367504 L6.86372232,12.4537074 L8.04558348,12.4537074 L8.04558348,13.6367504 L6.86372232,13.6367504 Z' id='Combined-Shape' fill='%23575E75'%3E%3C/path%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 133 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = require("react-style-proptype");

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(136);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n.button-group_button-group_3_c2R {\n    display: -webkit-inline-box;\n    display: -webkit-inline-flex;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n        -ms-flex-direction: row;\n            flex-direction: row;\n    padding: 0 .25rem;\n}\n", ""]);
// Exports
exports.locals = {
	"button-group": "button-group_button-group_3_c2R",
	"buttonGroup": "button-group_button-group_3_c2R"
};
module.exports = exports;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _colorStyleProptype = __webpack_require__(28);

var _colorStyleProptype2 = _interopRequireDefault(_colorStyleProptype);

var _blob = __webpack_require__(73);

var _blob2 = _interopRequireDefault(_blob);

var _stylePath = __webpack_require__(9);

var _fillStyle = __webpack_require__(18);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _selection = __webpack_require__(3);

var _brushMode = __webpack_require__(140);

var _brushMode2 = _interopRequireDefault(_brushMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BrushMode = function (_React$Component) {
    _inherits(BrushMode, _React$Component);

    function BrushMode(props) {
        _classCallCheck(this, BrushMode);

        var _this = _possibleConstructorReturn(this, (BrushMode.__proto__ || Object.getPrototypeOf(BrushMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        _this.blob = new _blob2.default(_this.props.onUpdateImage, _this.props.clearSelectedItems);
        return _this;
    }

    _createClass(BrushMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isBrushModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.isBrushModeActive && !this.props.isBrushModeActive) {
                this.activateTool();
            } else if (!nextProps.isBrushModeActive && this.props.isBrushModeActive) {
                this.deactivateTool();
            } else if (nextProps.isBrushModeActive && this.props.isBrushModeActive) {
                var _nextProps$colorState = nextProps.colorState,
                    fillColor = _nextProps$colorState.fillColor,
                    strokeColor = _nextProps$colorState.strokeColor,
                    strokeWidth = _nextProps$colorState.strokeWidth;

                this.blob.setOptions(_extends({
                    isEraser: false,
                    fillColor: fillColor.primary,
                    strokeColor: strokeColor.primary,
                    strokeWidth: strokeWidth
                }, nextProps.brushModeState));
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isBrushModeActive !== this.props.isBrushModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.blob.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            // TODO: Instead of clearing selection, consider a kind of "draw inside"
            // analogous to how selection works with eraser
            (0, _selection.clearSelection)(this.props.clearSelectedItems);
            this.props.clearGradient();
            // Force the default brush color if fill is MIXED or transparent
            var fillColor = this.props.colorState.fillColor.primary;
            if (fillColor === _stylePath.MIXED || fillColor === null) {
                this.props.onChangeFillColor(_fillStyle.DEFAULT_COLOR);
            }
            this.blob.activateTool(_extends({
                isEraser: false
            }, this.props.colorState, this.props.brushModeState));
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.blob.deactivateTool();
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_brushMode2.default, {
                isSelected: this.props.isBrushModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return BrushMode;
}(_react2.default.Component);

BrushMode.propTypes = {
    brushModeState: _propTypes2.default.shape({
        brushSize: _propTypes2.default.number.isRequired
    }),
    clearGradient: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    colorState: _propTypes2.default.shape({
        fillColor: _colorStyleProptype2.default,
        strokeColor: _colorStyleProptype2.default,
        strokeWidth: _propTypes2.default.number
    }).isRequired,
    handleMouseDown: _propTypes2.default.func.isRequired,
    isBrushModeActive: _propTypes2.default.bool.isRequired,
    onChangeFillColor: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        brushModeState: state.scratchPaint.brushMode,
        colorState: state.scratchPaint.color,
        isBrushModeActive: state.scratchPaint.mode === _modes2.default.BRUSH
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        clearGradient: function clearGradient() {
            dispatch((0, _fillStyle.clearFillGradient)());
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.BRUSH));
        },
        onChangeFillColor: function onChangeFillColor(fillColor) {
            dispatch((0, _fillStyle.changeFillColor)(fillColor));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(BrushMode);

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Broadbrush based on http://paperjs.org/tutorials/interaction/working-with-mouse-vectors/


var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _stylePath = __webpack_require__(9);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Broad brush functions to add as listeners on the mouse. Call them when the corresponding mouse event happens
 * to get the broad brush behavior.
 *
 * Broad brush draws strokes by drawing points equidistant from the mouse event, perpendicular to the
 * direction of motion. Shortcomings are that this path can cross itself, and 180 degree turns result
 * in a flat edge.
 *
 * @param {!Tool} tool paper.js mouse object
 */
var BroadBrushHelper = function () {
    function BroadBrushHelper() {
        _classCallCheck(this, BroadBrushHelper);

        // Direction vector of the last mouse move
        this.lastVec = null;
        // End point of the last mouse move
        this.lastPoint = null;
        // The path of the brush stroke we are building
        this.finalPath = null;
        // Number of points of finalPath that have already been processed
        this.smoothed = 0;
        // Number of steps to wait before performing another amortized smooth
        this.smoothingThreshold = 20;
        // Mouse moves since mouse down
        this.steps = 0;
        // End caps round out corners and are not merged into the path until the end.
        this.endCaps = [];
    }

    _createClass(BroadBrushHelper, [{
        key: 'onBroadMouseDown',
        value: function onBroadMouseDown(event, tool, options) {
            this.steps = 0;
            this.smoothed = 0;
            this.lastVec = null;
            tool.minDistance = Math.min(5, Math.max(2 / _paper2.default.view.zoom, options.brushSize / 2));
            tool.maxDistance = options.brushSize;
            if (event.event.button > 0) return; // only first mouse button

            this.finalPath = new _paper2.default.Path.Circle({
                center: event.point,
                radius: options.brushSize / 2
            });
            (0, _stylePath.styleBlob)(this.finalPath, options);
            this.lastPoint = event.point;
        }
    }, {
        key: 'onBroadMouseDrag',
        value: function onBroadMouseDrag(event, tool, options) {
            this.steps++;
            var step = event.delta.normalize(options.brushSize / 2);

            // Add an end cap if the mouse has changed direction very quickly
            if (this.lastVec) {
                var angle = this.lastVec.getDirectedAngle(step);
                if (Math.abs(angle) > 126) {
                    // This will cause us to skip simplifying this sharp angle. Running simplify on
                    // sharp angles causes the stroke to blob outwards.
                    this.simplify(1);
                    this.smoothed++;

                    // If the angle is large, the broad brush tends to leave behind a flat edge.
                    // This code makes a shape to fill in that flat edge with a rounded cap.
                    var circ = new _paper2.default.Path.Circle(this.lastPoint, options.brushSize / 2);
                    circ.fillColor = options.fillColor;
                    var rect = new _paper2.default.Path.Rectangle(this.lastPoint.subtract(new _paper2.default.Point(-options.brushSize / 2, 0)), this.lastPoint.subtract(new _paper2.default.Point(options.brushSize / 2, this.lastVec.length)));
                    rect.fillColor = options.fillColor;
                    rect.rotate(this.lastVec.angle - 90, this.lastPoint);
                    var rect2 = new _paper2.default.Path.Rectangle(event.point.subtract(new _paper2.default.Point(-options.brushSize / 2, 0)), event.point.subtract(new _paper2.default.Point(options.brushSize / 2, event.delta.length)));
                    rect2.fillColor = options.fillColor;
                    rect2.rotate(step.angle - 90, event.point);
                    this.endCaps.push(this.union(circ, this.union(rect, rect2)));
                }
            }
            step.angle += 90;

            // Move the first point out away from the drag so that the end of the path is rounded
            if (this.steps === 1) {
                // Replace circle with path
                this.finalPath.remove();
                this.finalPath = new _paper2.default.Path();
                var handleVec = event.delta.normalize(options.brushSize / 2);
                this.finalPath.add(new _paper2.default.Segment(this.lastPoint.subtract(handleVec), handleVec.rotate(-90), handleVec.rotate(90)));
                (0, _stylePath.styleBlob)(this.finalPath, options);
                this.finalPath.insert(0, new _paper2.default.Segment(this.lastPoint.subtract(step)));
                this.finalPath.add(new _paper2.default.Segment(this.lastPoint.add(step)));
            }

            // Update angle of the last brush step's points to match the average angle of the last mouse vector and this
            // mouse vector (aka the vertex normal).
            if (this.lastVec) {
                var lastNormal = this.lastVec.normalize(options.brushSize / 2).rotate(90);
                var averageNormal = new _paper2.default.Point(lastNormal.x + step.x, lastNormal.y + step.y).normalize(options.brushSize / 2);

                this.finalPath.segments[0].point = this.lastPoint.subtract(averageNormal);
                this.finalPath.segments[this.finalPath.segments.length - 1].point = this.lastPoint.add(averageNormal);
            }

            this.finalPath.add(event.point.add(step));
            this.finalPath.insert(0, event.point.subtract(step));

            if (this.finalPath.segments.length > this.smoothed + this.smoothingThreshold * 2) {
                this.simplify(1);
            }

            this.lastVec = event.delta;
            this.lastPoint = event.point;
        }

        /**
         * Simplify the path so that it looks almost the same while trying to have a reasonable number of handles.
         * Without this, there would be 2 handles for every mouse move, which would make the path produced basically
         * uneditable. This version of simplify keeps track of how much of the path has already been simplified to
         * avoid repeating work.
         * @param {number} threshold The simplify algorithm must try to stay within this distance of the actual line.
         *     The algorithm will be faster and able to remove more points the higher this number is.
         *     Note that 1 is about the lowest this algorithm can do (the result is about the same when 1 is
         *     passed in as when 0 is passed in)
         */

    }, {
        key: 'simplify',
        value: function simplify(threshold) {
            // Length of the current path
            var length = this.finalPath.segments.length;
            // Number of new points added to front and end of path since last simplify
            var newPoints = Math.floor((length - this.smoothed) / 2) + 1;

            // Where to cut. Don't go past the rounded start of the line (so there's always a tempPathMid)
            var firstCutoff = Math.min(newPoints + 1, Math.floor(length / 2));
            var lastCutoff = Math.max(length - 1 - newPoints, Math.floor(length / 2) + 1);
            if (firstCutoff <= 1 || lastCutoff >= length - 1) {
                // Entire path is simplified already
                return;
            }
            // Cut the path into 3 segments: the 2 ends where the new points are, and the middle, which will be
            // staying the same
            var tempPath1 = new _paper2.default.Path(this.finalPath.segments.slice(1, firstCutoff));
            var tempPathMid = new _paper2.default.Path(this.finalPath.segments.slice(firstCutoff, lastCutoff));
            var tempPath2 = new _paper2.default.Path(this.finalPath.segments.slice(lastCutoff, length - 1));

            // Run simplify on the new ends. We need to graft the old handles back onto the newly
            // simplified paths, since simplify removes the in handle from the start of the path, and
            // the out handle from the end of the path it's simplifying.
            var oldPath1End = tempPath1.segments[tempPath1.segments.length - 1];
            var oldPath2End = tempPath2.segments[0];
            tempPath1.simplify(threshold);
            tempPath2.simplify(threshold);
            var newPath1End = tempPath1.segments[tempPath1.segments.length - 1];
            var newPath2End = tempPath2.segments[0];
            newPath1End.handleOut = oldPath1End.handleOut;
            newPath2End.handleIn = oldPath2End.handleIn;

            // Delete the old contents of finalPath and replace it with the newly simplified segments, concatenated
            this.finalPath.removeSegments(1, this.finalPath.segments.length - 1);
            this.finalPath.insertSegments(1, tempPath1.segments.concat(tempPathMid.segments).concat(tempPath2.segments));

            // Remove temp paths
            tempPath1.remove();
            tempPath2.remove();
            tempPathMid.remove();

            // Update how many points have been smoothed so far so that we don't redo work when
            // simplify is called next time.
            this.smoothed = Math.max(2, this.finalPath.segments.length);
        }

        /**
         * Like paper.Path.unite, but it removes the original 2 paths
         * @param {paper.Path} path1 to merge
         * @param {paper.Path} path2 to merge
         * @return {paper.Path} merged path. Original paths 1 and 2 will be removed from the view.
         */

    }, {
        key: 'union',
        value: function union(path1, path2) {
            var temp = path1.unite(path2);
            path1.remove();
            path2.remove();
            return temp;
        }
    }, {
        key: 'onBroadMouseUp',
        value: function onBroadMouseUp(event, tool, options) {
            // If there was only a single click, draw a circle.
            if (this.steps === 0) {
                this.endCaps.length = 0;
                return this.finalPath;
            }

            var delta = this.lastVec;

            // If the mouse up is at the same point as the mouse drag event then we need
            // the second to last point to get the right direction vector for the end cap
            if (!event.point.equals(this.lastPoint)) {
                // The given event.delta is the difference between the mouse down coords and the mouse up coords,
                // but we want the difference between the last mouse drag coords and the mouse up coords.
                delta = event.point.subtract(this.lastPoint);
                var step = delta.normalize(options.brushSize / 2);
                step.angle += 90;

                var top = event.point.add(step);
                var bottom = event.point.subtract(step);
                this.finalPath.add(top);
                this.finalPath.insert(0, bottom);
            }

            // Simplify before adding end cap so cap doesn't get warped
            this.simplify(1);
            var handleVec = delta.normalize(options.brushSize / 2);
            this.finalPath.add(new _paper2.default.Segment(event.point.add(handleVec), handleVec.rotate(90), handleVec.rotate(-90)));
            this.finalPath.closePath();

            // Resolve self-crossings
            var newPath = this.finalPath.resolveCrossings().reorient(true /* nonZero */, true /* clockwise */).reduce({ simplify: true });
            if (newPath !== this.finalPath) {
                newPath.copyAttributes(this.finalPath);
                newPath.fillColor = this.finalPath.fillColor;
                this.finalPath.remove();
                this.finalPath = newPath;
            }

            // Try to merge end caps
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = this.endCaps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var cap = _step.value;

                    var temp = this.union(this.finalPath, cap);
                    if (temp.area >= this.finalPath.area && !(temp instanceof _paper2.default.CompoundPath && !(this.finalPath instanceof _paper2.default.CompoundPath))) {
                        this.finalPath = temp;
                    } else {
                        // If the union of the two shapes is smaller than the original shape,
                        // or it caused the path to become a compound path,
                        // then there must have been a glitch with paperjs's unite function.
                        // In this case, skip merging that segment. It's not great, but it's
                        // better than losing the whole path for instance. (Unfortunately, this
                        // happens reasonably often to scribbles, and this code doesn't catch
                        // all of the failures.)
                        this.finalPath.insertAbove(temp);
                        temp.remove();
                        _log2.default.warn('Skipping a merge.');
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.endCaps.length = 0;

            return this.finalPath;
        }
    }]);

    return BroadBrushHelper;
}();

exports.default = BroadBrushHelper;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _stylePath = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Segment brush functions to add as listeners on the mouse. Call them when the corresponding mouse event happens
 * to get the broad brush behavior.
 *
 * Segment brush draws by creating a rounded rectangle for each mouse move event and merging all of
 * those shapes. Unlike the broad brush, the resulting shape will not self-intersect and when you make
 * 180 degree turns, you will get a rounded point as expected. Shortcomings include that performance is
 * worse, especially as the number of segments to join increase, and that there are problems in paper.js
 * with union on shapes with curves, so that chunks of the union tend to disappear.
 * (https://github.com/paperjs/paper.js/issues/1321)
 *
 * @param {!Tool} tool paper.js mouse object
 */
var SegmentBrushHelper = function () {
    function SegmentBrushHelper() {
        _classCallCheck(this, SegmentBrushHelper);

        this.lastPoint = null;
        this.finalPath = null;
        this.firstCircle = null;
    }

    _createClass(SegmentBrushHelper, [{
        key: 'onSegmentMouseDown',
        value: function onSegmentMouseDown(event, tool, options) {
            if (event.event.button > 0) return; // only first mouse button

            tool.minDistance = 2 / _paper2.default.view.zoom;
            tool.maxDistance = options.brushSize;

            this.firstCircle = new _paper2.default.Path.Circle({
                center: event.point,
                radius: options.brushSize / 2
            });
            this.finalPath = this.firstCircle;
            (0, _stylePath.styleBlob)(this.finalPath, options);
            this.lastPoint = event.point;
        }
    }, {
        key: 'onSegmentMouseDrag',
        value: function onSegmentMouseDrag(event, tool, options) {
            if (event.event.button > 0) return; // only first mouse button

            var step = event.delta.normalize(options.brushSize / 2);
            var handleVec = step.clone();
            handleVec.length = options.brushSize / 2;
            handleVec.angle += 90;

            var path = new _paper2.default.Path();

            (0, _stylePath.styleBlob)(path, options);

            // Add handles to round the end caps
            path.add(new _paper2.default.Segment(this.lastPoint.subtract(step), handleVec.multiply(-1), handleVec));
            step.angle += 90;

            path.add(event.lastPoint.add(step));
            path.insert(0, event.lastPoint.subtract(step));
            path.add(event.point.add(step));
            path.insert(0, event.point.subtract(step));

            // Add end cap
            step.angle -= 90;
            path.add(new _paper2.default.Segment(event.point.add(step), handleVec, handleVec.multiply(-1)));
            path.closed = true;
            // The unite function on curved paths does not always work (sometimes deletes half the path)
            // so we have to flatten.
            path.flatten(Math.min(5, options.brushSize / 5));

            this.lastPoint = event.point;
            var newPath = this.finalPath.unite(path);
            path.remove();
            this.finalPath.remove();
            this.finalPath = newPath;
        }
    }, {
        key: 'onSegmentMouseUp',
        value: function onSegmentMouseUp(event) {
            if (event.event.button > 0) return; // only first mouse button

            // TODO: This smoothing tends to cut off large portions of the path! Would like to eventually
            // add back smoothing, maybe a custom implementation that only applies to a subset of the line?

            // Smooth the path. Make it unclosed first because smoothing of closed
            // paths tends to cut off the path.
            if (this.finalPath.segments && this.finalPath.segments.length > 4) {
                this.finalPath.closed = false;
                this.finalPath.simplify(2);
                this.finalPath.closed = true;
                // Merge again with the first point, since it gets distorted when we unclose the path.
                var temp = this.finalPath.unite(this.firstCircle);
                this.finalPath.remove();
                this.finalPath = temp;
            }
            return this.finalPath;
        }
    }]);

    return SegmentBrushHelper;
}();

exports.default = SegmentBrushHelper;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _brush = __webpack_require__(74);

var _brush2 = _interopRequireDefault(_brush);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BrushModeComponent = function BrushModeComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.brush,
        imgSrc: _brush2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

BrushModeComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = BrushModeComponent;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _blob = __webpack_require__(73);

var _blob2 = _interopRequireDefault(_blob);

var _eraserMode = __webpack_require__(51);

var _selectedItems = __webpack_require__(7);

var _eraserMode2 = __webpack_require__(142);

var _eraserMode3 = _interopRequireDefault(_eraserMode2);

var _modes3 = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EraserMode = function (_React$Component) {
    _inherits(EraserMode, _React$Component);

    function EraserMode(props) {
        _classCallCheck(this, EraserMode);

        var _this = _possibleConstructorReturn(this, (EraserMode.__proto__ || Object.getPrototypeOf(EraserMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        _this.blob = new _blob2.default(_this.props.onUpdateImage, _this.props.clearSelectedItems);
        return _this;
    }

    _createClass(EraserMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isEraserModeActive) {
                this.activateTool();
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.isEraserModeActive && !this.props.isEraserModeActive) {
                this.activateTool();
            } else if (!nextProps.isEraserModeActive && this.props.isEraserModeActive) {
                this.deactivateTool();
            } else if (nextProps.isEraserModeActive && this.props.isEraserModeActive) {
                this.blob.setOptions(_extends({
                    isEraser: true
                }, nextProps.eraserModeState));
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isEraserModeActive !== this.props.isEraserModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.blob.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            this.blob.activateTool(_extends({ isEraser: true }, this.props.eraserModeState));
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.blob.deactivateTool();
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_eraserMode3.default, {
                isSelected: this.props.isEraserModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return EraserMode;
}(_react2.default.Component);

EraserMode.propTypes = {
    clearSelectedItems: _propTypes2.default.func.isRequired,
    eraserModeState: _propTypes2.default.shape({
        brushSize: _propTypes2.default.number.isRequired
    }),
    handleMouseDown: _propTypes2.default.func.isRequired,
    isEraserModeActive: _propTypes2.default.bool.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        eraserModeState: state.scratchPaint.eraserMode,
        isEraserModeActive: state.scratchPaint.mode === _modes2.default.ERASER
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        changeBrushSize: function changeBrushSize(brushSize) {
            dispatch((0, _eraserMode.changeBrushSize)(brushSize));
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.ERASER));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(EraserMode);

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _eraser = __webpack_require__(75);

var _eraser2 = _interopRequireDefault(_eraser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EraserModeComponent = function EraserModeComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.eraser,
        imgSrc: _eraser2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

EraserModeComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = EraserModeComponent;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _reactRedux = __webpack_require__(6);

var _reactIntl = __webpack_require__(23);

var _colorIndex = __webpack_require__(42);

var _fillStyle = __webpack_require__(18);

var _fillModeGradientType = __webpack_require__(41);

var _modals = __webpack_require__(52);

var _selection = __webpack_require__(3);

var _selectedItems = __webpack_require__(7);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _format = __webpack_require__(11);

var _colorIndicator = __webpack_require__(76);

var _colorIndicator2 = _interopRequireDefault(_colorIndicator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var messages = (0, _reactIntl.defineMessages)({
    label: {
        'id': 'paint.paintEditor.fill',
        'defaultMessage': 'Fill'
    }
});

var FillColorIndicator = (0, _colorIndicator2.default)(messages.label, false);

var mapStateToProps = function mapStateToProps(state) {
    return {
        colorIndex: state.scratchPaint.fillMode.colorIndex,
        disabled: state.scratchPaint.mode === _modes2.default.LINE,
        color: state.scratchPaint.color.fillColor.primary,
        color2: state.scratchPaint.color.fillColor.secondary,
        colorModalVisible: state.scratchPaint.modals.fillColor,
        fillBitmapShapes: state.scratchPaint.fillBitmapShapes,
        format: state.scratchPaint.format,
        gradientType: state.scratchPaint.color.fillColor.gradientType,
        isEyeDropping: state.scratchPaint.color.eyeDropper.active,
        mode: state.scratchPaint.mode,
        shouldShowGradientTools: state.scratchPaint.mode in _modes.GradientToolsModes,
        textEditTarget: state.scratchPaint.textEditTarget
    };
};

var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        onChangeColorIndex: function onChangeColorIndex(index) {
            dispatch((0, _colorIndex.changeColorIndex)(index));
        },
        onChangeColor: function onChangeColor(fillColor, index) {
            if (index === 0) {
                dispatch((0, _fillStyle.changeFillColor)(fillColor));
            } else if (index === 1) {
                dispatch((0, _fillStyle.changeFillColor2)(fillColor));
            }
        },
        onOpenColor: function onOpenColor() {
            dispatch((0, _modals.openFillColor)());
        },
        onCloseColor: function onCloseColor() {
            dispatch((0, _modals.closeFillColor)());
        },
        onChangeGradientType: function onChangeGradientType(gradientType) {
            dispatch((0, _fillModeGradientType.changeGradientType)(gradientType));
        },
        setSelectedItems: function setSelectedItems(format) {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), (0, _format.isBitmap)(format)));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(FillColorIndicator);

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(145);

var convert = function() {
   return new Converter();
}

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   }
});

module.exports = convert;

/***/ }),
/* 145 */
/***/ (function(module, exports) {

/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;

  if(l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
  }

  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactPopover = __webpack_require__(77);

var _reactPopover2 = _interopRequireDefault(_reactPopover);

var _colorButton = __webpack_require__(147);

var _colorButton2 = _interopRequireDefault(_colorButton);

var _colorPicker = __webpack_require__(150);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _inputGroup = __webpack_require__(33);

var _inputGroup2 = _interopRequireDefault(_inputGroup);

var _label = __webpack_require__(54);

var _label2 = _interopRequireDefault(_label);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ColorIndicatorComponent = function ColorIndicatorComponent(props) {
    return _react2.default.createElement(
        _inputGroup2.default,
        {
            className: props.className,
            disabled: props.disabled
        },
        _react2.default.createElement(
            _reactPopover2.default,
            {
                body: _react2.default.createElement(_colorPicker2.default, {
                    color: props.color,
                    color2: props.color2,
                    gradientType: props.gradientType,
                    shouldShowGradientTools: props.shouldShowGradientTools,
                    onChangeColor: props.onChangeColor,
                    onChangeGradientType: props.onChangeGradientType,
                    onSwap: props.onSwap
                }),
                isOpen: props.colorModalVisible,
                preferPlace: 'below',
                onOuterAction: props.onCloseColor
            },
            _react2.default.createElement(
                _label2.default,
                { text: props.label },
                _react2.default.createElement(_colorButton2.default, {
                    color: props.color,
                    color2: props.color2,
                    gradientType: props.gradientType,
                    onClick: props.onOpenColor,
                    outline: props.outline
                })
            )
        )
    );
};

ColorIndicatorComponent.propTypes = {
    className: _propTypes2.default.string,
    disabled: _propTypes2.default.bool.isRequired,
    color: _propTypes2.default.string,
    color2: _propTypes2.default.string,
    colorModalVisible: _propTypes2.default.bool.isRequired,
    gradientType: _propTypes2.default.oneOf(Object.keys(_gradientTypes2.default)).isRequired,
    label: _propTypes2.default.string.isRequired,
    onChangeColor: _propTypes2.default.func.isRequired,
    onChangeGradientType: _propTypes2.default.func.isRequired,
    onCloseColor: _propTypes2.default.func.isRequired,
    onOpenColor: _propTypes2.default.func.isRequired,
    onSwap: _propTypes2.default.func.isRequired,
    outline: _propTypes2.default.bool.isRequired,
    shouldShowGradientTools: _propTypes2.default.bool.isRequired
};

exports.default = ColorIndicatorComponent;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _stylePath = __webpack_require__(9);

var _noFill = __webpack_require__(78);

var _noFill2 = _interopRequireDefault(_noFill);

var _mixedFill = __webpack_require__(79);

var _mixedFill2 = _interopRequireDefault(_mixedFill);

var _colorButton = __webpack_require__(148);

var _colorButton2 = _interopRequireDefault(_colorButton);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var colorToBackground = function colorToBackground(color, color2, gradientType) {
    if (color === _stylePath.MIXED || gradientType !== _gradientTypes2.default.SOLID && color2 === _stylePath.MIXED) return 'white';
    if (color === null) color = 'white';
    if (color2 === null) color2 = 'white';
    switch (gradientType) {
        case _gradientTypes2.default.SOLID:
            return color;
        case _gradientTypes2.default.HORIZONTAL:
            return 'linear-gradient(to right, ' + color + ', ' + color2 + ')';
        case _gradientTypes2.default.VERTICAL:
            return 'linear-gradient(' + color + ', ' + color2 + ')';
        case _gradientTypes2.default.RADIAL:
            return 'radial-gradient(' + color + ', ' + color2 + ')';
        default:
            _log2.default.error('Unrecognized gradient type: ' + gradientType);
    }
};

var ColorButtonComponent = function ColorButtonComponent(props) {
    return _react2.default.createElement(
        'div',
        {
            className: _colorButton2.default.colorButton,
            onClick: props.onClick
        },
        _react2.default.createElement(
            'div',
            {
                className: (0, _classnames2.default)(_colorButton2.default.colorButtonSwatch, _defineProperty({}, _colorButton2.default.outlineSwatch, props.outline && !(props.color === _stylePath.MIXED))),
                style: {
                    background: colorToBackground(props.color, props.color2, props.gradientType)
                }
            },
            props.color === null && (props.gradientType === _gradientTypes2.default.SOLID || props.color2 === null) ? _react2.default.createElement('img', {
                className: _colorButton2.default.swatchIcon,
                draggable: false,
                src: _noFill2.default
            }) : props.color === _stylePath.MIXED || props.gradientType !== _gradientTypes2.default.SOLID && props.color2 === _stylePath.MIXED ? _react2.default.createElement('img', {
                className: _colorButton2.default.swatchIcon,
                draggable: false,
                src: _mixedFill2.default
            }) : null
        ),
        _react2.default.createElement(
            'div',
            { className: _colorButton2.default.colorButtonArrow },
            '\u25BE'
        )
    );
};

ColorButtonComponent.propTypes = {
    color: _propTypes2.default.string,
    color2: _propTypes2.default.string,
    gradientType: _propTypes2.default.oneOf(Object.keys(_gradientTypes2.default)).isRequired,
    onClick: _propTypes2.default.func.isRequired,
    outline: _propTypes2.default.bool.isRequired
};

ColorButtonComponent.defaultProps = {
    outline: false
};

exports.default = ColorButtonComponent;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(149);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".color-button_color-button_2-mXT {\n    height: 2rem;\n    width: 3rem;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n}\n\n.color-button_color-button-swatch_6Xhs3 {\n    position: relative;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    cursor: pointer;\n    -webkit-flex-basis: 2rem;\n        -ms-flex-preferred-size: 2rem;\n            flex-basis: 2rem;\n    -webkit-flex-shrink: 0;\n        -ms-flex-negative: 0;\n            flex-shrink: 0;\n    height: 100%;\n    border: 1px solid rgba(0, 0, 0, 0.25);\n}\n\n[dir=\"ltr\"] .color-button_color-button-swatch_6Xhs3 {\n    border-top-left-radius: 4px;\n    border-bottom-left-radius: 4px;\n}\n\n[dir=\"rtl\"] .color-button_color-button-swatch_6Xhs3 {\n    border-top-right-radius: 4px;\n    border-bottom-right-radius: 4px;\n}\n\n.color-button_color-button-arrow_1b654 {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    cursor: pointer;\n    -webkit-flex-basis: 1rem;\n        -ms-flex-preferred-size: 1rem;\n            flex-basis: 1rem;\n    -webkit-flex-shrink: 0;\n        -ms-flex-negative: 0;\n            flex-shrink: 0;\n    height: 100%;\n\n    border: 1px solid rgba(0, 0, 0, 0.25);\n\n    -webkit-box-align: center;\n\n    -webkit-align-items: center;\n\n        -ms-flex-align: center;\n\n            align-items: center;\n    -webkit-box-pack: center;\n    -webkit-justify-content: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    color: #575e75;\n    font-size: 0.75rem;\n}\n\n[dir=\"ltr\"] .color-button_color-button-arrow_1b654 {\n    border-top-right-radius: 4px;\n    border-bottom-right-radius: 4px;\n    border-left: none;\n}\n\n[dir=\"rtl\"] .color-button_color-button-arrow_1b654 {\n    border-top-left-radius: 4px;\n    border-bottom-left-radius: 4px;\n    border-right: none;\n}\n\n.color-button_swatch-icon_2gc40 {\n    width: 1.75rem;\n    margin: auto;\n    /* Make sure it appears above the outline box */\n    z-index: 2;\n}\n\n.color-button_outline-swatch_2ifeG:after {\n    content: \"\";\n    position: absolute;\n    top: calc(0.5rem);\n    left: calc(0.5rem);\n    width: 0.75rem;\n    height: 0.75rem;\n    background: white;\n    border: 1px solid rgba(0, 0, 0, 0.25);\n    /* Make sure it appears below the transparent icon */\n    z-index: 1;\n}\n", ""]);
// Exports
exports.locals = {
	"color-button": "color-button_color-button_2-mXT",
	"colorButton": "color-button_color-button_2-mXT",
	"color-button-swatch": "color-button_color-button-swatch_6Xhs3",
	"colorButtonSwatch": "color-button_color-button-swatch_6Xhs3",
	"color-button-arrow": "color-button_color-button-arrow_1b654",
	"colorButtonArrow": "color-button_color-button-arrow_1b654",
	"swatch-icon": "color-button_swatch-icon_2gc40",
	"swatchIcon": "color-button_swatch-icon_2gc40",
	"outline-swatch": "color-button_outline-swatch_2ifeG",
	"outlineSwatch": "color-button_outline-swatch_2ifeG"
};
module.exports = exports;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _reactRedux = __webpack_require__(6);

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _parseColor = __webpack_require__(43);

var _parseColor2 = _interopRequireDefault(_parseColor);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _colorIndex = __webpack_require__(42);

var _selectedItems = __webpack_require__(7);

var _eyeDropper = __webpack_require__(39);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _colorPicker = __webpack_require__(151);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _stylePath = __webpack_require__(9);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var colorStringToHsv = function colorStringToHsv(hexString) {
    var hsv = (0, _parseColor2.default)(hexString).hsv;
    // Hue comes out in [0, 360], limit to [0, 100]
    hsv[0] = hsv[0] / 3.6;
    // Black is parsed as {0, 0, 0}, but turn saturation up to 100
    // to make it easier to see slider values.
    if (hsv[1] === 0 && hsv[2] === 0) {
        hsv[1] = 100;
    }
    return hsv;
};

var hsvToHex = function hsvToHex(h, s, v) {
    return (
        // Scale hue back up to [0, 360] from [0, 100]
        (0, _parseColor2.default)('hsv(' + 3.6 * h + ', ' + s + ', ' + v + ')').hex
    );
};

// Important! This component ignores new color props except when isEyeDropping
// This is to make the HSV <=> RGB conversion stable. The sliders manage their
// own changes until unmounted or color changes with props.isEyeDropping = true.

var ColorPicker = function (_React$Component) {
    _inherits(ColorPicker, _React$Component);

    function ColorPicker(props) {
        _classCallCheck(this, ColorPicker);

        var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, props));

        (0, _lodash2.default)(_this, ['getHsv', 'handleChangeGradientTypeHorizontal', 'handleChangeGradientTypeRadial', 'handleChangeGradientTypeSolid', 'handleChangeGradientTypeVertical', 'handleHueChange', 'handleSaturationChange', 'handleBrightnessChange', 'handleTransparent', 'handleActivateEyeDropper']);

        var color = props.colorIndex === 0 ? props.color : props.color2;
        var hsv = _this.getHsv(color);
        _this.state = {
            hue: hsv[0],
            saturation: hsv[1],
            brightness: hsv[2]
        };
        return _this;
    }

    _createClass(ColorPicker, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(newProps) {
            var color = newProps.colorIndex === 0 ? this.props.color : this.props.color2;
            var newColor = newProps.colorIndex === 0 ? newProps.color : newProps.color2;
            var colorSetByEyedropper = this.props.isEyeDropping && color !== newColor;
            if (colorSetByEyedropper || this.props.colorIndex !== newProps.colorIndex) {
                var hsv = this.getHsv(newColor);
                this.setState({
                    hue: hsv[0],
                    saturation: hsv[1],
                    brightness: hsv[2]
                });
            }
        }
    }, {
        key: 'getHsv',
        value: function getHsv(color) {
            var isTransparent = color === null;
            var isMixed = color === _stylePath.MIXED;
            return isTransparent || isMixed ? [50, 100, 100] : colorStringToHsv(color);
        }
    }, {
        key: 'handleHueChange',
        value: function handleHueChange(hue) {
            var _this2 = this;

            this.setState({ hue: hue }, function () {
                _this2.handleColorChange();
            });
        }
    }, {
        key: 'handleSaturationChange',
        value: function handleSaturationChange(saturation) {
            var _this3 = this;

            this.setState({ saturation: saturation }, function () {
                _this3.handleColorChange();
            });
        }
    }, {
        key: 'handleBrightnessChange',
        value: function handleBrightnessChange(brightness) {
            var _this4 = this;

            this.setState({ brightness: brightness }, function () {
                _this4.handleColorChange();
            });
        }
    }, {
        key: 'handleColorChange',
        value: function handleColorChange() {
            this.props.onChangeColor(hsvToHex(this.state.hue, this.state.saturation, this.state.brightness));
        }
    }, {
        key: 'handleTransparent',
        value: function handleTransparent() {
            this.props.onChangeColor(null);
        }
    }, {
        key: 'handleActivateEyeDropper',
        value: function handleActivateEyeDropper() {
            this.props.onActivateEyeDropper(_paper2.default.tool, // get the currently active tool from paper
            this.props.onChangeColor);
        }
    }, {
        key: 'handleChangeGradientTypeHorizontal',
        value: function handleChangeGradientTypeHorizontal() {
            this.props.onChangeGradientType(_gradientTypes2.default.HORIZONTAL);
        }
    }, {
        key: 'handleChangeGradientTypeRadial',
        value: function handleChangeGradientTypeRadial() {
            this.props.onChangeGradientType(_gradientTypes2.default.RADIAL);
        }
    }, {
        key: 'handleChangeGradientTypeSolid',
        value: function handleChangeGradientTypeSolid() {
            this.props.onChangeGradientType(_gradientTypes2.default.SOLID);
        }
    }, {
        key: 'handleChangeGradientTypeVertical',
        value: function handleChangeGradientTypeVertical() {
            this.props.onChangeGradientType(_gradientTypes2.default.VERTICAL);
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_colorPicker2.default, {
                brightness: this.state.brightness,
                color: this.props.color,
                color2: this.props.color2,
                colorIndex: this.props.colorIndex,
                gradientType: this.props.gradientType,
                hue: this.state.hue,
                isEyeDropping: this.props.isEyeDropping,
                mode: this.props.mode,
                rtl: this.props.rtl,
                saturation: this.state.saturation,
                shouldShowGradientTools: this.props.shouldShowGradientTools,
                onActivateEyeDropper: this.handleActivateEyeDropper,
                onBrightnessChange: this.handleBrightnessChange,
                onChangeGradientTypeHorizontal: this.handleChangeGradientTypeHorizontal,
                onChangeGradientTypeRadial: this.handleChangeGradientTypeRadial,
                onChangeGradientTypeSolid: this.handleChangeGradientTypeSolid,
                onChangeGradientTypeVertical: this.handleChangeGradientTypeVertical,
                onHueChange: this.handleHueChange,
                onSaturationChange: this.handleSaturationChange,
                onSelectColor: this.props.onSelectColor,
                onSelectColor2: this.props.onSelectColor2,
                onSwap: this.props.onSwap,
                onTransparent: this.handleTransparent
            });
        }
    }]);

    return ColorPicker;
}(_react2.default.Component);

ColorPicker.propTypes = {
    color: _propTypes2.default.string,
    color2: _propTypes2.default.string,
    colorIndex: _propTypes2.default.number.isRequired,
    gradientType: _propTypes2.default.oneOf(Object.keys(_gradientTypes2.default)).isRequired,
    isEyeDropping: _propTypes2.default.bool.isRequired,
    mode: _propTypes2.default.oneOf(Object.keys(_modes2.default)),
    onActivateEyeDropper: _propTypes2.default.func.isRequired,
    onChangeColor: _propTypes2.default.func.isRequired,
    onChangeGradientType: _propTypes2.default.func,
    onSelectColor: _propTypes2.default.func.isRequired,
    onSelectColor2: _propTypes2.default.func.isRequired,
    onSwap: _propTypes2.default.func,
    rtl: _propTypes2.default.bool.isRequired,
    shouldShowGradientTools: _propTypes2.default.bool.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        colorIndex: state.scratchPaint.fillMode.colorIndex,
        isEyeDropping: state.scratchPaint.color.eyeDropper.active,
        mode: state.scratchPaint.mode,
        rtl: state.scratchPaint.layout.rtl
    };
};

var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        onActivateEyeDropper: function onActivateEyeDropper(currentTool, callback) {
            dispatch((0, _eyeDropper.activateEyeDropper)(currentTool, callback));
        },
        onSelectColor: function onSelectColor() {
            dispatch((0, _colorIndex.changeColorIndex)(0));
        },
        onSelectColor2: function onSelectColor2() {
            dispatch((0, _colorIndex.changeColorIndex)(1));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(ColorPicker);

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactIntl = __webpack_require__(23);

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _parseColor = __webpack_require__(43);

var _parseColor2 = _interopRequireDefault(_parseColor);

var _slider = __webpack_require__(152);

var _slider2 = _interopRequireDefault(_slider);

var _labeledIconButton = __webpack_require__(53);

var _labeledIconButton2 = _interopRequireDefault(_labeledIconButton);

var _colorPicker = __webpack_require__(157);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _stylePath = __webpack_require__(9);

var _eyeDropper = __webpack_require__(159);

var _eyeDropper2 = _interopRequireDefault(_eyeDropper);

var _noFill = __webpack_require__(78);

var _noFill2 = _interopRequireDefault(_noFill);

var _mixedFill = __webpack_require__(79);

var _mixedFill2 = _interopRequireDefault(_mixedFill);

var _fillHorzGradientEnabled = __webpack_require__(160);

var _fillHorzGradientEnabled2 = _interopRequireDefault(_fillHorzGradientEnabled);

var _fillRadialEnabled = __webpack_require__(161);

var _fillRadialEnabled2 = _interopRequireDefault(_fillRadialEnabled);

var _fillSolidEnabled = __webpack_require__(162);

var _fillSolidEnabled2 = _interopRequireDefault(_fillSolidEnabled);

var _fillVertGradientEnabled = __webpack_require__(163);

var _fillVertGradientEnabled2 = _interopRequireDefault(_fillVertGradientEnabled);

var _swap = __webpack_require__(164);

var _swap2 = _interopRequireDefault(_swap);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var hsvToHex = function hsvToHex(h, s, v) {
    return (
        // Scale hue back up to [0, 360] from [0, 100]
        (0, _parseColor2.default)('hsv(' + 3.6 * h + ', ' + s + ', ' + v + ')').hex
    );
};

var messages = (0, _reactIntl.defineMessages)({
    swap: {
        'id': 'paint.colorPicker.swap',
        'defaultMessage': 'Swap'
    }
});

var ColorPickerComponent = function (_React$Component) {
    _inherits(ColorPickerComponent, _React$Component);

    function ColorPickerComponent() {
        _classCallCheck(this, ColorPickerComponent);

        return _possibleConstructorReturn(this, (ColorPickerComponent.__proto__ || Object.getPrototypeOf(ColorPickerComponent)).apply(this, arguments));
    }

    _createClass(ColorPickerComponent, [{
        key: '_makeBackground',
        value: function _makeBackground(channel) {
            var stops = [];
            // Generate the color slider background CSS gradients by adding
            // color stops depending on the slider.
            for (var n = 100; n >= 0; n -= 10) {
                switch (channel) {
                    case 'hue':
                        stops.push(hsvToHex(n, this.props.saturation, this.props.brightness));
                        break;
                    case 'saturation':
                        stops.push(hsvToHex(this.props.hue, n, this.props.brightness));
                        break;
                    case 'brightness':
                        stops.push(hsvToHex(this.props.hue, this.props.saturation, n));
                        break;
                    default:
                        throw new Error('Unknown channel for color sliders: ' + channel);
                }
            }

            // The sliders are a rounded capsule shape, and the slider handles are circles. As a consequence, when the
            // slider handle is fully to one side, its center is actually moved away from the start/end of the slider by
            // the slider handle's radius, meaning that the effective range of the slider excludes the rounded caps.
            // To compensate for this, position the first stop to where the rounded cap ends, and position the last stop
            // to where the rounded cap begins.
            var halfHandleWidth = _slider.HANDLE_WIDTH / 2;
            stops[0] += ' 0 ' + halfHandleWidth + 'px';
            stops[stops.length - 1] += ' ' + (_slider.CONTAINER_WIDTH - halfHandleWidth) + 'px 100%';

            return 'linear-gradient(to left, ' + stops.join(',') + ')';
        }
    }, {
        key: 'render',
        value: function render() {
            var _classNames, _classNames2, _classNames3, _classNames4, _classNames5, _classNames6, _classNames7, _classNames8;

            return _react2.default.createElement(
                'div',
                {
                    className: _colorPicker2.default.colorPickerContainer,
                    dir: this.props.rtl ? 'rtl' : 'ltr'
                },
                this.props.shouldShowGradientTools ? _react2.default.createElement(
                    'div',
                    null,
                    _react2.default.createElement(
                        'div',
                        { className: _colorPicker2.default.row },
                        _react2.default.createElement(
                            'div',
                            { className: _colorPicker2.default.gradientPickerRow },
                            _react2.default.createElement('img', {
                                className: (0, _classnames2.default)((_classNames = {}, _defineProperty(_classNames, _colorPicker2.default.inactiveGradient, this.props.gradientType !== _gradientTypes2.default.SOLID), _defineProperty(_classNames, _colorPicker2.default.clickable, true), _classNames)),
                                draggable: false,
                                src: _fillSolidEnabled2.default,
                                onClick: this.props.onChangeGradientTypeSolid
                            }),
                            _react2.default.createElement('img', {
                                className: (0, _classnames2.default)((_classNames2 = {}, _defineProperty(_classNames2, _colorPicker2.default.inactiveGradient, this.props.gradientType !== _gradientTypes2.default.HORIZONTAL), _defineProperty(_classNames2, _colorPicker2.default.clickable, true), _classNames2)),
                                draggable: false,
                                src: _fillHorzGradientEnabled2.default,
                                onClick: this.props.onChangeGradientTypeHorizontal
                            }),
                            _react2.default.createElement('img', {
                                className: (0, _classnames2.default)((_classNames3 = {}, _defineProperty(_classNames3, _colorPicker2.default.inactiveGradient, this.props.gradientType !== _gradientTypes2.default.VERTICAL), _defineProperty(_classNames3, _colorPicker2.default.clickable, true), _classNames3)),
                                draggable: false,
                                src: _fillVertGradientEnabled2.default,
                                onClick: this.props.onChangeGradientTypeVertical
                            }),
                            _react2.default.createElement('img', {
                                className: (0, _classnames2.default)((_classNames4 = {}, _defineProperty(_classNames4, _colorPicker2.default.inactiveGradient, this.props.gradientType !== _gradientTypes2.default.RADIAL), _defineProperty(_classNames4, _colorPicker2.default.clickable, true), _classNames4)),
                                draggable: false,
                                src: _fillRadialEnabled2.default,
                                onClick: this.props.onChangeGradientTypeRadial
                            })
                        )
                    ),
                    _react2.default.createElement('div', { className: _colorPicker2.default.divider }),
                    this.props.gradientType === _gradientTypes2.default.SOLID ? null : _react2.default.createElement(
                        'div',
                        { className: _colorPicker2.default.row },
                        _react2.default.createElement(
                            'div',
                            {
                                className: (0, _classnames2.default)(_colorPicker2.default.gradientPickerRow, _colorPicker2.default.gradientSwatchesRow)
                            },
                            _react2.default.createElement(
                                'div',
                                {
                                    className: (0, _classnames2.default)((_classNames5 = {}, _defineProperty(_classNames5, _colorPicker2.default.clickable, true), _defineProperty(_classNames5, _colorPicker2.default.swatch, true), _defineProperty(_classNames5, _colorPicker2.default.largeSwatch, true), _defineProperty(_classNames5, _colorPicker2.default.activeSwatch, this.props.colorIndex === 0), _classNames5)),
                                    style: {
                                        backgroundColor: this.props.color === null || this.props.color === _stylePath.MIXED ? 'white' : this.props.color
                                    },
                                    onClick: this.props.onSelectColor
                                },
                                this.props.color === null ? _react2.default.createElement('img', {
                                    className: _colorPicker2.default.largeSwatchIcon,
                                    draggable: false,
                                    src: _noFill2.default
                                }) : this.props.color === _stylePath.MIXED ? _react2.default.createElement('img', {
                                    className: _colorPicker2.default.largeSwatchIcon,
                                    draggable: false,
                                    src: _mixedFill2.default
                                }) : null
                            ),
                            _react2.default.createElement(_labeledIconButton2.default, {
                                className: _colorPicker2.default.swapButton,
                                imgSrc: _swap2.default,
                                title: this.props.intl.formatMessage(messages.swap),
                                onClick: this.props.onSwap
                            }),
                            _react2.default.createElement(
                                'div',
                                {
                                    className: (0, _classnames2.default)((_classNames6 = {}, _defineProperty(_classNames6, _colorPicker2.default.clickable, true), _defineProperty(_classNames6, _colorPicker2.default.swatch, true), _defineProperty(_classNames6, _colorPicker2.default.largeSwatch, true), _defineProperty(_classNames6, _colorPicker2.default.activeSwatch, this.props.colorIndex === 1), _classNames6)),
                                    style: {
                                        backgroundColor: this.props.color2 === null || this.props.color2 === _stylePath.MIXED ? 'white' : this.props.color2
                                    },
                                    onClick: this.props.onSelectColor2
                                },
                                this.props.color2 === null ? _react2.default.createElement('img', {
                                    className: _colorPicker2.default.largeSwatchIcon,
                                    draggable: false,
                                    src: _noFill2.default
                                }) : this.props.color2 === _stylePath.MIXED ? _react2.default.createElement('img', {
                                    className: _colorPicker2.default.largeSwatchIcon,
                                    draggable: false,
                                    src: _mixedFill2.default
                                }) : null
                            )
                        )
                    )
                ) : null,
                _react2.default.createElement(
                    'div',
                    { className: _colorPicker2.default.row },
                    _react2.default.createElement(
                        'div',
                        { className: _colorPicker2.default.rowHeader },
                        _react2.default.createElement(
                            'span',
                            { className: _colorPicker2.default.labelName },
                            _react2.default.createElement(_reactIntl.FormattedMessage, {
                                defaultMessage: 'Color',

                                id: 'paint.paintEditor.hue'
                            })
                        ),
                        _react2.default.createElement(
                            'span',
                            { className: _colorPicker2.default.labelReadout },
                            Math.round(this.props.hue)
                        )
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: _colorPicker2.default.rowSlider },
                        _react2.default.createElement(_slider2.default, {
                            background: this._makeBackground('hue'),
                            value: this.props.hue,
                            onChange: this.props.onHueChange
                        })
                    )
                ),
                _react2.default.createElement(
                    'div',
                    { className: _colorPicker2.default.row },
                    _react2.default.createElement(
                        'div',
                        { className: _colorPicker2.default.rowHeader },
                        _react2.default.createElement(
                            'span',
                            { className: _colorPicker2.default.labelName },
                            _react2.default.createElement(_reactIntl.FormattedMessage, {
                                defaultMessage: 'Saturation',

                                id: 'paint.paintEditor.saturation'
                            })
                        ),
                        _react2.default.createElement(
                            'span',
                            { className: _colorPicker2.default.labelReadout },
                            Math.round(this.props.saturation)
                        )
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: _colorPicker2.default.rowSlider },
                        _react2.default.createElement(_slider2.default, {
                            background: this._makeBackground('saturation'),
                            value: this.props.saturation,
                            onChange: this.props.onSaturationChange
                        })
                    )
                ),
                _react2.default.createElement(
                    'div',
                    { className: _colorPicker2.default.row },
                    _react2.default.createElement(
                        'div',
                        { className: _colorPicker2.default.rowHeader },
                        _react2.default.createElement(
                            'span',
                            { className: _colorPicker2.default.labelName },
                            _react2.default.createElement(_reactIntl.FormattedMessage, {
                                defaultMessage: 'Brightness',

                                id: 'paint.paintEditor.brightness'
                            })
                        ),
                        _react2.default.createElement(
                            'span',
                            { className: _colorPicker2.default.labelReadout },
                            Math.round(this.props.brightness)
                        )
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: _colorPicker2.default.rowSlider },
                        _react2.default.createElement(_slider2.default, {
                            lastSlider: true,
                            background: this._makeBackground('brightness'),
                            value: this.props.brightness,
                            onChange: this.props.onBrightnessChange
                        })
                    )
                ),
                _react2.default.createElement(
                    'div',
                    { className: _colorPicker2.default.swatchRow },
                    _react2.default.createElement(
                        'div',
                        { className: _colorPicker2.default.swatches },
                        this.props.mode === _modes2.default.BIT_LINE || this.props.mode === _modes2.default.BIT_RECT || this.props.mode === _modes2.default.BIT_OVAL || this.props.mode === _modes2.default.BIT_TEXT ? null : _react2.default.createElement(
                            'div',
                            {
                                className: (0, _classnames2.default)((_classNames7 = {}, _defineProperty(_classNames7, _colorPicker2.default.clickable, true), _defineProperty(_classNames7, _colorPicker2.default.swatch, true), _defineProperty(_classNames7, _colorPicker2.default.activeSwatch, this.props.colorIndex === 0 && this.props.color === null || this.props.colorIndex === 1 && this.props.color2 === null), _classNames7)),
                                onClick: this.props.onTransparent
                            },
                            _react2.default.createElement('img', {
                                className: _colorPicker2.default.swatchIcon,
                                draggable: false,
                                src: _noFill2.default
                            })
                        )
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: _colorPicker2.default.swatches },
                        _react2.default.createElement(
                            'div',
                            {
                                className: (0, _classnames2.default)((_classNames8 = {}, _defineProperty(_classNames8, _colorPicker2.default.clickable, true), _defineProperty(_classNames8, _colorPicker2.default.swatch, true), _defineProperty(_classNames8, _colorPicker2.default.activeSwatch, this.props.isEyeDropping), _classNames8)),
                                onClick: this.props.onActivateEyeDropper
                            },
                            _react2.default.createElement('img', {
                                className: _colorPicker2.default.swatchIcon,
                                draggable: false,
                                src: _eyeDropper2.default
                            })
                        )
                    )
                )
            );
        }
    }]);

    return ColorPickerComponent;
}(_react2.default.Component);

ColorPickerComponent.propTypes = {
    brightness: _propTypes2.default.number.isRequired,
    color: _propTypes2.default.string,
    color2: _propTypes2.default.string,
    colorIndex: _propTypes2.default.number.isRequired,
    gradientType: _propTypes2.default.oneOf(Object.keys(_gradientTypes2.default)).isRequired,
    hue: _propTypes2.default.number.isRequired,
    intl: _reactIntl.intlShape.isRequired,
    isEyeDropping: _propTypes2.default.bool.isRequired,
    mode: _propTypes2.default.oneOf(Object.keys(_modes2.default)),
    onActivateEyeDropper: _propTypes2.default.func.isRequired,
    onBrightnessChange: _propTypes2.default.func.isRequired,
    onChangeGradientTypeHorizontal: _propTypes2.default.func.isRequired,
    onChangeGradientTypeRadial: _propTypes2.default.func.isRequired,
    onChangeGradientTypeSolid: _propTypes2.default.func.isRequired,
    onChangeGradientTypeVertical: _propTypes2.default.func.isRequired,
    onHueChange: _propTypes2.default.func.isRequired,
    onSaturationChange: _propTypes2.default.func.isRequired,
    onSelectColor: _propTypes2.default.func.isRequired,
    onSelectColor2: _propTypes2.default.func.isRequired,
    onSwap: _propTypes2.default.func,
    onTransparent: _propTypes2.default.func.isRequired,
    rtl: _propTypes2.default.bool.isRequired,
    saturation: _propTypes2.default.number.isRequired,
    shouldShowGradientTools: _propTypes2.default.bool.isRequired
};

exports.default = (0, _reactIntl.injectIntl)(ColorPickerComponent);

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HANDLE_WIDTH = exports.CONTAINER_WIDTH = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _touchUtils = __webpack_require__(61);

var _slider = __webpack_require__(153);

var _slider2 = _interopRequireDefault(_slider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CONTAINER_WIDTH = 150;
var HANDLE_WIDTH = 26;

var SliderComponent = function (_React$Component) {
    _inherits(SliderComponent, _React$Component);

    function SliderComponent(props) {
        _classCallCheck(this, SliderComponent);

        var _this = _possibleConstructorReturn(this, (SliderComponent.__proto__ || Object.getPrototypeOf(SliderComponent)).call(this, props));

        (0, _lodash2.default)(_this, ['handleMouseDown', 'handleMouseUp', 'handleMouseMove', 'handleClickBackground', 'setBackground', 'setHandle']);

        // Distance from the left edge of the slider handle to the mouse down/click event
        _this.handleClickOffset = 0;
        return _this;
    }

    _createClass(SliderComponent, [{
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            document.addEventListener('mousemove', this.handleMouseMove);
            document.addEventListener('mouseup', this.handleMouseUp);
            document.addEventListener('touchmove', this.handleMouseMove, { passive: false });
            document.addEventListener('touchend', this.handleMouseUp);

            this.handleClickOffset = (0, _touchUtils.getEventXY)(event).x - this.handle.getBoundingClientRect().left;
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp() {
            document.removeEventListener('mousemove', this.handleMouseMove);
            document.removeEventListener('mouseup', this.handleMouseUp);
            document.removeEventListener('touchmove', this.handleMouseMove, { passive: false });
            document.removeEventListener('touchend', this.handleMouseUp);
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            event.preventDefault();
            this.props.onChange(this.scaleMouseToSliderPosition(event));
        }
    }, {
        key: 'handleClickBackground',
        value: function handleClickBackground(event) {
            // Because the slider handle is a child of the "background" element this handler is registered to, it calls this
            // when clicked as well. We only want to change the slider value if the user clicked on the background itself.
            if (event.target !== this.background) return;
            // Move slider handle's center to the cursor
            this.handleClickOffset = HANDLE_WIDTH / 2;
            this.props.onChange(this.scaleMouseToSliderPosition(event));
        }
    }, {
        key: 'scaleMouseToSliderPosition',
        value: function scaleMouseToSliderPosition(event) {
            var _getEventXY = (0, _touchUtils.getEventXY)(event),
                x = _getEventXY.x;

            var backgroundBBox = this.background.getBoundingClientRect();
            var scaledX = x - backgroundBBox.left - this.handleClickOffset;
            return Math.max(0, Math.min(100, 100 * scaledX / (backgroundBBox.width - HANDLE_WIDTH)));
        }
    }, {
        key: 'setBackground',
        value: function setBackground(ref) {
            this.background = ref;
        }
    }, {
        key: 'setHandle',
        value: function setHandle(ref) {
            this.handle = ref;
        }
    }, {
        key: 'render',
        value: function render() {
            var _classNames;

            var halfHandleWidth = HANDLE_WIDTH / 2;
            var pixelMin = halfHandleWidth;
            var pixelMax = CONTAINER_WIDTH - halfHandleWidth;
            var handleOffset = pixelMin + (pixelMax - pixelMin) * (this.props.value / 100) - halfHandleWidth;
            return _react2.default.createElement(
                'div',
                {
                    className: (0, _classnames2.default)((_classNames = {}, _defineProperty(_classNames, _slider2.default.container, true), _defineProperty(_classNames, _slider2.default.last, this.props.lastSlider), _classNames)),
                    ref: this.setBackground,
                    style: {
                        backgroundImage: this.props.background
                    },
                    onClick: this.handleClickBackground
                },
                _react2.default.createElement('div', {
                    className: _slider2.default.handle,
                    ref: this.setHandle,
                    style: {
                        left: handleOffset + 'px'
                    },
                    onMouseDown: this.handleMouseDown,
                    onTouchStart: this.handleMouseDown
                })
            );
        }
    }]);

    return SliderComponent;
}(_react2.default.Component);

SliderComponent.propTypes = {
    background: _propTypes2.default.string,
    lastSlider: _propTypes2.default.bool,
    onChange: _propTypes2.default.func.isRequired,
    value: _propTypes2.default.number.isRequired
};

SliderComponent.defaultProps = {
    background: 'yellow'
};

exports.default = SliderComponent;
exports.CONTAINER_WIDTH = CONTAINER_WIDTH;
exports.HANDLE_WIDTH = HANDLE_WIDTH;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(154);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".slider_container_2U0n6 {\n    margin: 8px;\n    height: 22px;\n    width: 150px;\n    position: relative;\n    outline: none;\n    border-radius: 11px;\n    margin-bottom: 20px;\n}\n\n.slider_last_3coMi {\n    margin-bottom: 4px;\n}\n\n.slider_handle_2M_mA {\n    left: 100px;\n    width: 26px;\n    height: 26px;\n    margin-top: -2px;\n    position: absolute;\n    background-color: white;\n    border-radius: 100%;\n    -webkit-box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.15);\n            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.15);\n    -ms-touch-action: none;\n        touch-action: none;\n}\n", ""]);
// Exports
exports.locals = {
	"container": "slider_container_2U0n6",
	"last": "slider_last_3coMi",
	"handle": "slider_handle_2M_mA"
};
module.exports = exports;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(156);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n.labeled-icon-button_mod-edit-field_Z3eav {\n    background: none;\n    border: none;\n    display: inline-block;\n    padding: .25rem .325rem;\n    outline: none;\n    border-radius: 0.25rem;\n    min-width: 3rem;\n    font-size: 0.85rem;\n    text-align: center;\n}\n\n.labeled-icon-button_edit-field-icon_1BGdr {\n    width: 1.5rem;\n    height: 1.5rem;\n    -webkit-box-flex: 1;\n    -webkit-flex-grow: 1;\n        -ms-flex-positive: 1;\n            flex-grow: 1;\n    vertical-align: middle;\n}\n\n.labeled-icon-button_edit-field-title_32vCQ {\n    display: block;\n    margin-top: .125rem;\n    font-size: .625rem;\n}\n", ""]);
// Exports
exports.locals = {
	"mod-edit-field": "labeled-icon-button_mod-edit-field_Z3eav",
	"modEditField": "labeled-icon-button_mod-edit-field_Z3eav",
	"edit-field-icon": "labeled-icon-button_edit-field-icon_1BGdr",
	"editFieldIcon": "labeled-icon-button_edit-field-icon_1BGdr",
	"edit-field-title": "labeled-icon-button_edit-field-title_32vCQ",
	"editFieldTitle": "labeled-icon-button_edit-field-title_32vCQ"
};
module.exports = exports;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(158);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n/* Popover styles */\n\n.Popover-body {\n    background: white;\n    border: 1px solid #ddd;\n    padding: 4px;\n    border-radius: 4px;\n    padding: 4px;\n    -webkit-box-shadow: 0px 0px 8px 1px rgba(0, 0, 0, .3);\n            box-shadow: 0px 0px 8px 1px rgba(0, 0, 0, .3);\n}\n\n.Popover-tipShape {\n    fill: white;\n    stroke: #ddd;\n}\n\n.color-picker_clickable_1qAhZ {\n    cursor: pointer;\n}\n\n.color-picker_swatch-row_3ygSb {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n        -ms-flex-direction: row;\n            flex-direction: row;\n    -webkit-box-pack: justify;\n    -webkit-justify-content: space-between;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n}\n\n.color-picker_row-header_23YDh {\n    font-family: \"Helvetica Neue\", Helvetica, sans-serif;\n    font-size: 0.65rem;\n    color: #575E75;\n    margin: 8px;\n}\n\n[dir=\"ltr\"] .color-picker_label-readout_efqFT {\n    margin-left: 10px;\n}\n\n[dir=\"rtl\"] .color-picker_label-readout_efqFT {\n    margin-right: 10px;\n}\n\n.color-picker_label-name_3kaOv {\n    font-weight: bold;\n}\n\n.color-picker_divider_3Hq7P {\n    border-top: 1px solid #ddd;\n    margin: 8px;\n}\n\n.color-picker_swap-button_knDOR {\n    margin-left: 8px;\n    margin-right: 8px;\n}\n\n.color-picker_swatches_3P15b {\n    margin: 8px;\n}\n\n.color-picker_swatch_3zRbd {\n    width: 1.5rem;\n    height: 1.5rem;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    -webkit-box-sizing: content-box;\n            box-sizing: content-box;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n\n.color-picker_large-swatch-icon_2EdzJ {\n    width: 1.75rem;\n    margin: auto;\n}\n\n.color-picker_large-swatch_2tprq {\n    width: 2rem;\n    height: 2rem;\n}\n\n.color-picker_active-swatch_2U6UP {\n    border: 1px solid #4C97FF;\n    -webkit-box-shadow: 0px 0px 0px 3px hsla(215, 100%, 65%, 0.2);\n            box-shadow: 0px 0px 0px 3px hsla(215, 100%, 65%, 0.2);\n}\n\n.color-picker_swatch-icon_1GWhH {\n    width: 1.5rem;\n    height: 1.5rem;\n}\n\n.color-picker_inactive-gradient_3LMcb {\n    -webkit-filter: saturate(0%);\n            filter: saturate(0%);\n}\n\n.color-picker_gradient-picker-row_2ZOSs {\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n        -ms-flex-direction: row;\n            flex-direction: row;\n    -webkit-box-pack: center;\n    -webkit-justify-content: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    margin: 8px;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n\n[dir=\"ltr\"] .color-picker_gradient-picker-row_2ZOSs > img + img {\n    margin-left: calc(2 * .25rem);\n}\n\n[dir=\"rtl\"] .color-picker_gradient-picker-row_2ZOSs > img + img {\n    margin-right: calc(2 * .25rem);\n}\n\n[dir=\"rtl\"] .color-picker_gradient-swatches-row_1laEb {\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: reverse;\n    -webkit-flex-direction: row-reverse;\n        -ms-flex-direction: row-reverse;\n            flex-direction: row-reverse;\n}\n", ""]);
// Exports
exports.locals = {
	"clickable": "color-picker_clickable_1qAhZ",
	"swatch-row": "color-picker_swatch-row_3ygSb",
	"swatchRow": "color-picker_swatch-row_3ygSb",
	"row-header": "color-picker_row-header_23YDh",
	"rowHeader": "color-picker_row-header_23YDh",
	"label-readout": "color-picker_label-readout_efqFT",
	"labelReadout": "color-picker_label-readout_efqFT",
	"label-name": "color-picker_label-name_3kaOv",
	"labelName": "color-picker_label-name_3kaOv",
	"divider": "color-picker_divider_3Hq7P",
	"swap-button": "color-picker_swap-button_knDOR",
	"swapButton": "color-picker_swap-button_knDOR",
	"swatches": "color-picker_swatches_3P15b",
	"swatch": "color-picker_swatch_3zRbd",
	"large-swatch-icon": "color-picker_large-swatch-icon_2EdzJ",
	"largeSwatchIcon": "color-picker_large-swatch-icon_2EdzJ",
	"large-swatch": "color-picker_large-swatch_2tprq",
	"largeSwatch": "color-picker_large-swatch_2tprq",
	"active-swatch": "color-picker_active-swatch_2U6UP",
	"activeSwatch": "color-picker_active-swatch_2U6UP",
	"swatch-icon": "color-picker_swatch-icon_1GWhH",
	"swatchIcon": "color-picker_swatch-icon_1GWhH",
	"inactive-gradient": "color-picker_inactive-gradient_3LMcb",
	"inactiveGradient": "color-picker_inactive-gradient_3LMcb",
	"gradient-picker-row": "color-picker_gradient-picker-row_2ZOSs",
	"gradientPickerRow": "color-picker_gradient-picker-row_2ZOSs",
	"gradient-swatches-row": "color-picker_gradient-swatches-row_1laEb",
	"gradientSwatchesRow": "color-picker_gradient-swatches-row_1laEb"
};
module.exports = exports;


/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eeye-dropper%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='eye-dropper' fill='%23575E75'%3E %3Cpath d='M9.15334605,12.4824962 C9.03394044,12.6188737 8.88041895,12.7041096 8.60749186,12.7722983 C7.90811618,12.925723 7.24285639,13.5564688 7.03816107,14.2554033 C6.9699293,14.4770167 6.74817603,14.7156773 6.50936483,14.8350076 L4.73533871,15.6703196 C4.650049,15.704414 4.58181722,15.7214612 4.54770134,15.7214612 L4.27477424,15.4657534 C4.27477424,15.4487062 4.27477424,15.3805175 4.32594807,15.2611872 L5.1617873,13.4712329 C5.26413496,13.2496195 5.50294617,13.0280061 5.74175737,12.9598174 C6.44113305,12.738204 7.07227696,12.090411 7.25991433,11.2380518 C7.29403022,11.1016743 7.37931994,10.9652968 7.49872554,10.8289193 L11.4391105,6.90806697 L13.093731,8.56164384 L9.15334605,12.4824962 Z M16.6076673,5.28858447 C16.8635365,5.03287671 17,4.67488584 17,4.33394216 C17,3.99299848 16.8635365,3.65205479 16.6076673,3.39634703 C16.0788711,2.86788432 15.2430318,2.86788432 14.7142356,3.39634703 L13.2301945,4.87945205 L13.0596151,4.70898021 L12.5137609,4.16347032 C12.172602,3.82252664 11.6096899,3.82252664 11.268531,4.16347032 L10.6032712,4.81126332 C10.2791703,5.152207 10.2621124,5.64657534 10.5520974,5.98751903 L6.59465454,9.92541857 C6.30466951,10.2322679 6.09997418,10.5902588 5.98056858,11.1016743 C5.92939475,11.357382 5.63940971,11.6471842 5.36648262,11.7324201 C4.80357049,11.9028919 4.2577163,12.3802131 4.00184715,12.9427702 L3.16600792,14.7156773 C2.89308083,15.3123288 2.9613126,15.9260274 3.33658736,16.3181126 L3.67774623,16.6590563 C3.89949949,16.8806697 4.20654247,17 4.54770134,17 C4.7694546,17 5.02532375,16.9318113 5.26413496,16.8295282 L7.05521901,15.9942161 C7.61813114,15.7214612 8.09575356,15.1929985 8.26633299,14.6304414 C8.33456477,14.3576865 8.64160775,14.0678843 9.05099839,13.9826484 C9.4092152,13.8974125 9.76743201,13.6928463 10.057417,13.385997 L14.0148599,9.44809741 C14.3560188,9.73789954 14.8677571,9.70380518 15.1748001,9.37990868 L15.8400599,8.73211568 C16.1812187,8.39117199 16.1812187,7.82861492 15.8400599,7.48767123 L15.2600898,6.90806697 L15.1236262,6.7716895 L16.6076673,5.28858447 Z' id='eye-dropper-icon'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 50.2 (55047) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Efill-horz-gradient-enabled%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E %3ClinearGradient x1='100%25' y1='50%25' x2='0%25' y2='50%25' id='linearGradient-1'%3E %3Cstop stop-color='%23FFFFFF' offset='0%25'%3E%3C/stop%3E %3Cstop stop-color='%234C97FF' offset='100%25'%3E%3C/stop%3E %3C/linearGradient%3E %3C/defs%3E %3Cg id='fill-horz-gradient-enabled' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' stroke-opacity='0.15'%3E %3Crect id='Horizontal' stroke='%23000000' fill='url(%23linearGradient-1)' x='0.5' y='0.5' width='19' height='19' rx='4'%3E%3C/rect%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 161 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 51 (57462) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Efill-radial-enabled%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E %3CradialGradient cx='50%25' cy='50%25' fx='50%25' fy='50%25' r='39.3896484%25' id='radialGradient-1'%3E %3Cstop stop-color='%234C97FF' offset='0%25'%3E%3C/stop%3E %3Cstop stop-color='%23FFFFFF' offset='100%25'%3E%3C/stop%3E %3C/radialGradient%3E %3C/defs%3E %3Cg id='fill-radial-enabled' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' stroke-opacity='0.15'%3E %3Crect id='Radial' stroke='%23000000' fill='url(%23radialGradient-1)' x='0.5' y='0.5' width='19' height='19' rx='4'%3E%3C/rect%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 162 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 50.2 (55047) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Efill-solid-enabled%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='fill-solid-enabled' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' stroke-opacity='0.15'%3E %3Crect id='Solid' stroke='%23000000' fill='%234C97FF' x='0.5' y='0.5' width='19' height='19' rx='4'%3E%3C/rect%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 163 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 51 (57462) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Efill-vert-gradient-enabled%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E %3ClinearGradient x1='50%25' y1='100%25' x2='50%25' y2='3.061617e-15%25' id='linearGradient-1'%3E %3Cstop stop-color='%23FFFFFF' offset='0%25'%3E%3C/stop%3E %3Cstop stop-color='%234C97FF' offset='100%25'%3E%3C/stop%3E %3C/linearGradient%3E %3C/defs%3E %3Cg id='fill-vert-gradient-enabled' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' stroke-opacity='0.15'%3E %3Crect id='Vertical' stroke='%23000000' fill='url(%23linearGradient-1)' x='0.5' y='0.5' width='19' height='19' rx='4'%3E%3C/rect%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 50.2 (55047) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eswap%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='swap' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='Swap-v2' transform='translate(2.000000, 2.000000)' fill='%234C97FF'%3E %3Cpath d='M3.69424597,2.00682151 L7.95663608,2.66498231 C8.44536222,2.73588913 8.7900887,3.24405473 8.7176525,3.79585529 C8.66179809,4.24129561 8.34150792,4.58764819 7.95663608,4.64128284 L3.69424597,5.30126176 L3.69424597,6.79666856 C3.69424597,7.22392764 3.23781067,7.42846657 2.97250219,7.13483958 L0.120436084,3.97403142 C-0.0401453614,3.78767373 -0.0401453614,3.48404706 0.120436084,3.30587093 L2.97250219,0.135972153 C3.23781067,-0.157654834 3.69424597,0.0559747078 3.69424597,0.474143173 L3.69424597,2.00682151 Z M12.305754,10.7340942 L12.305754,9.2014159 C12.305754,8.78324744 12.7621893,8.56961789 13.0274978,8.86324488 L15.8795639,12.0331437 C16.0401454,12.2113198 16.0401454,12.5149465 15.8795639,12.7013041 L13.0274978,15.8621123 C12.7621893,16.1557393 12.305754,15.9512004 12.305754,15.5239413 L12.305754,14.0285345 L8.04336392,13.3685556 C7.65849208,13.3149209 7.33820191,12.9685683 7.2823475,12.523128 C7.2099113,11.9713275 7.55463778,11.4631619 8.04336392,11.392255 L12.305754,10.7340942 Z' id='Swap-v1'%3E%3C/path%3E %3Cpath d='M11.2727273,1.45454545 L13.4545455,1.45454545 C14.0567273,1.45454545 14.5454545,1.94327273 14.5454545,2.54545455 L14.5454545,4.72727273 C14.5454545,5.33054545 14.0567273,5.81818182 13.4545455,5.81818182 L11.2727273,5.81818182 C10.6705455,5.81818182 10.1818182,5.33054545 10.1818182,4.72727273 L10.1818182,2.54545455 C10.1818182,1.94327273 10.6705455,1.45454545 11.2727273,1.45454545' id='Fill-6' fill-opacity='0.5'%3E%3C/path%3E %3Cpath d='M2.54545455,10.1818182 L4.72727273,10.1818182 C5.32945455,10.1818182 5.81818182,10.6705455 5.81818182,11.2727273 L5.81818182,13.4545455 C5.81818182,14.0578182 5.32945455,14.5454545 4.72727273,14.5454545 L2.54545455,14.5454545 C1.94327273,14.5454545 1.45454545,14.0578182 1.45454545,13.4545455 L1.45454545,11.2727273 C1.45454545,10.6705455 1.94327273,10.1818182 2.54545455,10.1818182' id='Fill-6-Copy' fill-opacity='0.5'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(166);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n.input-group_input-group_3FzNB {\n    display: -webkit-inline-box;\n    display: -webkit-inline-flex;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n        -ms-flex-direction: row;\n            flex-direction: row;\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n\n[dir=\"ltr\"] .input-group_input-group_3FzNB + .input-group_input-group_3FzNB {\n    margin-left: calc(2 * .25rem);\n}\n\n[dir=\"rtl\"] .input-group_input-group_3FzNB + .input-group_input-group_3FzNB {\n    margin-right: calc(2 * .25rem);\n}\n\n.input-group_disabled_3fp6_ {\n    opacity: 0.3;\n    /* Prevent any user actions */\n    pointer-events: none;\n}\n", ""]);
// Exports
exports.locals = {
	"input-group": "input-group_input-group_3FzNB",
	"inputGroup": "input-group_input-group_3FzNB",
	"disabled": "input-group_disabled_3fp6_"
};
module.exports = exports;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(168);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n.label_input-group_2vTky {\n    display: -webkit-inline-box;\n    display: -webkit-inline-flex;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n        -ms-flex-direction: row;\n            flex-direction: row;\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n\n[dir=\"ltr\"] .label_input-group_2vTky + .label_input-group_2vTky {\n    margin-left: calc(2 * .25rem);\n}\n\n[dir=\"rtl\"] .label_input-group_2vTky + .label_input-group_2vTky {\n    margin-right: calc(2 * .25rem);\n}\n\n.label_disabled_1HlGv {\n    opacity: 0.3;\n    /* Prevent any user actions */\n    pointer-events: none;\n}\n\n.label_input-label_3KjCa, .label_input-label-secondary_3QDNV {\n    font-size: 0.625rem;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    cursor: default;\n}\n\n[dir=\"ltr\"] .label_input-label_3KjCa, [dir=\"ltr\"] .label_input-label-secondary_3QDNV{\n    margin-right: calc(2 * .25rem);\n}\n\n[dir=\"rtl\"] .label_input-label_3KjCa, [dir=\"ltr\"] .label_input-label-secondary_3QDNV{\n    margin-left: calc(2 * .25rem);\n}\n\n.label_input-label_3KjCa {\n    font-weight: bold;\n}\n\n@media only screen and (max-width: 1256px) {\n    .label_input-group_2vTky {\n        display: -webkit-box;\n        display: -webkit-flex;\n        display: -ms-flexbox;\n        display: flex;\n        -webkit-box-orient: vertical;\n        -webkit-box-direction: normal;\n        -webkit-flex-direction: column;\n            -ms-flex-direction: column;\n                flex-direction: column;\n        -webkit-box-align: start;\n        -webkit-align-items: flex-start;\n            -ms-flex-align: start;\n                align-items: flex-start;\n        margin-top: -1rem; /* To align with the non-labeled inputs */\n    }\n\n    .label_input-label_3KjCa {\n        font-weight: normal;\n        margin-bottom: 0.25rem;\n    }\n}\n", ""]);
// Exports
exports.locals = {
	"input-group": "label_input-group_2vTky",
	"inputGroup": "label_input-group_2vTky",
	"disabled": "label_disabled_1HlGv",
	"input-label": "label_input-label_3KjCa",
	"inputLabel": "label_input-label_3KjCa",
	"input-label-secondary": "label_input-label-secondary_3QDNV",
	"inputLabelSecondary": "label_input-label-secondary_3QDNV"
};
module.exports = exports;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _fillTool = __webpack_require__(170);

var _fillTool2 = _interopRequireDefault(_fillTool);

var _stylePath = __webpack_require__(9);

var _fillStyle = __webpack_require__(18);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _selection = __webpack_require__(3);

var _hover = __webpack_require__(36);

var _fillModeGradientType = __webpack_require__(41);

var _fillMode = __webpack_require__(171);

var _fillMode2 = _interopRequireDefault(_fillMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FillMode = function (_React$Component) {
    _inherits(FillMode, _React$Component);

    function FillMode(props) {
        _classCallCheck(this, FillMode);

        var _this = _possibleConstructorReturn(this, (FillMode.__proto__ || Object.getPrototypeOf(FillMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(FillMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isFillModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool) {
                if (nextProps.fillColor !== this.props.fillColor) {
                    this.tool.setFillColor(nextProps.fillColor);
                }
                if (nextProps.fillColor2 !== this.props.fillColor2) {
                    this.tool.setFillColor2(nextProps.fillColor2);
                }
                if (nextProps.hoveredItemId !== this.props.hoveredItemId) {
                    this.tool.setPrevHoveredItemId(nextProps.hoveredItemId);
                }
                if (nextProps.fillModeGradientType !== this.props.fillModeGradientType) {
                    this.tool.setGradientType(nextProps.fillModeGradientType);
                }
            }

            if (nextProps.isFillModeActive && !this.props.isFillModeActive) {
                this.activateTool();
            } else if (!nextProps.isFillModeActive && this.props.isFillModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isFillModeActive !== this.props.isFillModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            (0, _selection.clearSelection)(this.props.clearSelectedItems);

            // Force the default fill color if fill is MIXED
            var fillColor = this.props.fillColor;
            if (this.props.fillColor === _stylePath.MIXED) {
                fillColor = _fillStyle.DEFAULT_COLOR;
                this.props.onChangeFillColor(_fillStyle.DEFAULT_COLOR, 0);
            }
            var gradientType = this.props.fillModeGradientType ? this.props.fillModeGradientType : this.props.fillStyleGradientType;
            var fillColor2 = this.props.fillColor2;
            if (gradientType !== this.props.fillStyleGradientType) {
                if (this.props.fillStyleGradientType === _gradientTypes2.default.SOLID) {
                    fillColor2 = (0, _stylePath.generateSecondaryColor)(fillColor);
                    this.props.onChangeFillColor(fillColor2, 1);
                }
                this.props.changeGradientType(gradientType);
            }
            if (this.props.fillColor2 === _stylePath.MIXED) {
                fillColor2 = (0, _stylePath.generateSecondaryColor)(fillColor);
                this.props.onChangeFillColor(fillColor2, 1);
            }
            this.tool = new _fillTool2.default(this.props.setHoveredItem, this.props.clearHoveredItem, this.props.onUpdateImage);
            this.tool.setFillColor(fillColor);
            this.tool.setFillColor2(fillColor2);
            this.tool.setGradientType(gradientType);
            this.tool.setPrevHoveredItemId(this.props.hoveredItemId);
            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_fillMode2.default, {
                isSelected: this.props.isFillModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return FillMode;
}(_react2.default.Component);

FillMode.propTypes = {
    changeGradientType: _propTypes2.default.func.isRequired,
    clearHoveredItem: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    fillColor: _propTypes2.default.string,
    fillColor2: _propTypes2.default.string,
    fillStyleGradientType: _propTypes2.default.oneOf(Object.keys(_gradientTypes2.default)).isRequired,
    fillModeGradientType: _propTypes2.default.oneOf(Object.keys(_gradientTypes2.default)),
    handleMouseDown: _propTypes2.default.func.isRequired,
    hoveredItemId: _propTypes2.default.number,
    isFillModeActive: _propTypes2.default.bool.isRequired,
    onChangeFillColor: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    setHoveredItem: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        fillModeGradientType: state.scratchPaint.fillMode.gradientType, // Last user-selected gradient type
        fillColor: state.scratchPaint.color.fillColor.primary,
        fillColor2: state.scratchPaint.color.fillColor.secondary,
        fillStyleGradientType: state.scratchPaint.color.fillColor.gradientType, // Selected item(s)' gradient type
        hoveredItemId: state.scratchPaint.hoveredItemId,
        isFillModeActive: state.scratchPaint.mode === _modes2.default.FILL
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        setHoveredItem: function setHoveredItem(hoveredItemId) {
            dispatch((0, _hover.setHoveredItem)(hoveredItemId));
        },
        clearHoveredItem: function clearHoveredItem() {
            dispatch((0, _hover.clearHoveredItem)());
        },
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        changeGradientType: function changeGradientType(gradientType) {
            dispatch((0, _fillModeGradientType.changeGradientType)(gradientType));
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.FILL));
        },
        onChangeFillColor: function onChangeFillColor(fillColor, index) {
            if (index === 0) {
                dispatch((0, _fillStyle.changeFillColor)(fillColor));
            } else if (index === 1) {
                dispatch((0, _fillStyle.changeFillColor2)(fillColor));
            }
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(FillMode);

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _hover = __webpack_require__(80);

var _math = __webpack_require__(20);

var _stylePath = __webpack_require__(9);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FillTool = function (_paper$Tool) {
    _inherits(FillTool, _paper$Tool);

    _createClass(FillTool, null, [{
        key: 'TOLERANCE',
        get: function get() {
            return 2;
        }
        /**
         * @param {function} setHoveredItem Callback to set the hovered item
         * @param {function} clearHoveredItem Callback to clear the hovered item
         * @param {!function} onUpdateImage A callback to call when the image visibly changes
         */

    }]);

    function FillTool(setHoveredItem, clearHoveredItem, onUpdateImage) {
        _classCallCheck(this, FillTool);

        var _this = _possibleConstructorReturn(this, (FillTool.__proto__ || Object.getPrototypeOf(FillTool)).call(this));

        _this.setHoveredItem = setHoveredItem;
        _this.clearHoveredItem = clearHoveredItem;
        _this.onUpdateImage = onUpdateImage;

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseMove = _this.handleMouseMove;
        _this.onMouseUp = _this.handleMouseUp;

        // Color to fill with
        _this.fillColor = null;
        _this.fillColor2 = null;
        _this.gradientType = null;

        // The path that's being hovered over.
        _this.fillItem = null;
        // The style property that we're applying the color to (either fill or stroke).
        _this.fillProperty = null;
        // If we're hovering over a hole in a compound path, we can't just recolor it. This is the
        // added item that's the same shape as the hole that's drawn over the hole when we fill a hole.
        _this.addedFillItem = null;
        _this.fillItemOrigColor = null;
        _this.prevHoveredItemId = null;
        return _this;
    }

    _createClass(FillTool, [{
        key: 'getHitOptions',
        value: function getHitOptions() {
            var isAlmostClosedPath = function isAlmostClosedPath(item) {
                return item instanceof _paper2.default.Path && item.segments.length > 2 && item.lastSegment.point.getDistance(item.firstSegment.point) < 8;
            };
            return {
                segments: false,
                stroke: true,
                curves: false,
                fill: true,
                guide: false,
                match: function match(hitResult) {
                    // Allow fills to be hit only if the item has a fill already or the path is closed/nearly closed
                    var hitFill = hitResult.item.hasFill() || hitResult.item.closed || isAlmostClosedPath(hitResult.item);
                    if (hitResult.item instanceof _paper2.default.Path && (
                    // Disallow hits that don't qualify for the fill criteria, but only if they're fills
                    hitFill || hitResult.type !== 'fill')) {
                        return true;
                    }
                    if (hitResult.item instanceof _paper2.default.PointText) {
                        return true;
                    }
                },
                hitUnfilledPaths: true,
                // If the color is transparent/none, then we need to be able to hit "invisible" outlines so that we don't
                // prevent ourselves from hitting an outline when we make it transparent via the fill preview, causing it to
                // flicker back and forth between transparent/its previous color as we hit it, then stop hitting it, etc.
                // If the color *is* visible, then don't hit "invisible" outlines, since this would add visible outlines to
                // non-outlined shapes when you hovered over where their outlines would be.
                hitUnstrokedPaths: this.gradientType === _gradientTypes2.default.SOLID && this.fillColor === null,
                tolerance: FillTool.TOLERANCE / _paper2.default.view.zoom
            };
        }
    }, {
        key: 'setFillColor',
        value: function setFillColor(fillColor) {
            this.fillColor = fillColor;
        }
    }, {
        key: 'setFillColor2',
        value: function setFillColor2(fillColor2) {
            this.fillColor2 = fillColor2;
        }
    }, {
        key: 'setGradientType',
        value: function setGradientType(gradientType) {
            this.gradientType = gradientType;
        }
        /**
         * To be called when the hovered item changes. When the select tool hovers over a
         * new item, it compares against this to see if a hover item change event needs to
         * be fired.
         * @param {paper.Item} prevHoveredItemId ID of the highlight item that indicates the mouse is
         *     over a given item currently
         */

    }, {
        key: 'setPrevHoveredItemId',
        value: function setPrevHoveredItemId(prevHoveredItemId) {
            this.prevHoveredItemId = prevHoveredItemId;
        }
    }, {
        key: 'updateFillPreview',
        value: function updateFillPreview(event) {
            var hoveredItem = (0, _hover.getHoveredItem)(event, this.getHitOptions(), true /* subselect */);
            if (!hoveredItem && this.prevHoveredItemId || // There is no longer a hovered item
            hoveredItem && !this.prevHoveredItemId || // There is now a hovered item
            hoveredItem && this.prevHoveredItemId && hoveredItem.id !== this.prevHoveredItemId) {
                // hovered item changed
                this.setHoveredItem(hoveredItem ? hoveredItem.id : null);
            }
            var hitItem = hoveredItem ? hoveredItem.data.origItem : null;
            var hitType = hoveredItem ? hoveredItem.data.hitResult.type : null;

            // The hit "target" changes if we switch items or switch between fill/outline on the same item
            var hitTargetChanged = hitItem !== this.fillItem || hitType !== this.fillProperty;

            // Still hitting the same thing
            if (!hitTargetChanged) {
                // Only radial gradient needs to be updated
                if (this.gradientType === _gradientTypes2.default.RADIAL) {
                    this._setFillItemColor(this.fillColor, this.fillColor2, this.gradientType, event.point);
                }
                return;
            }
            if (this.fillItem) {
                if (this.addedFillItem) {
                    this.addedFillItem.remove();
                    this.addedFillItem = null;
                } else {
                    this._setFillItemColor(this.fillItemOrigColor);
                }
                this.fillItemOrigColor = null;
                this.fillItem = null;
                this.fillProperty = null;
            }
            if (hitItem) {
                this.fillItem = hitItem;
                this.fillProperty = hitType;
                var colorProp = hitType === 'fill' ? 'fillColor' : 'strokeColor';
                this.fillItemOrigColor = hitItem[colorProp];
                if (hitItem.parent instanceof _paper2.default.CompoundPath && hitItem.area < 0 && hitType === 'fill') {
                    // hole
                    if (!this.fillColor) {
                        // Hole filled with transparent is no-op
                        this.fillItem = null;
                        this.fillProperty = null;
                        this.fillItemOrigColor = null;
                        return;
                    }
                    // Make an item to fill the hole
                    this.addedFillItem = hitItem.clone();
                    this.addedFillItem.setClockwise(true);
                    this.addedFillItem.data.noHover = true;
                    this.addedFillItem.data.origItem = hitItem;
                    // This usually fixes it so there isn't a teeny tiny gap in between the fill and the outline
                    // when filling in a hole
                    (0, _math.expandBy)(this.addedFillItem, .1);
                    this.addedFillItem.insertAbove(hitItem.parent);
                } else if (this.fillItem.parent instanceof _paper2.default.CompoundPath) {
                    this.fillItemOrigColor = hitItem.parent[colorProp];
                }
                this._setFillItemColor(this.fillColor, this.fillColor2, this.gradientType, event.point);
            }
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            // on touch, the user might touch-and-hold to preview what the fill tool would do
            // if they don't move their finger at all after the "mouse down" event
            // then this might be our only chance to give them a good preview
            this.updateFillPreview(event);
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            this.updateFillPreview(event);
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0) return; // only first mouse button
            if (this.fillItem) {
                // If the hole we're filling in is the same color as the parent, and parent has no outline, remove the hole
                if (this.addedFillItem && this._noStroke(this.fillItem.parent) && this.addedFillItem.fillColor.type !== 'gradient' && this.fillItem.parent.fillColor.toCSS() === this.addedFillItem.fillColor.toCSS()) {
                    this.addedFillItem.remove();
                    this.addedFillItem = null;
                    var parent = this.fillItem.parent;
                    this.fillItem.remove();
                    parent = parent.reduce();
                    parent.fillColor = this.fillColor;
                } else if (this.addedFillItem) {
                    // Fill in a hole.
                    this.addedFillItem.data.noHover = false;
                } else if (!this.fillColor && this.fillItem.data && this.fillItem.data.origItem) {
                    // Filling a hole filler with transparent returns it to being gone
                    // instead of making a shape that's transparent
                    var group = this.fillItem.parent;
                    this.fillItem.remove();
                    if (!(group instanceof _paper2.default.Layer) && group.children.length === 1) {
                        group.reduce();
                    }
                }

                this.clearHoveredItem();
                this.fillItem = null;
                this.fillProperty = null;
                this.addedFillItem = null;
                this.fillItemOrigColor = null;
                this.onUpdateImage();
            }
        }
    }, {
        key: '_noStroke',
        value: function _noStroke(item) {
            return !item.strokeColor || item.strokeColor.alpha === 0 || item.strokeWidth === 0;
        }
        // Either pass in a fully defined paper.Color as color1,
        // or pass in 2 color strings, a gradient type, and a pointer location

    }, {
        key: '_setFillItemColor',
        value: function _setFillItemColor(color1, color2, gradientType, pointerLocation) {
            var item = this._getFillItem();
            if (!item) return;
            var colorProp = this.fillProperty === 'fill' ? 'fillColor' : 'strokeColor';
            // Only create a gradient if specifically requested, else use color1 directly
            // This ensures we do not set a gradient by accident (see scratch-paint#830).
            if (gradientType && gradientType !== _gradientTypes2.default.SOLID) {
                item[colorProp] = (0, _stylePath.createGradientObject)(color1, color2, gradientType, item.bounds, pointerLocation, item.strokeWidth);
            } else {
                item[colorProp] = color1;
            }
        }
    }, {
        key: '_getFillItem',
        value: function _getFillItem() {
            if (this.addedFillItem) {
                return this.addedFillItem;
            } else if (this.fillItem && this.fillItem.parent instanceof _paper2.default.CompoundPath) {
                return this.fillItem.parent;
            }
            return this.fillItem;
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            if (this.fillItem) {
                this._setFillItemColor(this.fillItemOrigColor);
                this.fillItemOrigColor = null;
                this.fillItem = null;
                this.fillProperty = null;
            }
            this.clearHoveredItem();
            this.setHoveredItem = null;
            this.clearHoveredItem = null;
        }
    }]);

    return FillTool;
}(_paper2.default.Tool);

exports.default = FillTool;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _fill = __webpack_require__(172);

var _fill2 = _interopRequireDefault(_fill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FillModeComponent = function FillModeComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.fill,
        imgSrc: _fill2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

FillModeComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = FillModeComponent;

/***/ }),
/* 172 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 48.1 (47250) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Efill%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='fill' fill='%23575E75'%3E %3Cpath d='M14.0450969,9.69349504 L14.0306818,9.67916207 C13.4396629,9.36383682 12.5170968,8.69018743 11.4215496,7.60088203 C11.0900024,7.27122381 10.7872854,6.95589857 10.5422288,6.65490628 C10.71521,6.4399118 10.8881911,6.22491731 11.0611722,6.00992282 C11.3783043,6.26791621 11.7242666,6.58324146 12.084644,6.9415656 C12.3152855,7.17089305 12.5026817,7.37155458 12.690078,7.5722161 C12.7189081,7.61521499 12.7621534,7.65821389 12.8198138,7.70121279 C13.6270591,8.6185226 14.1027573,9.36383682 14.3189837,9.7938258 C14.3189837,9.80815877 14.3333988,9.82249173 14.3333988,9.8368247 C14.2469082,9.7938258 14.1460025,9.7508269 14.0450969,9.69349504 M10.5998892,10.0661521 C9.7349835,10.53914 8.91332309,10.983462 7.61596455,10.6824697 C6.17445506,10.3528115 5.4825305,9.76515987 5.19422861,9.42116869 L8.3078891,5.40793826 C8.52411553,5.83792723 8.84124762,6.28224917 9.1727948,6.69790518 C8.82683252,7.21389195 8.55294572,7.64388093 8.42320986,7.84454245 C8.27905891,8.08820287 8.35113439,8.41786108 8.6106061,8.5755237 C8.69709667,8.63285557 8.79800233,8.6615215 8.8844929,8.6615215 C9.07188913,8.6615215 9.24487027,8.56119074 9.34577594,8.40352811 C9.50434198,8.13120176 9.69173821,7.84454245 9.89354954,7.55788313 C10.1962665,7.90187431 10.4701533,8.17420066 10.6575496,8.36052922 C11.0755873,8.77618523 11.4936251,9.14884234 11.8972477,9.47850055 C11.4215496,9.60749724 11.0035119,9.85115766 10.5998892,10.0661521 M10.2106816,5.33627343 C10.0953609,5.49393605 9.96562502,5.65159868 9.85030426,5.79492834 C9.50434198,5.33627343 9.28811556,4.96361632 9.1727948,4.70562293 C9.41785141,4.80595369 9.76381369,5.02094818 10.2106816,5.33627343 M13.5117384,4.07497244 C13.6703044,4.07497244 13.8432855,4.10363837 13.8721157,4.1753032 C14.0450969,4.49062845 13.6270591,5.49393605 13.0648704,6.3969129 L12.848644,6.18191841 C12.6180025,5.95259096 12.2287949,5.59426681 11.781927,5.20727674 C12.4450213,4.53362734 13.0504553,4.07497244 13.5117384,4.07497244 M16.5533234,12.1587652 C16.337097,11.5997795 15.9911347,11.0981257 15.587512,10.6681367 C15.5442667,10.6108049 15.4866064,10.567806 15.428946,10.5248071 C15.6740026,9.99448732 15.2703799,9.23484013 14.9244177,8.69018743 C14.6505309,8.24586549 14.2757384,7.74421169 13.8288705,7.24255788 C14.3910592,6.38257993 15.3568705,4.676957 14.8379271,3.67364939 C14.679361,3.37265711 14.3189837,3 13.5117384,3 L13.4973233,3 C12.6756629,3 11.7675119,3.65931643 10.9458515,4.51929438 C10.0232854,3.84564498 9.01422875,3.31532525 8.40879477,3.65931643 C8.35113439,3.68798236 8.27905891,3.71664829 8.23581363,3.77398015 C8.22139853,3.78831312 8.19256835,3.80264609 8.17815325,3.83131202 C8.16373816,3.84564498 8.14932306,3.85997795 8.13490797,3.88864388 L8.12049287,3.91730981 L4.12751158,9.04851158 C4.11309649,9.04851158 4.11309649,9.04851158 4.09868139,9.06284454 L3.20494551,10.2238148 L3.16170023,10.2668137 C3.11845494,10.3098126 3.08962475,10.3671444 3.07520966,10.4101433 L3.07520966,10.4244763 C2.62834171,11.3417861 4.28607763,13.1334068 5.06449275,13.92172 C5.75641731,14.6097023 7.28441737,16 8.23581363,16 C8.43762496,16 8.596191,15.9426681 8.74034195,15.8136714 L14.2613233,11.5567806 C14.2901535,11.5424476 14.3045686,11.5137817 14.3333988,11.4851158 C14.362229,11.5137817 14.3766441,11.5567806 14.3910592,11.5854465 C14.5640403,11.9294377 14.679361,12.2877619 14.6937761,12.6747519 C14.7370214,13.061742 14.7081912,13.463065 14.6505309,13.8500551 L14.6505309,13.8643881 C14.6361158,13.9790518 14.6361158,14.0793826 14.6505309,14.1940463 C14.7514365,14.8390298 15.3568705,15.2833517 15.9911347,15.1830209 C16.639814,15.0826902 17.0866819,14.4807056 16.9857762,13.8357222 C16.8992857,13.2767365 16.7839649,12.7034179 16.5533234,12.1587652' id='Fill-1'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _colorStyleProptype = __webpack_require__(28);

var _colorStyleProptype2 = _interopRequireDefault(_colorStyleProptype);

var _selection = __webpack_require__(3);

var _snapping = __webpack_require__(174);

var _guides = __webpack_require__(27);

var _stylePath = __webpack_require__(9);

var _strokeStyle = __webpack_require__(31);

var _strokeWidth = __webpack_require__(32);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _math = __webpack_require__(20);

var _lineMode = __webpack_require__(175);

var _lineMode2 = _interopRequireDefault(_lineMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LineMode = function (_React$Component) {
    _inherits(LineMode, _React$Component);

    _createClass(LineMode, null, [{
        key: 'SNAP_TOLERANCE',
        get: function get() {
            return 6;
        }
    }, {
        key: 'DEFAULT_COLOR',
        get: function get() {
            return '#000000';
        }
    }]);

    function LineMode(props) {
        _classCallCheck(this, LineMode);

        var _this = _possibleConstructorReturn(this, (LineMode.__proto__ || Object.getPrototypeOf(LineMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool', 'drawHitPoint', 'onMouseDown', 'onMouseMove', 'onMouseDrag', 'onMouseUp']);
        return _this;
    }

    _createClass(LineMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isLineModeActive) {
                this.activateTool();
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.isLineModeActive && !this.props.isLineModeActive) {
                this.activateTool();
            } else if (!nextProps.isLineModeActive && this.props.isLineModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isLineModeActive !== this.props.isLineModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            (0, _selection.clearSelection)(this.props.clearSelectedItems);
            // Force the default line color if stroke is MIXED or transparent
            var strokeColor1 = this.props.colorState.strokeColor.primary;
            var strokeColor2 = this.props.colorState.strokeColor.secondary;
            if (strokeColor1 === _stylePath.MIXED || strokeColor1 === null && (strokeColor2 === null || strokeColor2 === _stylePath.MIXED)) {
                this.props.onChangeStrokeColor(LineMode.DEFAULT_COLOR);
            }
            if (strokeColor2 === _stylePath.MIXED) {
                this.props.clearStrokeGradient();
            }
            // Force a minimum stroke width
            if (!this.props.colorState.strokeWidth) {
                this.props.onChangeStrokeWidth(1);
            }
            this.tool = new _paper2.default.Tool();
            this.active = false;

            this.path = null;
            this.hitResult = null;

            var lineMode = this;
            this.tool.onMouseDown = function (event) {
                if (event.event.button > 0) return; // only first mouse button
                lineMode.onMouseDown(event);
            };
            this.tool.onMouseMove = function (event) {
                lineMode.onMouseMove(event);
            };
            this.tool.onMouseDrag = function (event) {
                if (event.event.button > 0) return; // only first mouse button
                lineMode.onMouseDrag(event);
            };
            this.tool.onMouseUp = function (event) {
                if (event.event.button > 0) return; // only first mouse button
                lineMode.onMouseUp(event);
            };

            this.tool.activate();
        }
    }, {
        key: 'onMouseDown',
        value: function onMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;

            // If you click near a point, continue that line instead of making a new line
            this.hitResult = (0, _snapping.endPointHit)(event.point, LineMode.SNAP_TOLERANCE);
            if (this.hitResult) {
                this.path = this.hitResult.path;
                (0, _stylePath.styleShape)(this.path, {
                    fillColor: null,
                    strokeColor: this.props.colorState.strokeColor,
                    strokeWidth: this.props.colorState.strokeWidth
                });
                if (this.hitResult.isFirst) {
                    this.path.reverse();
                }

                this.path.lastSegment.handleOut = null; // Make sure added line isn't made curvy
                this.path.add(this.hitResult.segment.point); // Add second point, which is what will move when dragged
            }

            // If not near other path, start a new path
            if (!this.path) {
                this.path = new _paper2.default.Path();
                this.path.strokeCap = 'round';
                (0, _stylePath.styleShape)(this.path, {
                    fillColor: null,
                    strokeColor: this.props.colorState.strokeColor,
                    strokeWidth: this.props.colorState.strokeWidth
                });

                this.path.add(event.point);
                this.path.add(event.point); // Add second point, which is what will move when dragged
            }
        }
    }, {
        key: 'drawHitPoint',
        value: function drawHitPoint(hitResult) {
            // If near another path's endpoint, draw hit point to indicate that paths would merge
            if (hitResult) {
                var hitPath = hitResult.path;
                if (hitResult.isFirst) {
                    (0, _guides.drawHitPoint)(hitPath.firstSegment.point);
                } else {
                    (0, _guides.drawHitPoint)(hitPath.lastSegment.point);
                }
            }
        }
    }, {
        key: 'onMouseMove',
        value: function onMouseMove(event) {
            if (this.hitResult) {
                (0, _guides.removeHitPoint)();
            }
            this.hitResult = (0, _snapping.endPointHit)(event.point, LineMode.SNAP_TOLERANCE);
            this.drawHitPoint(this.hitResult);
        }
    }, {
        key: 'onMouseDrag',
        value: function onMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            // Clear the last hit result
            if (this.hitResult) {
                (0, _guides.removeHitPoint)();
                this.hitResult = null;
            }

            // If shift is held, act like event.point always lies on a straight or 45 degree line from the last point
            var endPoint = event.point;
            if (event.modifiers.shift) {
                var line = event.point.subtract(this.path.lastSegment.previous.point);
                endPoint = this.path.lastSegment.previous.point.add((0, _math.snapDeltaToAngle)(line, Math.PI / 4));
            }

            // Find an end point that endPoint is close to (to snap lines together)
            if (this.path && !this.path.closed && this.path.segments.length > 3 && (0, _snapping.touching)(this.path.firstSegment.point, endPoint, LineMode.SNAP_TOLERANCE)) {
                this.hitResult = {
                    path: this.path,
                    segment: this.path.firstSegment,
                    isFirst: true
                };
            } else {
                this.hitResult = (0, _snapping.endPointHit)(endPoint, LineMode.SNAP_TOLERANCE, this.path);
            }

            // If shift is being held, we shouldn't snap to end points that change the slope by too much.
            // In that case, clear the hit result.
            if (this.hitResult && event.modifiers.shift) {
                var lineToSnap = this.hitResult.segment.point.subtract(this.path.lastSegment.previous.point);
                var lineToEndPoint = endPoint.subtract(this.path.lastSegment.previous.point);
                if (lineToSnap.normalize().getDistance(lineToEndPoint.normalize()) > 1e-2) {
                    this.hitResult = null;
                }
            }

            // If near another path's endpoint, or this path's beginpoint, clip to it to suggest
            // joining/closing the paths.
            if (this.hitResult) {
                this.drawHitPoint(this.hitResult);
                this.path.lastSegment.point = this.hitResult.segment.point;
            } else {
                this.path.lastSegment.point = endPoint;
            }

            (0, _stylePath.styleShape)(this.path, {
                fillColor: null,
                strokeColor: this.props.colorState.strokeColor,
                strokeWidth: this.props.colorState.strokeWidth
            });
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            // If I single clicked, don't do anything
            if (this.path.segments.length < 2 || this.path.segments.length === 2 && (0, _snapping.touching)(this.path.firstSegment.point, event.point, LineMode.SNAP_TOLERANCE) && !this.hitResult) {
                // Let lines be short if you're connecting them
                this.path.remove();
                this.path = null;
                return;
            } else if (!this.hitResult && (0, _snapping.touching)(this.path.lastSegment.point, this.path.segments[this.path.segments.length - 2].point, LineMode.SNAP_TOLERANCE)) {
                // Single click or short drag on an existing path end point
                this.path.removeSegment(this.path.segments.length - 1);
                this.path = null;
                return;
            }
            // If I intersect other line end points, join or close
            if (this.hitResult) {
                this.path.removeSegment(this.path.segments.length - 1);
                if (this.path.firstSegment.point.equals(this.hitResult.segment.point)) {
                    this.path.firstSegment.handleIn = null; // Make sure added line isn't made curvy
                    // close path
                    this.path.closed = true;
                } else {
                    // joining two paths
                    if (!this.hitResult.isFirst) {
                        this.hitResult.path.reverse();
                    }
                    this.hitResult.path.firstSegment.handleIn = null; // Make sure added line isn't made curvy
                    this.path.join(this.hitResult.path);
                }
                (0, _guides.removeHitPoint)();
                this.hitResult = null;
            }

            (0, _stylePath.styleShape)(this.path, {
                fillColor: null,
                strokeColor: this.props.colorState.strokeColor,
                strokeWidth: this.props.colorState.strokeWidth
            });

            if (this.path) {
                this.props.onUpdateImage();
                this.path = null;
            }
            this.active = false;
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.remove();
            this.tool = null;
            if (this.hitResult) {
                (0, _guides.removeHitPoint)();
                this.hitResult = null;
            }
            if (this.path) {
                this.path = null;
            }
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_lineMode2.default, {
                isSelected: this.props.isLineModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return LineMode;
}(_react2.default.Component);

LineMode.propTypes = {
    clearSelectedItems: _propTypes2.default.func.isRequired,
    clearStrokeGradient: _propTypes2.default.func.isRequired,
    colorState: _propTypes2.default.shape({
        fillColor: _colorStyleProptype2.default,
        strokeColor: _colorStyleProptype2.default,
        strokeWidth: _propTypes2.default.number
    }).isRequired,
    handleMouseDown: _propTypes2.default.func.isRequired,
    isLineModeActive: _propTypes2.default.bool.isRequired,
    onChangeStrokeColor: _propTypes2.default.func.isRequired,
    onChangeStrokeWidth: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        colorState: state.scratchPaint.color,
        isLineModeActive: state.scratchPaint.mode === _modes2.default.LINE
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        clearStrokeGradient: function clearStrokeGradient() {
            dispatch((0, _strokeStyle.clearStrokeGradient)());
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.LINE));
        },
        onChangeStrokeColor: function onChangeStrokeColor(strokeColor) {
            dispatch((0, _strokeStyle.changeStrokeColor)(strokeColor));
        },
        onChangeStrokeWidth: function onChangeStrokeWidth(strokeWidth) {
            dispatch((0, _strokeWidth.changeStrokeWidth)(strokeWidth));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(LineMode);

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.touching = exports.endPointHit = undefined;

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _selection = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {paper.Point} point1 point 1
 * @param {paper.Point} point2 point 2
 * @param {number} tolerance Distance allowed between points that are "touching"
 * @return {boolean} true if points are within the tolerance distance.
 */
var touching = function touching(point1, point2, tolerance) {
    return point1.getDistance(point2, true) < Math.pow(tolerance / _paper2.default.view.zoom, 2);
};

/**
 * @param {!paper.Point} point Point to check line endpoint hits against
 * @param {!number} tolerance Distance within which it counts as a hit
 * @param {?paper.Path} excludePath Path to exclude from hit test, if any. For instance, you
 *     are drawing a line and don't want it to snap to its own start point.
 * @return {object} data about the end point of an unclosed path, if any such point is within the
 *     tolerance distance of the given point, or null if none exists.
 */
var endPointHit = function endPointHit(point, tolerance, excludePath) {
    var lines = (0, _selection.getItems)({
        class: _paper2.default.Path
    });
    // Prefer more recent lines
    for (var i = lines.length - 1; i >= 0; i--) {
        if (lines[i].closed) {
            continue;
        }
        if (!(lines[i].parent instanceof _paper2.default.Layer)) {
            // Don't connect to lines inside of groups
            continue;
        }
        if (excludePath && lines[i] === excludePath) {
            continue;
        }
        if (lines[i].firstSegment && touching(lines[i].firstSegment.point, point, tolerance)) {
            return {
                path: lines[i],
                segment: lines[i].firstSegment,
                isFirst: true
            };
        }
        if (lines[i].lastSegment && touching(lines[i].lastSegment.point, point, tolerance)) {
            return {
                path: lines[i],
                segment: lines[i].lastSegment,
                isFirst: false
            };
        }
    }
    return null;
};

exports.endPointHit = endPointHit;
exports.touching = touching;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _line = __webpack_require__(176);

var _line2 = _interopRequireDefault(_line);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LineModeComponent = function LineModeComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.line,
        imgSrc: _line2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

LineModeComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = LineModeComponent;

/***/ }),
/* 176 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eline%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' stroke-linecap='square'%3E %3Cg id='line' stroke='%23575E75' stroke-width='2'%3E %3Cpath d='M5,15 L15,5' id='Line'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _box = __webpack_require__(71);

var _box2 = _interopRequireDefault(_box);

var _eyeDropper = __webpack_require__(81);

var _loupe = __webpack_require__(178);

var _loupe2 = _interopRequireDefault(_loupe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LoupeComponent = function (_React$Component) {
    _inherits(LoupeComponent, _React$Component);

    function LoupeComponent(props) {
        _classCallCheck(this, LoupeComponent);

        var _this = _possibleConstructorReturn(this, (LoupeComponent.__proto__ || Object.getPrototypeOf(LoupeComponent)).call(this, props));

        (0, _lodash2.default)(_this, ['setCanvas']);
        return _this;
    }

    _createClass(LoupeComponent, [{
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            this.draw();
        }
    }, {
        key: 'draw',
        value: function draw() {
            var boxSize = 5;
            var boxLineWidth = 1;
            var colorRingWidth = 15;
            var loupeRadius = _eyeDropper.ZOOM_SCALE * _eyeDropper.LOUPE_RADIUS;
            var loupeDiameter = loupeRadius * 2;

            var color = this.props.colorInfo.color;

            var ctx = this.canvas.getContext('2d');
            this.canvas.width = loupeDiameter;
            this.canvas.height = loupeDiameter;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, loupeDiameter, loupeDiameter);

            // In order to scale the image data, must draw to a tmp canvas first
            var tmpCanvas = document.createElement('canvas');
            tmpCanvas.width = loupeDiameter;
            tmpCanvas.height = loupeDiameter;
            var tmpCtx = tmpCanvas.getContext('2d');
            var imageData = tmpCtx.createImageData(loupeDiameter, loupeDiameter);

            // Since the color info comes from elsewhere there is no guarantee
            // about the size. Make sure it matches to prevent data.set from throwing.
            // See issue #966 for example of how that can happen.
            if (this.props.colorInfo.data.length === imageData.data.length) {
                imageData.data.set(this.props.colorInfo.data);
            } else {
                console.warn('Image data size mismatch drawing loupe'); // eslint-disable-line no-console
            }

            tmpCtx.putImageData(imageData, 0, 0);

            // Scale the loupe canvas and draw the zoomed image
            ctx.drawImage(tmpCanvas, 0, 0);

            // Draw an outlined square at the cursor position (cursor is hidden)
            ctx.lineWidth = boxLineWidth;
            ctx.strokeStyle = 'black';
            ctx.fillStyle = 'rgba(' + color[0] + ', ' + color[1] + ', ' + color[2] + ', ' + color[3] + ')';
            ctx.beginPath();
            ctx.rect(loupeRadius - boxSize / 2, loupeRadius - boxSize / 2, boxSize, boxSize);
            ctx.fill();
            ctx.stroke();

            // Draw a thick ring around the loupe showing the current color
            ctx.strokeStyle = 'rgba(' + color[0] + ', ' + color[1] + ', ' + color[2] + ', ' + color[3] + ')';
            ctx.lineWidth = colorRingWidth;
            ctx.beginPath();
            ctx.moveTo(loupeDiameter, loupeDiameter);
            ctx.arc(loupeRadius, loupeRadius, loupeRadius, 0, 2 * Math.PI);
            ctx.stroke();
        }
    }, {
        key: 'setCanvas',
        value: function setCanvas(element) {
            this.canvas = element;
            // Make sure to draw a frame when this component is first mounted
            // Check for null ref because refs are called with null when unmounted
            if (this.canvas) {
                this.draw();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                colorInfo = _props.colorInfo,
                pixelRatio = _props.pixelRatio,
                boxProps = _objectWithoutProperties(_props, ['colorInfo', 'pixelRatio']);

            var loupeDiameter = _eyeDropper.ZOOM_SCALE * _eyeDropper.LOUPE_RADIUS * 2;
            return _react2.default.createElement(_box2.default, _extends({}, boxProps, {
                className: _loupe2.default.eyeDropper,
                componentRef: this.setCanvas,
                element: 'canvas',
                height: _eyeDropper.LOUPE_RADIUS * 2,
                style: {
                    top: colorInfo.y / pixelRatio - loupeDiameter / 2,
                    left: colorInfo.x / pixelRatio - loupeDiameter / 2,
                    width: loupeDiameter,
                    height: loupeDiameter
                },
                width: _eyeDropper.LOUPE_RADIUS * 2
            }));
        }
    }]);

    return LoupeComponent;
}(_react2.default.Component);

LoupeComponent.propTypes = {
    colorInfo: _propTypes2.default.shape({
        color: _propTypes2.default.instanceOf(Uint8ClampedArray), // this is the [r,g,b,a] array
        x: _propTypes2.default.number,
        y: _propTypes2.default.number,
        data: _propTypes2.default.instanceOf(Uint8ClampedArray)
    }),
    pixelRatio: _propTypes2.default.number.isRequired
};

exports.default = LoupeComponent;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(179);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".loupe_eye-dropper_39EHg {\n    position: absolute;\n    border-radius: 100%;\n    border: 1px solid #222;\n}\n", ""]);
// Exports
exports.locals = {
	"eye-dropper": "loupe_eye-dropper_39EHg",
	"eyeDropper": "loupe_eye-dropper_39EHg"
};
module.exports = exports;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _fixedTools = __webpack_require__(181);

var _fixedTools2 = _interopRequireDefault(_fixedTools);

var _modes = __webpack_require__(10);

var _format = __webpack_require__(40);

var _selectedItems = __webpack_require__(7);

var _eyeDropper = __webpack_require__(39);

var _textEditTarget = __webpack_require__(44);

var _layout = __webpack_require__(56);

var _selection = __webpack_require__(3);

var _order = __webpack_require__(82);

var _group = __webpack_require__(24);

var _format2 = __webpack_require__(11);

var _format3 = _interopRequireDefault(_format2);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FixedTools = function (_React$Component) {
    _inherits(FixedTools, _React$Component);

    function FixedTools(props) {
        _classCallCheck(this, FixedTools);

        var _this = _possibleConstructorReturn(this, (FixedTools.__proto__ || Object.getPrototypeOf(FixedTools)).call(this, props));

        (0, _lodash2.default)(_this, ['handleSendBackward', 'handleSendForward', 'handleSendToBack', 'handleSendToFront', 'handleSetSelectedItems', 'handleGroup', 'handleUngroup']);
        return _this;
    }

    _createClass(FixedTools, [{
        key: 'handleGroup',
        value: function handleGroup() {
            (0, _group.groupSelection)(this.props.clearSelectedItems, this.handleSetSelectedItems, this.props.onUpdateImage);
        }
    }, {
        key: 'handleUngroup',
        value: function handleUngroup() {
            (0, _group.ungroupSelection)(this.props.clearSelectedItems, this.handleSetSelectedItems, this.props.onUpdateImage);
        }
    }, {
        key: 'handleSendBackward',
        value: function handleSendBackward() {
            (0, _order.sendBackward)(this.props.onUpdateImage);
        }
    }, {
        key: 'handleSendForward',
        value: function handleSendForward() {
            (0, _order.bringForward)(this.props.onUpdateImage);
        }
    }, {
        key: 'handleSendToBack',
        value: function handleSendToBack() {
            (0, _order.sendToBack)(this.props.onUpdateImage);
        }
    }, {
        key: 'handleSendToFront',
        value: function handleSendToFront() {
            (0, _order.bringToFront)(this.props.onUpdateImage);
        }
    }, {
        key: 'handleSetSelectedItems',
        value: function handleSetSelectedItems() {
            this.props.setSelectedItems(this.props.format);
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_fixedTools2.default, {
                canRedo: this.props.canRedo,
                canUndo: this.props.canUndo,
                name: this.props.name,
                onGroup: this.handleGroup,
                onRedo: this.props.onRedo,
                onSendBackward: this.handleSendBackward,
                onSendForward: this.handleSendForward,
                onSendToBack: this.handleSendToBack,
                onSendToFront: this.handleSendToFront,
                onUndo: this.props.onUndo,
                onUngroup: this.handleUngroup,
                onUpdateImage: this.props.onUpdateImage,
                onUpdateName: this.props.onUpdateName
            });
        }
    }]);

    return FixedTools;
}(_react2.default.Component);

FixedTools.propTypes = {
    canRedo: _propTypes2.default.func.isRequired,
    canUndo: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    format: _propTypes2.default.oneOf(Object.keys(_format3.default)),
    name: _propTypes2.default.string,
    onRedo: _propTypes2.default.func.isRequired,
    onUndo: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    onUpdateName: _propTypes2.default.func.isRequired,
    setSelectedItems: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        changeColorToEyeDropper: state.scratchPaint.color.eyeDropper.callback,
        format: state.scratchPaint.format,
        isEyeDropping: state.scratchPaint.color.eyeDropper.active,
        mode: state.scratchPaint.mode,
        pasteOffset: state.scratchPaint.clipboard.pasteOffset,
        previousTool: state.scratchPaint.color.eyeDropper.previousTool,
        selectedItems: state.scratchPaint.selectedItems,
        viewBounds: state.scratchPaint.viewBounds
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        changeMode: function changeMode(mode) {
            dispatch((0, _modes.changeMode)(mode));
        },
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        handleSwitchToBitmap: function handleSwitchToBitmap() {
            dispatch((0, _format.changeFormat)(_format3.default.BITMAP));
        },
        handleSwitchToVector: function handleSwitchToVector() {
            dispatch((0, _format.changeFormat)(_format3.default.VECTOR));
        },
        removeTextEditTarget: function removeTextEditTarget() {
            dispatch((0, _textEditTarget.setTextEditTarget)());
        },
        setLayout: function setLayout(layout) {
            dispatch((0, _layout.setLayout)(layout));
        },
        setSelectedItems: function setSelectedItems(format) {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), (0, _format2.isBitmap)(format)));
        },
        onDeactivateEyeDropper: function onDeactivateEyeDropper() {
            // set redux values to default for eye dropper reducer
            dispatch((0, _eyeDropper.deactivateEyeDropper)());
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(FixedTools);

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _reactRedux = __webpack_require__(6);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactResponsive = __webpack_require__(182);

var _reactResponsive2 = _interopRequireDefault(_reactResponsive);

var _group = __webpack_require__(24);

var _order = __webpack_require__(82);

var _bufferedInputHoc = __webpack_require__(183);

var _bufferedInputHoc2 = _interopRequireDefault(_bufferedInputHoc);

var _button = __webpack_require__(38);

var _button2 = _interopRequireDefault(_button);

var _buttonGroup = __webpack_require__(72);

var _buttonGroup2 = _interopRequireDefault(_buttonGroup);

var _dropdown = __webpack_require__(83);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _reactIntl = __webpack_require__(23);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _input = __webpack_require__(55);

var _input2 = _interopRequireDefault(_input);

var _inputGroup = __webpack_require__(33);

var _inputGroup2 = _interopRequireDefault(_inputGroup);

var _label = __webpack_require__(54);

var _label2 = _interopRequireDefault(_label);

var _labeledIconButton = __webpack_require__(53);

var _labeledIconButton2 = _interopRequireDefault(_labeledIconButton);

var _layoutConstants = __webpack_require__(189);

var _layoutConstants2 = _interopRequireDefault(_layoutConstants);

var _hideLabel = __webpack_require__(84);

var _fixedTools = __webpack_require__(190);

var _fixedTools2 = _interopRequireDefault(_fixedTools);

var _group2 = __webpack_require__(192);

var _group3 = _interopRequireDefault(_group2);

var _redo = __webpack_require__(193);

var _redo2 = _interopRequireDefault(_redo);

var _sendBack = __webpack_require__(194);

var _sendBack2 = _interopRequireDefault(_sendBack);

var _sendBackward = __webpack_require__(195);

var _sendBackward2 = _interopRequireDefault(_sendBackward);

var _sendForward = __webpack_require__(196);

var _sendForward2 = _interopRequireDefault(_sendForward);

var _sendFront = __webpack_require__(197);

var _sendFront2 = _interopRequireDefault(_sendFront);

var _undo = __webpack_require__(198);

var _undo2 = _interopRequireDefault(_undo);

var _ungroup = __webpack_require__(199);

var _ungroup2 = _interopRequireDefault(_ungroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var BufferedInput = (0, _bufferedInputHoc2.default)(_input2.default);
var messages = (0, _reactIntl.defineMessages)({
    costume: {
        'id': 'paint.paintEditor.costume',
        'defaultMessage': 'Costume'
    },
    group: {
        'id': 'paint.paintEditor.group',
        'defaultMessage': 'Group'
    },
    ungroup: {
        'id': 'paint.paintEditor.ungroup',
        'defaultMessage': 'Ungroup'
    },
    undo: {
        'id': 'paint.paintEditor.undo',
        'defaultMessage': 'Undo'
    },
    redo: {
        'id': 'paint.paintEditor.redo',
        'defaultMessage': 'Redo'
    },
    forward: {
        'id': 'paint.paintEditor.forward',
        'defaultMessage': 'Forward'
    },
    backward: {
        'id': 'paint.paintEditor.backward',
        'defaultMessage': 'Backward'
    },
    front: {
        'id': 'paint.paintEditor.front',
        'defaultMessage': 'Front'
    },
    back: {
        'id': 'paint.paintEditor.back',
        'defaultMessage': 'Back'
    },
    more: {
        'id': 'paint.paintEditor.more',
        'defaultMessage': 'More'
    }
});

var FixedToolsComponent = function FixedToolsComponent(props) {
    var redoDisabled = !props.canRedo();
    var undoDisabled = !props.canUndo();

    return _react2.default.createElement(
        'div',
        { className: _fixedTools2.default.row },
        _react2.default.createElement(
            _inputGroup2.default,
            null,
            _react2.default.createElement(
                _reactResponsive2.default,
                { minWidth: _layoutConstants2.default.fullSizeEditorMinWidth },
                _react2.default.createElement(
                    _label2.default,
                    { text: props.intl.formatMessage(messages.costume) },
                    _react2.default.createElement(BufferedInput, {
                        className: _fixedTools2.default.costumeInput,
                        type: 'text',
                        value: props.name,
                        onSubmit: props.onUpdateName
                    })
                )
            ),
            _react2.default.createElement(
                _reactResponsive2.default,
                { maxWidth: _layoutConstants2.default.fullSizeEditorMinWidth - 1 },
                _react2.default.createElement(BufferedInput, {
                    className: _fixedTools2.default.costumeInput,
                    type: 'text',
                    value: props.name,
                    onSubmit: props.onUpdateName
                })
            )
        ),
        _react2.default.createElement(
            _inputGroup2.default,
            null,
            _react2.default.createElement(
                _buttonGroup2.default,
                null,
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fixedTools2.default.buttonGroupButton, _defineProperty({}, _fixedTools2.default.modNoEndBorder, !redoDisabled)),
                        disabled: undoDisabled,
                        onClick: props.onUndo
                    },
                    _react2.default.createElement('img', {
                        alt: props.intl.formatMessage(messages.undo),
                        className: (0, _classnames2.default)(_fixedTools2.default.buttonGroupButtonIcon, _fixedTools2.default.undoIcon),
                        draggable: false,
                        src: _undo2.default
                    })
                ),
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fixedTools2.default.buttonGroupButton, _defineProperty({}, _fixedTools2.default.modStartBorder, !redoDisabled)),
                        disabled: redoDisabled,
                        onClick: props.onRedo
                    },
                    _react2.default.createElement('img', {
                        alt: props.intl.formatMessage(messages.redo),
                        className: _fixedTools2.default.buttonGroupButtonIcon,
                        draggable: false,
                        src: _redo2.default
                    })
                )
            )
        ),
        (0, _format.isVector)(props.format) ? _react2.default.createElement(
            _inputGroup2.default,
            { className: _fixedTools2.default.modDashedBorder },
            _react2.default.createElement(_labeledIconButton2.default, {
                disabled: !(0, _group.shouldShowGroup)(),
                hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                imgSrc: _group3.default,
                title: props.intl.formatMessage(messages.group),
                onClick: props.onGroup
            }),
            _react2.default.createElement(_labeledIconButton2.default, {
                disabled: !(0, _group.shouldShowUngroup)(),
                hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                imgSrc: _ungroup2.default,
                title: props.intl.formatMessage(messages.ungroup),
                onClick: props.onUngroup
            })
        ) : null,
        (0, _format.isVector)(props.format) ? _react2.default.createElement(
            _inputGroup2.default,
            { className: _fixedTools2.default.modDashedBorder },
            _react2.default.createElement(_labeledIconButton2.default, {
                disabled: !(0, _order.shouldShowBringForward)(),
                hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                imgSrc: _sendForward2.default,
                title: props.intl.formatMessage(messages.forward),
                onClick: props.onSendForward
            }),
            _react2.default.createElement(_labeledIconButton2.default, {
                disabled: !(0, _order.shouldShowSendBackward)(),
                hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                imgSrc: _sendBackward2.default,
                title: props.intl.formatMessage(messages.backward),
                onClick: props.onSendBackward
            })
        ) : null,
        (0, _format.isVector)(props.format) ? _react2.default.createElement(
            _reactResponsive2.default,
            { minWidth: _layoutConstants2.default.fullSizeEditorMinWidth },
            _react2.default.createElement(
                _inputGroup2.default,
                { className: _fixedTools2.default.row },
                _react2.default.createElement(_labeledIconButton2.default, {
                    disabled: !(0, _order.shouldShowBringForward)(),
                    hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                    imgSrc: _sendFront2.default,
                    title: props.intl.formatMessage(messages.front),
                    onClick: props.onSendToFront
                }),
                _react2.default.createElement(_labeledIconButton2.default, {
                    disabled: !(0, _order.shouldShowSendBackward)(),
                    hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                    imgSrc: _sendBack2.default,
                    title: props.intl.formatMessage(messages.back),
                    onClick: props.onSendToBack
                })
            )
        ) : null,
        (0, _format.isVector)(props.format) ? _react2.default.createElement(
            _reactResponsive2.default,
            { maxWidth: _layoutConstants2.default.fullSizeEditorMinWidth - 1 },
            _react2.default.createElement(
                _inputGroup2.default,
                null,
                _react2.default.createElement(
                    _dropdown2.default,
                    {
                        className: _fixedTools2.default.modUnselect,
                        enterExitTransitionDurationMs: 20,
                        popoverContent: _react2.default.createElement(
                            _inputGroup2.default,
                            {
                                className: _fixedTools2.default.modContextMenu,
                                rtl: props.rtl
                            },
                            _react2.default.createElement(
                                _button2.default,
                                {
                                    className: (0, _classnames2.default)(_fixedTools2.default.modMenuItem, _defineProperty({}, _fixedTools2.default.modDisabled, !(0, _order.shouldShowBringForward)())),
                                    disabled: !(0, _order.shouldShowBringForward)(),
                                    onClick: props.onSendToFront
                                },
                                _react2.default.createElement('img', {
                                    className: _fixedTools2.default.menuItemIcon,
                                    draggable: false,
                                    src: _sendFront2.default
                                }),
                                _react2.default.createElement(
                                    'span',
                                    null,
                                    props.intl.formatMessage(messages.front)
                                )
                            ),
                            _react2.default.createElement(
                                _button2.default,
                                {
                                    className: (0, _classnames2.default)(_fixedTools2.default.modMenuItem, _defineProperty({}, _fixedTools2.default.modDisabled, !(0, _order.shouldShowSendBackward)())),
                                    disabled: !(0, _order.shouldShowSendBackward)(),
                                    onClick: props.onSendToBack
                                },
                                _react2.default.createElement('img', {
                                    className: _fixedTools2.default.menuItemIcon,
                                    draggable: false,
                                    src: _sendBack2.default
                                }),
                                _react2.default.createElement(
                                    'span',
                                    null,
                                    props.intl.formatMessage(messages.back)
                                )
                            )
                        ),
                        tipSize: .01
                    },
                    props.intl.formatMessage(messages.more)
                )
            )
        ) : null
    );
};

FixedToolsComponent.propTypes = {
    canRedo: _propTypes2.default.func.isRequired,
    canUndo: _propTypes2.default.func.isRequired,
    format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
    intl: _reactIntl.intlShape,
    name: _propTypes2.default.string,
    onGroup: _propTypes2.default.func.isRequired,
    onRedo: _propTypes2.default.func.isRequired,
    onSendBackward: _propTypes2.default.func.isRequired,
    onSendForward: _propTypes2.default.func.isRequired,
    onSendToBack: _propTypes2.default.func.isRequired,
    onSendToFront: _propTypes2.default.func.isRequired,
    onUndo: _propTypes2.default.func.isRequired,
    onUngroup: _propTypes2.default.func.isRequired,
    onUpdateName: _propTypes2.default.func.isRequired,
    rtl: _propTypes2.default.bool.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        format: state.scratchPaint.format,
        rtl: state.scratchPaint.layout.rtl,
        selectedItems: state.scratchPaint.selectedItems,
        undoState: state.scratchPaint.undo
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps)((0, _reactIntl.injectIntl)(FixedToolsComponent));

/***/ }),
/* 182 */
/***/ (function(module, exports) {

module.exports = require("react-responsive");

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function (Input) {
    var BufferedInput = function (_React$Component) {
        _inherits(BufferedInput, _React$Component);

        function BufferedInput(props) {
            _classCallCheck(this, BufferedInput);

            var _this = _possibleConstructorReturn(this, (BufferedInput.__proto__ || Object.getPrototypeOf(BufferedInput)).call(this, props));

            (0, _lodash2.default)(_this, ['handleChange', 'handleKeyPress', 'handleFlush']);
            _this.state = {
                value: null
            };
            return _this;
        }

        _createClass(BufferedInput, [{
            key: 'handleKeyPress',
            value: function handleKeyPress(e) {
                if (e.key === 'Enter') {
                    this.handleFlush();
                    e.target.blur();
                }
            }
        }, {
            key: 'handleFlush',
            value: function handleFlush() {
                var isNumeric = typeof this.props.value === 'number';
                var validatesNumeric = isNumeric ? !isNaN(this.state.value) : true;
                if (this.state.value !== null && validatesNumeric) {
                    this.props.onSubmit(isNumeric ? Number(this.state.value) : this.state.value);
                }
                this.setState({ value: null });
            }
        }, {
            key: 'handleChange',
            value: function handleChange(e) {
                this.setState({ value: e.target.value });
            }
        }, {
            key: 'render',
            value: function render() {
                var bufferedValue = this.state.value === null ? this.props.value : this.state.value;
                return _react2.default.createElement(Input, _extends({}, this.props, {
                    value: bufferedValue,
                    onBlur: this.handleFlush,
                    onChange: this.handleChange,
                    onKeyPress: this.handleKeyPress
                }));
            }
        }]);

        return BufferedInput;
    }(_react2.default.Component);

    BufferedInput.propTypes = {
        onSubmit: _propTypes2.default.func.isRequired,
        value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])
    };

    return BufferedInput;
};

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* DO NOT EDIT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               @todo This file is copied from GUI and should be pulled out into a shared library.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               See https://github.com/LLK/scratch-paint/issues/13 */

/**
 * Higher Order Component to manage inputs that submit on blur and <enter>
 * @param {React.Component} Input text input that consumes onChange, onBlur, onKeyPress
 * @returns {React.Component} Buffered input that calls onSubmit on blur and <enter>
 */

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(185);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n.dropdown_dropdown_2cQyf {\n    border: 1px solid #E9EEF2;\n    border-radius: 5px;\n    overflow: visible;\n    min-width: 3.5rem;\n    color: #4C97FF;\n    padding: .5rem;\n}\n\n.dropdown_mod-open_1QOjG {\n    background-color: #E9EEF2;\n}\n\n.dropdown_dropdown-icon_13LnP {\n    width: .5rem;\n    height: .5rem;\n    vertical-align: middle;\n    padding-bottom: .2rem;\n}\n\n[dir=\"ltr\"] .dropdown_dropdown-icon_13LnP {\n    margin-left: .5rem;\n}\n\n[dir=\"rtl\"] .dropdown_dropdown-icon_13LnP {\n    margin-right: .5rem;\n}\n\n.dropdown_mod-caret-up_1v809 {\n    -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n            transform: rotate(180deg);\n    padding-bottom: 0;\n    padding-top: .2rem;\n}\n", ""]);
// Exports
exports.locals = {
	"dropdown": "dropdown_dropdown_2cQyf",
	"mod-open": "dropdown_mod-open_1QOjG",
	"modOpen": "dropdown_mod-open_1QOjG",
	"dropdown-icon": "dropdown_dropdown-icon_13LnP",
	"dropdownIcon": "dropdown_dropdown-icon_13LnP",
	"mod-caret-up": "dropdown_mod-caret-up_1v809",
	"modCaretUp": "dropdown_mod-caret-up_1v809"
};
module.exports = exports;


/***/ }),
/* 186 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='8px' height='5px' viewBox='0 0 8 5' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Edropdown-caret%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='dropdown-caret' fill='%234C97FF'%3E %3Cpath d='M4,5 C3.72520708,5 3.45163006,4.89695045 3.24127973,4.68965311 L0.314613572,1.80666227 C-0.104871191,1.39326583 -0.104871191,0.724642023 0.314613572,0.310047331 C0.732882438,-0.10334911 7.26711756,-0.10334911 7.68538643,0.310047331 C8.10487119,0.723443772 8.10487119,1.39326583 7.68538643,1.80666227 L4.75993617,4.68965311 C4.54958583,4.89695045 4.27600882,5 4,5'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(188);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* NOTE:\nEdited to add input-range-small\n*/\n\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n.input_input-form_l9eYg {\n    height: 2rem;\n    padding: 0 0.75rem;\n\n    font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    font-size: 0.75rem;\n    font-weight: bold;\n    color: #575e75;\n\n    border-width: 1px;\n    border-style: solid;\n    border-color: #E9EEF2;\n    border-radius: 2rem;\n\n    outline: none;\n    cursor: text;\n    -webkit-transition: 0.25s ease-out;\n    -o-transition: 0.25s ease-out;\n    transition: 0.25s ease-out; /* @todo: standardize with var */\n    -webkit-box-shadow: none;\n            box-shadow: none;\n\n    /*\n        For truncating overflowing text gracefully\n        Min-width is for a bug: https://css-tricks.com/flexbox-truncated-text\n        @todo: move this out into a mixin or a helper component\n    */\n    overflow: hidden;\n    -o-text-overflow: ellipsis;\n       text-overflow: ellipsis;\n    white-space: nowrap;\n    min-width: 0;\n}\n\n.input_input-form_l9eYg:focus {\n    border-color: #4C97FF;\n    -webkit-box-shadow: 0 0 0 .25rem hsla(215, 100%, 65%, 0.20);\n            box-shadow: 0 0 0 .25rem hsla(215, 100%, 65%, 0.20);\n}\n\n.input_input-small_2qj1C {\n    width: 3rem;\n    text-align: center;\n}\n\n.input_input-small-range_2GQzZ {\n    width: 4rem;\n    text-align: center;\n}\n", ""]);
// Exports
exports.locals = {
	"input-form": "input_input-form_l9eYg",
	"inputForm": "input_input-form_l9eYg",
	"input-small": "input_input-small_2qj1C",
	"inputSmall": "input_input-small_2qj1C",
	"input-small-range": "input_input-small-range_2GQzZ",
	"inputSmallRange": "input_input-small-range_2GQzZ"
};
module.exports = exports;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    fullSizeEditorMinWidth: 1274
};

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(191);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n.fixed-tools_row_2PVw6 {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n        -ms-flex-direction: row;\n            flex-direction: row;\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n\n.fixed-tools_costume-input_3ax5t {\n    width: 8rem;\n}\n\n[dir=\"ltr\"] .fixed-tools_mod-dashed-border_1AyX1 {\n    border-right: 1px dashed #D9D9D9;\n    padding-right: calc(2 * .25rem);\n}\n\n[dir=\"rtl\"] .fixed-tools_mod-dashed-border_1AyX1 {\n    border-left: 1px dashed #D9D9D9;\n    padding-left: calc(2 * .25rem);\n}\n\n.fixed-tools_mod-unselect_1Xf-j {\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n\n.fixed-tools_button-group-button_2DTEM {\n    display: inline-block;\n    border: 1px solid #D9D9D9;\n    border-radius: 0;\n    padding: .35rem;\n}\n\n[dir=\"ltr\"] .fixed-tools_button-group-button_2DTEM {\n    border-left: none;\n}\n\n[dir=\"rtl\"] .fixed-tools_button-group-button_2DTEM {\n    border-right: none;\n}\n\n[dir=\"ltr\"] .fixed-tools_button-group-button_2DTEM:last-of-type {\n    border-top-right-radius: 0.25rem;\n    border-bottom-right-radius: 0.25rem;\n}\n\n[dir=\"ltr\"] .fixed-tools_button-group-button_2DTEM:first-of-type {\n    border-left: 1px solid #D9D9D9;\n    border-top-left-radius: 0.25rem;\n    border-bottom-left-radius: 0.25rem;\n}\n\n[dir=\"rtl\"] .fixed-tools_button-group-button_2DTEM:last-of-type {\n    border-top-left-radius: 0.25rem;\n    border-bottom-left-radius: 0.25rem;\n}\n\n[dir=\"rtl\"] .fixed-tools_button-group-button_2DTEM:first-of-type {\n    border-right: 1px solid #D9D9D9;\n    border-top-right-radius: 0.25rem;\n    border-bottom-right-radius: 0.25rem;\n}\n\n[dir=\"ltr\"] .fixed-tools_button-group-button_2DTEM.fixed-tools_mod-start-border_1OTDn {\n    border-left: 1px solid #D9D9D9;\n}\n\n[dir=\"rtl\"] .fixed-tools_button-group-button_2DTEM.fixed-tools_mod-start-border_1OTDn {\n    border-right: 1px solid #D9D9D9;\n}\n\n[dir=\"ltr\"] .fixed-tools_button-group-button_2DTEM.fixed-tools_mod-no-end-border_20uuv {\n    border-right: none;\n}\n\n[dir=\"rtl\"] .fixed-tools_button-group-button_2DTEM.fixed-tools_mod-no-end-border_20uuv {\n    border-left: none;\n}\n\n.fixed-tools_button-group-button-icon_3shFH {\n    width: 1.25rem;\n    height: 1.25rem;\n    vertical-align: middle;\n}\n\n[dir=\"rtl\"] .fixed-tools_button-group-button-icon_3shFH {\n    -webkit-transform: scaleX(-1);\n        -ms-transform: scaleX(-1);\n            transform: scaleX(-1);\n}\n\n.fixed-tools_mod-context-menu_JvI5y {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n        -ms-flex-direction: column;\n            flex-direction: column;\n}\n\n.fixed-tools_mod-top-divider_oxfsG {\n    border-top: 1px solid #D9D9D9;\n}\n\n.fixed-tools_mod-menu-item_1eQQZ {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    margin: 0 -.25rem;\n    min-width: 6.25rem;\n    padding: calc(3 * .25rem);\n    white-space: nowrap;\n    cursor: pointer;\n    -webkit-transition: 0.1s ease;\n    -o-transition: 0.1s ease;\n    transition: 0.1s ease;\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n    font-family: \"Helvetica Neue\", Helvetica, sans-serif;\n}\n\n.fixed-tools_mod-disabled_UJyp0 {\n    cursor: auto;\n}\n\n.fixed-tools_mod-menu-item_1eQQZ:hover {\n    background: hsla(215, 100%, 65%, 0.20);\n}\n\n.fixed-tools_mod-disabled_UJyp0:hover {\n    background-color: transparent;\n}\n\n.fixed-tools_menu-item-icon_2DtJ1 {\n    margin-right: calc(2 * .25rem);\n}\n\n[dir=\"rtl\"] .fixed-tools_menu-item-icon_2DtJ1 {\n    margin-right: 0;\n    margin-left: calc(2 * .25rem);\n}\n", ""]);
// Exports
exports.locals = {
	"row": "fixed-tools_row_2PVw6",
	"costume-input": "fixed-tools_costume-input_3ax5t",
	"costumeInput": "fixed-tools_costume-input_3ax5t",
	"mod-dashed-border": "fixed-tools_mod-dashed-border_1AyX1",
	"modDashedBorder": "fixed-tools_mod-dashed-border_1AyX1",
	"mod-unselect": "fixed-tools_mod-unselect_1Xf-j",
	"modUnselect": "fixed-tools_mod-unselect_1Xf-j",
	"button-group-button": "fixed-tools_button-group-button_2DTEM",
	"buttonGroupButton": "fixed-tools_button-group-button_2DTEM",
	"mod-start-border": "fixed-tools_mod-start-border_1OTDn",
	"modStartBorder": "fixed-tools_mod-start-border_1OTDn",
	"mod-no-end-border": "fixed-tools_mod-no-end-border_20uuv",
	"modNoEndBorder": "fixed-tools_mod-no-end-border_20uuv",
	"button-group-button-icon": "fixed-tools_button-group-button-icon_3shFH",
	"buttonGroupButtonIcon": "fixed-tools_button-group-button-icon_3shFH",
	"mod-context-menu": "fixed-tools_mod-context-menu_JvI5y",
	"modContextMenu": "fixed-tools_mod-context-menu_JvI5y",
	"mod-top-divider": "fixed-tools_mod-top-divider_oxfsG",
	"modTopDivider": "fixed-tools_mod-top-divider_oxfsG",
	"mod-menu-item": "fixed-tools_mod-menu-item_1eQQZ",
	"modMenuItem": "fixed-tools_mod-menu-item_1eQQZ",
	"mod-disabled": "fixed-tools_mod-disabled_UJyp0",
	"modDisabled": "fixed-tools_mod-disabled_UJyp0",
	"menu-item-icon": "fixed-tools_menu-item-icon_2DtJ1",
	"menuItemIcon": "fixed-tools_menu-item-icon_2DtJ1"
};
module.exports = exports;


/***/ }),
/* 192 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Egroup%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='group' stroke-width='0.75'%3E %3Cg id='group-icon' transform='translate(2.000000, 2.000000)'%3E %3Crect id='Rectangle-2' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='0' y='0' width='3' height='3'%3E%3C/rect%3E %3Crect id='Rectangle-2-Copy-2' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='13' y='0' width='3' height='3'%3E%3C/rect%3E %3Crect id='Rectangle-2-Copy' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='0' y='13' width='3' height='3'%3E%3C/rect%3E %3Crect id='Rectangle-2-Copy-3' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='13' y='13' width='3' height='3'%3E%3C/rect%3E %3Cpath d='M1.5,3 L1.5,13' id='Line' stroke='%234C97FF' stroke-linecap='square'%3E%3C/path%3E %3Cpath d='M14.5,3 L14.5,13' id='Line-Copy' stroke='%234C97FF' stroke-linecap='square'%3E%3C/path%3E %3Cpath d='M13,1.5 L3,1.5' id='Line-Copy-2' stroke='%234C97FF' stroke-linecap='square'%3E%3C/path%3E %3Cpath d='M13,14.5 L3,14.5' id='Line-Copy-3' stroke='%234C97FF' stroke-linecap='square'%3E%3C/path%3E %3Cg id='Group' transform='translate(8.000000, 8.000000) rotate(180.000000) translate(-8.000000, -8.000000) translate(4.000000, 4.000000)' stroke='%23575E75'%3E %3Crect id='Rectangle-3-Copy' fill='%23FFFFFF' transform='translate(5.500000, 5.500000) rotate(180.000000) translate(-5.500000, -5.500000) ' x='3' y='3' width='5' height='5' rx='0.5'%3E%3C/rect%3E %3Crect id='Rectangle-3' fill='%23575E75' transform='translate(2.500000, 2.500000) rotate(180.000000) translate(-2.500000, -2.500000) ' x='0' y='0' width='5' height='5' rx='0.5'%3E%3C/rect%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eredo%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='redo' fill='%234C97FF'%3E %3Cpath d='M17.5581635,12.7700651 L13.8403972,16.4941315 C13.5610922,16.7671364 13.1830854,16.9211391 12.7903784,16.9211391 C12.3990715,16.9211391 12.0210647,16.7671364 11.7403597,16.4941315 L8.02399342,12.7700651 C7.5969858,12.3430574 7.47098355,11.7060461 7.70198767,11.1530362 C7.93299179,10.6000263 8.46500128,10.24302 9.06701202,10.24302 L10.4040359,10.24302 C10.3690352,9.92101423 10.2780336,9.55700774 10.1240309,9.17200087 C10.07573,9.05999887 10.0260291,8.94799688 9.97002813,8.83599488 C9.89302676,8.70999263 9.90072689,8.67499201 9.79502501,8.52098926 C9.62702201,8.26898476 9.47301926,8.07998139 9.29031601,7.86297752 C8.9200094,7.4639704 8.47200141,7.12096429 7.99599292,6.86895979 C7.5129843,6.6169553 7.00897531,6.46295255 6.56096732,6.37895105 C6.11995945,6.30194968 5.71395221,6.29494955 5.47594796,6.29494955 C5.35694584,6.28794943 5.2029431,6.31594993 5.12594172,6.32295005 C5.04194022,6.32995018 4.99293935,6.3369503 4.99293935,6.3369503 C4.49593048,6.38595117 4.04792249,6.02194468 3.99892162,5.52493582 C3.95692087,5.10492832 4.20192524,4.72692158 4.57293186,4.58691908 C4.57293186,4.58691908 4.62193273,4.56591871 4.6989341,4.53791821 C4.78993573,4.50991771 4.87393723,4.46091684 5.06994072,4.40491584 C5.46194772,4.28591371 5.95895658,4.15991147 6.60996819,4.09691034 C7.25397968,4.04090934 8.03099354,4.05490959 8.85070816,4.22291259 C9.66902276,4.39791571 10.5300381,4.72692158 11.3280524,5.20293007 C11.7060591,5.44793444 12.1120663,5.73493956 12.427072,6.01494456 C12.5670745,6.11994643 12.8050787,6.35795068 12.9450812,6.5049533 C13.1060841,6.67295629 13.2530867,6.84095929 13.4007893,7.01596241 C13.9670994,7.7159749 14.3871069,8.47198839 14.6601118,9.15800062 C14.8211147,9.55000762 14.9331167,9.92101423 15.0171182,10.24302 L16.5151449,10.24302 C17.1171556,10.24302 17.6491651,10.6000263 17.8801692,11.1530362 C18.1111734,11.7060461 17.9851711,12.3430574 17.5581635,12.7700651' id='Fill-1' transform='translate(10.994247, 10.494247) rotate(-45.000000) translate(-10.994247, -10.494247) '%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 194 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Esend-back%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='send-back'%3E %3Cg transform='translate(10.000000, 10.000000) rotate(180.000000) translate(-10.000000, -10.000000) translate(2.000000, 3.000000)'%3E %3Cpath d='M12.3476736,5.92549723 L10.2407376,5.92549723 L9.33601611,12.7635981 C9.23807603,13.5476661 8.54025295,14.1003698 7.78121732,13.9846876 C7.16909181,13.8947126 6.69163391,13.3805697 6.6169546,12.7635981 L5.7122331,5.92549723 L3.65426714,5.92549723 C3.0678509,5.92549723 2.78504892,5.19284356 3.190276,4.76867564 L7.53514286,0.192803597 C7.79223558,-0.0642678658 8.20970517,-0.0642678658 8.45333113,0.192803597 L12.812889,4.76867564 C13.2168918,5.19284356 12.9230716,5.92549723 12.3476736,5.92549723' id='Fill-1' fill='%234C97FF'%3E%3C/path%3E %3Cpath d='M12,8 L16,8' id='Stroke-6' stroke='%23575E75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M12,10 L15,10' id='Stroke-6-Copy' stroke='%23575E75' opacity='0.75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M12,12 L14,12' id='Stroke-6-Copy-2' stroke='%23575E75' opacity='0.5' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M0,8 L4,8' id='Stroke-10' stroke='%23575E75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M1,10 L4,10' id='Stroke-10-Copy' stroke='%23575E75' opacity='0.75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M2,12 L4,12' id='Stroke-10-Copy-2' stroke='%23575E75' opacity='0.5' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 195 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Esend-backward%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='send-backward'%3E %3Cg id='send-forward' transform='translate(10.000000, 10.000000) rotate(180.000000) translate(-10.000000, -10.000000) translate(2.000000, 3.000000)'%3E %3Cpath d='M12.3476736,5.92549723 L10.2407376,5.92549723 L9.33601611,12.7635981 C9.23807603,13.5476661 8.54025295,14.1003698 7.78121732,13.9846876 C7.16909181,13.8947126 6.69163391,13.3805697 6.6169546,12.7635981 L5.7122331,5.92549723 L3.65426714,5.92549723 C3.0678509,5.92549723 2.78504892,5.19284356 3.190276,4.76867564 L7.53514286,0.192803597 C7.79223558,-0.0642678658 8.20970517,-0.0642678658 8.45333113,0.192803597 L12.812889,4.76867564 C13.2168918,5.19284356 12.9230716,5.92549723 12.3476736,5.92549723' id='Fill-1' fill='%234C97FF'%3E%3C/path%3E %3Cpath d='M12,8 L16,8' id='Stroke-6' stroke='%23575E75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M0,8 L4,8' id='Stroke-10' stroke='%23575E75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 196 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Esend-forward%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='send-forward'%3E %3Cg transform='translate(2.000000, 3.000000)'%3E %3Cpath d='M12.3476736,5.92549723 L10.2407376,5.92549723 L9.33601611,12.7635981 C9.23807603,13.5476661 8.54025295,14.1003698 7.78121732,13.9846876 C7.16909181,13.8947126 6.69163391,13.3805697 6.6169546,12.7635981 L5.7122331,5.92549723 L3.65426714,5.92549723 C3.0678509,5.92549723 2.78504892,5.19284356 3.190276,4.76867564 L7.53514286,0.192803597 C7.79223558,-0.0642678658 8.20970517,-0.0642678658 8.45333113,0.192803597 L12.812889,4.76867564 C13.2168918,5.19284356 12.9230716,5.92549723 12.3476736,5.92549723' id='Fill-1' fill='%234C97FF'%3E%3C/path%3E %3Cpath d='M12,8 L16,8' id='Stroke-6' stroke='%23575E75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M0,8 L4,8' id='Stroke-10' stroke='%23575E75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 197 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Esend-front%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='send-front'%3E %3Cg transform='translate(2.000000, 3.000000)'%3E %3Cpath d='M12.3476736,5.92549723 L10.2407376,5.92549723 L9.33601611,12.7635981 C9.23807603,13.5476661 8.54025295,14.1003698 7.78121732,13.9846876 C7.16909181,13.8947126 6.69163391,13.3805697 6.6169546,12.7635981 L5.7122331,5.92549723 L3.65426714,5.92549723 C3.0678509,5.92549723 2.78504892,5.19284356 3.190276,4.76867564 L7.53514286,0.192803597 C7.79223558,-0.0642678658 8.20970517,-0.0642678658 8.45333113,0.192803597 L12.812889,4.76867564 C13.2168918,5.19284356 12.9230716,5.92549723 12.3476736,5.92549723' id='Fill-1' fill='%234C97FF'%3E%3C/path%3E %3Cpath d='M12,8 L16,8' id='Stroke-6' stroke='%23575E75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M12,10 L15,10' id='Stroke-6-Copy' stroke='%23575E75' opacity='0.75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M12,12 L14,12' id='Stroke-6-Copy-2' stroke='%23575E75' opacity='0.5' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M0,8 L4,8' id='Stroke-10' stroke='%23575E75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M1,10 L4,10' id='Stroke-10-Copy' stroke='%23575E75' opacity='0.75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M2,12 L4,12' id='Stroke-10-Copy-2' stroke='%23575E75' opacity='0.5' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 198 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eundo%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='undo' fill='%234C97FF'%3E %3Cpath d='M15.5581635,12.7700651 L11.8403972,16.4941315 C11.5610922,16.7671364 11.1830854,16.9211391 10.7903784,16.9211391 C10.3990715,16.9211391 10.0210647,16.7671364 9.74035971,16.4941315 L6.02399342,12.7700651 C5.5969858,12.3430574 5.47098355,11.7060461 5.70198767,11.1530362 C5.93299179,10.6000263 6.46500128,10.24302 7.06701202,10.24302 L8.40403587,10.24302 C8.36903525,9.92101423 8.27803362,9.55700774 8.12403088,9.17200087 C8.07573002,9.05999887 8.02602913,8.94799688 7.97002813,8.83599488 C7.89302676,8.70999263 7.90072689,8.67499201 7.79502501,8.52098926 C7.62702201,8.26898476 7.47301926,8.07998139 7.29031601,7.86297752 C6.9200094,7.4639704 6.47200141,7.12096429 5.99599292,6.86895979 C5.5129843,6.6169553 5.00897531,6.46295255 4.56096732,6.37895105 C4.11995945,6.30194968 3.71395221,6.29494955 3.47594796,6.29494955 C3.35694584,6.28794943 3.2029431,6.31594993 3.12594172,6.32295005 C3.04194022,6.32995018 2.99293935,6.3369503 2.99293935,6.3369503 C2.49593048,6.38595117 2.04792249,6.02194468 1.99892162,5.52493582 C1.95692087,5.10492832 2.20192524,4.72692158 2.57293186,4.58691908 C2.57293186,4.58691908 2.62193273,4.56591871 2.6989341,4.53791821 C2.78993573,4.50991771 2.87393723,4.46091684 3.06994072,4.40491584 C3.46194772,4.28591371 3.95895658,4.15991147 4.60996819,4.09691034 C5.25397968,4.04090934 6.03099354,4.05490959 6.85070816,4.22291259 C7.66902276,4.39791571 8.53003812,4.72692158 9.32805235,5.20293007 C9.7060591,5.44793444 10.1120663,5.73493956 10.427072,6.01494456 C10.5670745,6.11994643 10.8050787,6.35795068 10.9450812,6.5049533 C11.1060841,6.67295629 11.2530867,6.84095929 11.4007893,7.01596241 C11.9670994,7.7159749 12.3871069,8.47198839 12.6601118,9.15800062 C12.8211147,9.55000762 12.9331167,9.92101423 13.0171182,10.24302 L14.5151449,10.24302 C15.1171556,10.24302 15.6491651,10.6000263 15.8801692,11.1530362 C16.1111734,11.7060461 15.9851711,12.3430574 15.5581635,12.7700651' id='Fill-1' transform='translate(8.994247, 10.494247) scale(-1, 1) rotate(-45.000000) translate(-8.994247, -10.494247) '%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 199 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eungroup%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='ungroup' stroke-width='0.75'%3E %3Cg id='ungroup-icon' transform='translate(10.000000, 10.000000) rotate(180.000000) translate(-10.000000, -10.000000) translate(2.000000, 2.000000)'%3E %3Crect id='Rectangle-3-Copy' stroke='%23575E75' fill='%23FFFFFF' x='6.5' y='6.5' width='8' height='8' rx='0.5'%3E%3C/rect%3E %3Crect id='Rectangle-3' stroke='%23575E75' fill='%23575E75' x='1.5' y='1.5' width='8' height='8' rx='0.5'%3E%3C/rect%3E %3Crect id='Rectangle-2' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='0' y='0' width='3' height='3'%3E%3C/rect%3E %3Crect id='Rectangle-2-Copy-2' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='8' y='0' width='3' height='3'%3E%3C/rect%3E %3Crect id='Rectangle-2-Copy' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='0' y='8' width='3' height='3'%3E%3C/rect%3E %3Crect id='Rectangle-2-Copy-3' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='8' y='8' width='3' height='3'%3E%3C/rect%3E %3Crect id='Rectangle-2-Copy-4' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='13' y='5' width='3' height='3'%3E%3C/rect%3E %3Crect id='Rectangle-2-Copy-5' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='13' y='13' width='3' height='3'%3E%3C/rect%3E %3Crect id='Rectangle-2-Copy-6' stroke='%234C97FF' fill='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' x='5' y='13' width='3' height='3'%3E%3C/rect%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _copyPasteHoc = __webpack_require__(85);

var _copyPasteHoc2 = _interopRequireDefault(_copyPasteHoc);

var _modeTools = __webpack_require__(201);

var _modeTools2 = _interopRequireDefault(_modeTools);

var _selectedItems = __webpack_require__(7);

var _selection = __webpack_require__(3);

var _math = __webpack_require__(20);

var _layer = __webpack_require__(12);

var _bitmap = __webpack_require__(21);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModeTools = function (_React$Component) {
    _inherits(ModeTools, _React$Component);

    function ModeTools(props) {
        _classCallCheck(this, ModeTools);

        var _this = _possibleConstructorReturn(this, (ModeTools.__proto__ || Object.getPrototypeOf(ModeTools)).call(this, props));

        (0, _lodash2.default)(_this, ['_getSelectedUncurvedPoints', '_getSelectedUnpointedPoints', 'hasSelectedUncurvedPoints', 'hasSelectedUnpointedPoints', 'handleCurvePoints', 'handleFlipHorizontal', 'handleFlipVertical', 'handleDelete', 'handlePasteFromClipboard', 'handlePointPoints']);
        return _this;
    }

    _createClass(ModeTools, [{
        key: '_getSelectedUncurvedPoints',
        value: function _getSelectedUncurvedPoints() {
            var items = [];
            var selectedItems = (0, _selection.getSelectedLeafItems)();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = selectedItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var item = _step.value;

                    if (!item.segments) continue;
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                        for (var _iterator2 = item.segments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var seg = _step2.value;

                            if (seg.selected) {
                                var prev = seg.getPrevious();
                                var next = seg.getNext();
                                var isCurved = (!prev || seg.handleIn.length > 0) && (!next || seg.handleOut.length > 0) && (prev && next ? seg.handleOut.isColinear(seg.handleIn) : true);
                                if (!isCurved) items.push(seg);
                            }
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return items;
        }
    }, {
        key: '_getSelectedUnpointedPoints',
        value: function _getSelectedUnpointedPoints() {
            var points = [];
            var selectedItems = (0, _selection.getSelectedLeafItems)();
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = selectedItems[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var item = _step3.value;

                    if (!item.segments) continue;
                    var _iteratorNormalCompletion4 = true;
                    var _didIteratorError4 = false;
                    var _iteratorError4 = undefined;

                    try {
                        for (var _iterator4 = item.segments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                            var seg = _step4.value;

                            if (seg.selected) {
                                if (seg.handleIn.length > 0 || seg.handleOut.length > 0) {
                                    points.push(seg);
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError4 = true;
                        _iteratorError4 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                _iterator4.return();
                            }
                        } finally {
                            if (_didIteratorError4) {
                                throw _iteratorError4;
                            }
                        }
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return points;
        }
    }, {
        key: 'hasSelectedUncurvedPoints',
        value: function hasSelectedUncurvedPoints() {
            var points = this._getSelectedUncurvedPoints();
            return points.length > 0;
        }
    }, {
        key: 'hasSelectedUnpointedPoints',
        value: function hasSelectedUnpointedPoints() {
            var points = this._getSelectedUnpointedPoints();
            return points.length > 0;
        }
    }, {
        key: 'handleCurvePoints',
        value: function handleCurvePoints() {
            var changed = void 0;
            var points = this._getSelectedUncurvedPoints();
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = points[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var point = _step5.value;

                    var prev = point.getPrevious();
                    var next = point.getNext();
                    var noHandles = point.handleIn.length === 0 && point.handleOut.length === 0;
                    if (!prev && !next) {
                        continue;
                    } else if (prev && next && noHandles) {
                        // Handles are parallel to the line from prev to next
                        point.handleIn = prev.point.subtract(next.point).normalize().multiply(prev.getCurve().length * _math.HANDLE_RATIO);
                    } else if (prev && !next && point.handleIn.length === 0) {
                        // Point is end point
                        // Direction is average of normal at the point and direction to prev point, using the
                        // normal that points out from the convex side
                        // Lenth is curve length * HANDLE_RATIO
                        var convexity = prev.getCurve().getCurvatureAtTime(.5) < 0 ? -1 : 1;
                        point.handleIn = prev.getCurve().getNormalAtTime(1).multiply(convexity).add(prev.point.subtract(point.point).normalize()).normalize().multiply(prev.getCurve().length * _math.HANDLE_RATIO);
                    } else if (next && !prev && point.handleOut.length === 0) {
                        // Point is start point
                        // Direction is average of normal at the point and direction to prev point, using the
                        // normal that points out from the convex side
                        // Lenth is curve length * HANDLE_RATIO
                        var _convexity = point.getCurve().getCurvatureAtTime(.5) < 0 ? -1 : 1;
                        point.handleOut = point.getCurve().getNormalAtTime(0).multiply(_convexity).add(next.point.subtract(point.point).normalize()).normalize().multiply(point.getCurve().length * _math.HANDLE_RATIO);
                    }

                    // Point guaranteed to have a handle now. Make the second handle match the length and direction of first.
                    // This defines a curved point.
                    if (point.handleIn.length > 0 && next) {
                        point.handleOut = point.handleIn.multiply(-1);
                    } else if (point.handleOut.length > 0 && prev) {
                        point.handleIn = point.handleOut.multiply(-1);
                    }
                    changed = true;
                }
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }

            if (changed) {
                this.props.setSelectedItems(this.props.format);
                this.props.onUpdateImage();
            }
        }
    }, {
        key: 'handlePointPoints',
        value: function handlePointPoints() {
            var changed = void 0;
            var points = this._getSelectedUnpointedPoints();
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
                for (var _iterator6 = points[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                    var point = _step6.value;

                    var noHandles = point.handleIn.length === 0 && point.handleOut.length === 0;
                    if (!noHandles) {
                        point.handleIn = null;
                        point.handleOut = null;
                        changed = true;
                    }
                }
            } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                        _iterator6.return();
                    }
                } finally {
                    if (_didIteratorError6) {
                        throw _iteratorError6;
                    }
                }
            }

            if (changed) {
                this.props.setSelectedItems(this.props.format);
                this.props.onUpdateImage();
            }
        }
    }, {
        key: '_handleFlip',
        value: function _handleFlip(horizontalScale, verticalScale, selectedItems) {
            if (selectedItems.length === 0) {
                // If nothing is selected, select everything
                selectedItems = (0, _selection.getAllRootItems)();
            }
            // Record old indices
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
                for (var _iterator7 = selectedItems[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    var item = _step7.value;

                    item.data.index = item.index;
                }

                // Group items so that they flip as a unit
            } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
                        _iterator7.return();
                    }
                } finally {
                    if (_didIteratorError7) {
                        throw _iteratorError7;
                    }
                }
            }

            var itemGroup = new _paper2.default.Group(selectedItems);
            // Flip
            itemGroup.scale(horizontalScale, verticalScale);
            (0, _math.ensureClockwise)(itemGroup);

            // Remove flipped item from group and insert at old index. Must insert from bottom index up.
            for (var i = 0; i < selectedItems.length; i++) {
                itemGroup.layer.insertChild(selectedItems[i].data.index, selectedItems[i]);
                selectedItems[i].data.index = null;
            }
            itemGroup.remove();

            this.props.onUpdateImage();
        }
    }, {
        key: 'handleFlipHorizontal',
        value: function handleFlipHorizontal() {
            var selectedItems = (0, _selection.getSelectedRootItems)();
            if ((0, _format.isBitmap)(this.props.format) && selectedItems.length === 0) {
                (0, _layer.getRaster)().canvas = (0, _bitmap.flipBitmapHorizontal)((0, _layer.getRaster)().canvas);
                this.props.onUpdateImage();
            } else {
                this._handleFlip(-1, 1, selectedItems);
            }
        }
    }, {
        key: 'handleFlipVertical',
        value: function handleFlipVertical() {
            var selectedItems = (0, _selection.getSelectedRootItems)();
            if ((0, _format.isBitmap)(this.props.format) && selectedItems.length === 0) {
                (0, _layer.getRaster)().canvas = (0, _bitmap.flipBitmapVertical)((0, _layer.getRaster)().canvas);
                this.props.onUpdateImage();
            } else {
                this._handleFlip(1, -1, selectedItems);
            }
        }
    }, {
        key: 'handlePasteFromClipboard',
        value: function handlePasteFromClipboard() {
            if (this.props.onPasteFromClipboard()) {
                this.props.onUpdateImage();
            }
        }
    }, {
        key: 'handleDelete',
        value: function handleDelete() {
            if (!this.props.selectedItems.length) {
                if ((0, _format.isBitmap)(this.props.format)) {
                    (0, _bitmap.selectAllBitmap)(this.props.clearSelectedItems);
                } else if (this.props.mode === _modes2.default.RESHAPE) {
                    (0, _selection.selectAllSegments)();
                } else {
                    (0, _selection.selectAllItems)();
                }
            }
            if ((0, _selection.deleteSelection)(this.props.mode, this.props.onUpdateImage)) {
                this.props.setSelectedItems(this.props.format);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_modeTools2.default, {
                hasSelectedUncurvedPoints: this.hasSelectedUncurvedPoints(),
                hasSelectedUnpointedPoints: this.hasSelectedUnpointedPoints(),
                onCopyToClipboard: this.props.onCopyToClipboard,
                onCurvePoints: this.handleCurvePoints,
                onDelete: this.handleDelete,
                onFlipHorizontal: this.handleFlipHorizontal,
                onFlipVertical: this.handleFlipVertical,
                onPasteFromClipboard: this.handlePasteFromClipboard,
                onPointPoints: this.handlePointPoints,
                onUpdateImage: this.props.onUpdateImage
            });
        }
    }]);

    return ModeTools;
}(_react2.default.Component);

ModeTools.propTypes = {
    clearSelectedItems: _propTypes2.default.func.isRequired,
    format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
    mode: _propTypes2.default.oneOf(Object.keys(_modes2.default)),
    onCopyToClipboard: _propTypes2.default.func.isRequired,
    onPasteFromClipboard: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    // Listen on selected items to update hasSelectedPoints
    selectedItems: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_paper2.default.Item)), // eslint-disable-line react/no-unused-prop-types
    setSelectedItems: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        format: state.scratchPaint.format,
        mode: state.scratchPaint.mode,
        selectedItems: state.scratchPaint.selectedItems
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        setSelectedItems: function setSelectedItems(format) {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), (0, _format.isBitmap)(format)));
        }
    };
};

exports.default = (0, _copyPasteHoc2.default)((0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(ModeTools));

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _reactRedux = __webpack_require__(6);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _brushMode = __webpack_require__(86);

var _eraserMode = __webpack_require__(51);

var _bitBrushSize = __webpack_require__(87);

var _bitEraserSize = __webpack_require__(88);

var _fillBitmapShapes = __webpack_require__(89);

var _fontDropdown = __webpack_require__(202);

var _fontDropdown2 = _interopRequireDefault(_fontDropdown);

var _liveInputHoc = __webpack_require__(91);

var _liveInputHoc2 = _interopRequireDefault(_liveInputHoc);

var _label = __webpack_require__(54);

var _label2 = _interopRequireDefault(_label);

var _reactIntl = __webpack_require__(23);

var _input = __webpack_require__(55);

var _input2 = _interopRequireDefault(_input);

var _inputGroup = __webpack_require__(33);

var _inputGroup2 = _interopRequireDefault(_inputGroup);

var _labeledIconButton = __webpack_require__(53);

var _labeledIconButton2 = _interopRequireDefault(_labeledIconButton);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _hideLabel = __webpack_require__(84);

var _modeTools = __webpack_require__(205);

var _modeTools2 = _interopRequireDefault(_modeTools);

var _copy = __webpack_require__(207);

var _copy2 = _interopRequireDefault(_copy);

var _paste = __webpack_require__(208);

var _paste2 = _interopRequireDefault(_paste);

var _delete = __webpack_require__(209);

var _delete2 = _interopRequireDefault(_delete);

var _brush = __webpack_require__(63);

var _brush2 = _interopRequireDefault(_brush);

var _eraser = __webpack_require__(70);

var _eraser2 = _interopRequireDefault(_eraser);

var _line = __webpack_require__(65);

var _line2 = _interopRequireDefault(_line);

var _brush3 = __webpack_require__(74);

var _brush4 = _interopRequireDefault(_brush3);

var _curvedPoint = __webpack_require__(210);

var _curvedPoint2 = _interopRequireDefault(_curvedPoint);

var _eraser3 = __webpack_require__(75);

var _eraser4 = _interopRequireDefault(_eraser3);

var _flipHorizontal = __webpack_require__(211);

var _flipHorizontal2 = _interopRequireDefault(_flipHorizontal);

var _flipVertical = __webpack_require__(212);

var _flipVertical2 = _interopRequireDefault(_flipVertical);

var _straightPoint = __webpack_require__(213);

var _straightPoint2 = _interopRequireDefault(_straightPoint);

var _oval = __webpack_require__(68);

var _oval2 = _interopRequireDefault(_oval);

var _rectangle = __webpack_require__(69);

var _rectangle2 = _interopRequireDefault(_rectangle);

var _ovalOutlined = __webpack_require__(214);

var _ovalOutlined2 = _interopRequireDefault(_ovalOutlined);

var _rectangleOutlined = __webpack_require__(215);

var _rectangleOutlined2 = _interopRequireDefault(_rectangleOutlined);

var _strokeWidth = __webpack_require__(32);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LiveInput = (0, _liveInputHoc2.default)(_input2.default);
var ModeToolsComponent = function ModeToolsComponent(props) {
    var messages = (0, _reactIntl.defineMessages)({
        brushSize: {
            'id': 'paint.modeTools.brushSize',
            'defaultMessage': 'Size'
        },
        eraserSize: {
            'id': 'paint.modeTools.eraserSize',
            'defaultMessage': 'Eraser size'
        },
        copy: {
            'id': 'paint.modeTools.copy',
            'defaultMessage': 'Copy'
        },
        paste: {
            'id': 'paint.modeTools.paste',
            'defaultMessage': 'Paste'
        },
        delete: {
            'id': 'paint.modeTools.delete',
            'defaultMessage': 'Delete'
        },
        curved: {
            'id': 'paint.modeTools.curved',
            'defaultMessage': 'Curved'
        },
        pointed: {
            'id': 'paint.modeTools.pointed',
            'defaultMessage': 'Pointed'
        },
        thickness: {
            'id': 'paint.modeTools.thickness',
            'defaultMessage': 'Thickness'
        },
        flipHorizontal: {
            'id': 'paint.modeTools.flipHorizontal',
            'defaultMessage': 'Flip Horizontal'
        },
        flipVertical: {
            'id': 'paint.modeTools.flipVertical',
            'defaultMessage': 'Flip Vertical'
        },
        filled: {
            'id': 'paint.modeTools.filled',
            'defaultMessage': 'Filled'
        },
        outlined: {
            'id': 'paint.modeTools.outlined',
            'defaultMessage': 'Outlined'
        }
    });

    switch (props.mode) {
        case _modes2.default.BRUSH:
        /* falls through */
        case _modes2.default.BIT_BRUSH:
        /* falls through */
        case _modes2.default.BIT_LINE:
            {
                var currentIcon = (0, _format.isVector)(props.format) ? _brush4.default : props.mode === _modes2.default.BIT_LINE ? _line2.default : _brush2.default;
                var currentBrushValue = (0, _format.isBitmap)(props.format) ? props.bitBrushSize : props.brushValue;
                var changeFunction = (0, _format.isBitmap)(props.format) ? props.onBitBrushSliderChange : props.onBrushSliderChange;
                var currentMessage = props.mode === _modes2.default.BIT_LINE ? messages.thickness : messages.brushSize;
                return _react2.default.createElement(
                    'div',
                    { className: (0, _classnames2.default)(props.className, _modeTools2.default.modeTools) },
                    _react2.default.createElement(
                        'div',
                        null,
                        _react2.default.createElement('img', {
                            alt: props.intl.formatMessage(currentMessage),
                            className: _modeTools2.default.modeToolsIcon,
                            draggable: false,
                            src: currentIcon
                        })
                    ),
                    _react2.default.createElement(LiveInput, {
                        range: true,
                        small: true,
                        max: _strokeWidth.MAX_STROKE_WIDTH,
                        min: '1',
                        type: 'number',
                        value: currentBrushValue,
                        onSubmit: changeFunction
                    })
                );
            }
        case _modes2.default.BIT_ERASER:
        /* falls through */
        case _modes2.default.ERASER:
            {
                var _currentIcon = (0, _format.isVector)(props.format) ? _eraser4.default : _eraser2.default;
                var currentEraserValue = (0, _format.isBitmap)(props.format) ? props.bitEraserSize : props.eraserValue;
                var _changeFunction = (0, _format.isBitmap)(props.format) ? props.onBitEraserSliderChange : props.onEraserSliderChange;
                return _react2.default.createElement(
                    'div',
                    { className: (0, _classnames2.default)(props.className, _modeTools2.default.modeTools) },
                    _react2.default.createElement(
                        'div',
                        null,
                        _react2.default.createElement('img', {
                            alt: props.intl.formatMessage(messages.eraserSize),
                            className: _modeTools2.default.modeToolsIcon,
                            draggable: false,
                            src: _currentIcon
                        })
                    ),
                    _react2.default.createElement(LiveInput, {
                        range: true,
                        small: true,
                        max: _strokeWidth.MAX_STROKE_WIDTH,
                        min: '1',
                        type: 'number',
                        value: currentEraserValue,
                        onSubmit: _changeFunction
                    })
                );
            }
        case _modes2.default.RESHAPE:
            return _react2.default.createElement(
                'div',
                { className: (0, _classnames2.default)(props.className, _modeTools2.default.modeTools) },
                _react2.default.createElement(
                    _inputGroup2.default,
                    { className: (0, _classnames2.default)(_modeTools2.default.modDashedBorder, _modeTools2.default.modLabeledIconHeight) },
                    _react2.default.createElement(_labeledIconButton2.default, {
                        disabled: !props.hasSelectedUncurvedPoints,
                        hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                        imgSrc: _curvedPoint2.default,
                        title: props.intl.formatMessage(messages.curved),
                        onClick: props.onCurvePoints
                    }),
                    _react2.default.createElement(_labeledIconButton2.default, {
                        disabled: !props.hasSelectedUnpointedPoints,
                        hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                        imgSrc: _straightPoint2.default,
                        title: props.intl.formatMessage(messages.pointed),
                        onClick: props.onPointPoints
                    })
                ),
                _react2.default.createElement(
                    _inputGroup2.default,
                    { className: (0, _classnames2.default)(_modeTools2.default.modLabeledIconHeight) },
                    _react2.default.createElement(_labeledIconButton2.default, {
                        hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                        imgSrc: _delete2.default,
                        title: props.intl.formatMessage(messages.delete),
                        onClick: props.onDelete
                    })
                )
            );
        case _modes2.default.BIT_SELECT:
        /* falls through */
        case _modes2.default.SELECT:
            return _react2.default.createElement(
                'div',
                { className: (0, _classnames2.default)(props.className, _modeTools2.default.modeTools) },
                _react2.default.createElement(
                    _inputGroup2.default,
                    { className: (0, _classnames2.default)(_modeTools2.default.modDashedBorder, _modeTools2.default.modLabeledIconHeight) },
                    _react2.default.createElement(_labeledIconButton2.default, {
                        hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                        imgSrc: _copy2.default,
                        title: props.intl.formatMessage(messages.copy),
                        onClick: props.onCopyToClipboard
                    }),
                    _react2.default.createElement(_labeledIconButton2.default, {
                        disabled: !(props.clipboardItems.length > 0),
                        hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                        imgSrc: _paste2.default,
                        title: props.intl.formatMessage(messages.paste),
                        onClick: props.onPasteFromClipboard
                    })
                ),
                _react2.default.createElement(
                    _inputGroup2.default,
                    { className: (0, _classnames2.default)(_modeTools2.default.modDashedBorder, _modeTools2.default.modLabeledIconHeight) },
                    _react2.default.createElement(_labeledIconButton2.default, {
                        hideLabel: (0, _hideLabel.hideLabel)(props.intl.locale),
                        imgSrc: _delete2.default,
                        title: props.intl.formatMessage(messages.delete),
                        onClick: props.onDelete
                    })
                ),
                _react2.default.createElement(
                    _inputGroup2.default,
                    { className: (0, _classnames2.default)(_modeTools2.default.modLabeledIconHeight) },
                    _react2.default.createElement(_labeledIconButton2.default, {
                        hideLabel: props.intl.locale !== 'en',
                        imgSrc: _flipHorizontal2.default,
                        title: props.intl.formatMessage(messages.flipHorizontal),
                        onClick: props.onFlipHorizontal
                    }),
                    _react2.default.createElement(_labeledIconButton2.default, {
                        hideLabel: props.intl.locale !== 'en',
                        imgSrc: _flipVertical2.default,
                        title: props.intl.formatMessage(messages.flipVertical),
                        onClick: props.onFlipVertical
                    })
                )
            );
        case _modes2.default.BIT_TEXT:
        /* falls through */
        case _modes2.default.TEXT:
            return _react2.default.createElement(
                'div',
                { className: (0, _classnames2.default)(props.className, _modeTools2.default.modeTools) },
                _react2.default.createElement(
                    _inputGroup2.default,
                    null,
                    _react2.default.createElement(_fontDropdown2.default, {
                        onUpdateImage: props.onUpdateImage
                    })
                )
            );
        case _modes2.default.BIT_RECT:
        /* falls through */
        case _modes2.default.BIT_OVAL:
            {
                var fillIcon = props.mode === _modes2.default.BIT_RECT ? _rectangle2.default : _oval2.default;
                var outlineIcon = props.mode === _modes2.default.BIT_RECT ? _rectangleOutlined2.default : _ovalOutlined2.default;
                return _react2.default.createElement(
                    'div',
                    { className: (0, _classnames2.default)(props.className, _modeTools2.default.modeTools) },
                    _react2.default.createElement(
                        _inputGroup2.default,
                        null,
                        _react2.default.createElement(_labeledIconButton2.default, {
                            highlighted: props.fillBitmapShapes,
                            imgSrc: fillIcon,
                            title: props.intl.formatMessage(messages.filled),
                            onClick: props.onFillShapes
                        })
                    ),
                    _react2.default.createElement(
                        _inputGroup2.default,
                        null,
                        _react2.default.createElement(_labeledIconButton2.default, {
                            highlighted: !props.fillBitmapShapes,
                            imgSrc: outlineIcon,
                            title: props.intl.formatMessage(messages.outlined),
                            onClick: props.onOutlineShapes
                        })
                    ),
                    props.fillBitmapShapes ? null : _react2.default.createElement(
                        _inputGroup2.default,
                        null,
                        _react2.default.createElement(
                            _label2.default,
                            { text: props.intl.formatMessage(messages.thickness) },
                            _react2.default.createElement(LiveInput, {
                                range: true,
                                small: true,
                                max: _strokeWidth.MAX_STROKE_WIDTH,
                                min: '1',
                                type: 'number',
                                value: props.bitBrushSize,
                                onSubmit: props.onBitBrushSliderChange
                            })
                        )
                    )
                );
            }
        default:
            // Leave empty for now, if mode not supported
            return _react2.default.createElement('div', { className: (0, _classnames2.default)(props.className, _modeTools2.default.modeTools) });
    }
};

ModeToolsComponent.propTypes = {
    bitBrushSize: _propTypes2.default.number,
    bitEraserSize: _propTypes2.default.number,
    brushValue: _propTypes2.default.number,
    className: _propTypes2.default.string,
    clipboardItems: _propTypes2.default.arrayOf(_propTypes2.default.array),
    eraserValue: _propTypes2.default.number,
    fillBitmapShapes: _propTypes2.default.bool,
    format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
    hasSelectedUncurvedPoints: _propTypes2.default.bool,
    hasSelectedUnpointedPoints: _propTypes2.default.bool,
    intl: _reactIntl.intlShape.isRequired,
    mode: _propTypes2.default.string.isRequired,
    onBitBrushSliderChange: _propTypes2.default.func.isRequired,
    onBitEraserSliderChange: _propTypes2.default.func.isRequired,
    onBrushSliderChange: _propTypes2.default.func.isRequired,
    onCopyToClipboard: _propTypes2.default.func.isRequired,
    onCurvePoints: _propTypes2.default.func.isRequired,
    onDelete: _propTypes2.default.func.isRequired,
    onEraserSliderChange: _propTypes2.default.func,
    onFillShapes: _propTypes2.default.func.isRequired,
    onFlipHorizontal: _propTypes2.default.func.isRequired,
    onFlipVertical: _propTypes2.default.func.isRequired,
    onOutlineShapes: _propTypes2.default.func.isRequired,
    onPasteFromClipboard: _propTypes2.default.func.isRequired,
    onPointPoints: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        mode: state.scratchPaint.mode,
        format: state.scratchPaint.format,
        fillBitmapShapes: state.scratchPaint.fillBitmapShapes,
        bitBrushSize: state.scratchPaint.bitBrushSize,
        bitEraserSize: state.scratchPaint.bitEraserSize,
        brushValue: state.scratchPaint.brushMode.brushSize,
        clipboardItems: state.scratchPaint.clipboard.items,
        eraserValue: state.scratchPaint.eraserMode.brushSize
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        onBrushSliderChange: function onBrushSliderChange(brushSize) {
            dispatch((0, _brushMode.changeBrushSize)(brushSize));
        },
        onBitBrushSliderChange: function onBitBrushSliderChange(bitBrushSize) {
            dispatch((0, _bitBrushSize.changeBitBrushSize)(bitBrushSize));
        },
        onBitEraserSliderChange: function onBitEraserSliderChange(eraserSize) {
            dispatch((0, _bitEraserSize.changeBitEraserSize)(eraserSize));
        },
        onEraserSliderChange: function onEraserSliderChange(eraserSize) {
            dispatch((0, _eraserMode.changeBrushSize)(eraserSize));
        },
        onFillShapes: function onFillShapes() {
            dispatch((0, _fillBitmapShapes.setShapesFilled)(true));
        },
        onOutlineShapes: function onOutlineShapes() {
            dispatch((0, _fillBitmapShapes.setShapesFilled)(false));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)((0, _reactIntl.injectIntl)(ModeToolsComponent));

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _fontDropdown = __webpack_require__(203);

var _fontDropdown2 = _interopRequireDefault(_fontDropdown);

var _fonts = __webpack_require__(46);

var _fonts2 = _interopRequireDefault(_fonts);

var _font = __webpack_require__(57);

var _selection = __webpack_require__(3);

var _fontDropdown3 = __webpack_require__(90);

var _fontDropdown4 = _interopRequireDefault(_fontDropdown3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FontDropdown = function (_React$Component) {
    _inherits(FontDropdown, _React$Component);

    function FontDropdown(props) {
        _classCallCheck(this, FontDropdown);

        var _this = _possibleConstructorReturn(this, (FontDropdown.__proto__ || Object.getPrototypeOf(FontDropdown)).call(this, props));

        (0, _lodash2.default)(_this, ['getFontStyle', 'getFontName', 'handleChangeFontSerif', 'handleChangeFontSansSerif', 'handleChangeFontHandwriting', 'handleChangeFontMarker', 'handleChangeFontCurly', 'handleChangeFontPixel', 'handleChangeFontChinese', 'handleChangeFontJapanese', 'handleChangeFontKorean', 'handleOpenDropdown', 'handleClickOutsideDropdown', 'setDropdown', 'handleChoose']);
        return _this;
    }

    _createClass(FontDropdown, [{
        key: 'getFontStyle',
        value: function getFontStyle(font) {
            switch (font) {
                case _fonts2.default.SERIF:
                    return _fontDropdown4.default.serif;
                case _fonts2.default.SANS_SERIF:
                    return _fontDropdown4.default.sansSerif;
                case _fonts2.default.HANDWRITING:
                    return _fontDropdown4.default.handwriting;
                case _fonts2.default.MARKER:
                    return _fontDropdown4.default.marker;
                case _fonts2.default.CURLY:
                    return _fontDropdown4.default.curly;
                case _fonts2.default.PIXEL:
                    return _fontDropdown4.default.pixel;
                case _fonts2.default.CHINESE:
                    return _fontDropdown4.default.chinese;
                case _fonts2.default.JAPANESE:
                    return _fontDropdown4.default.japanese;
                case _fonts2.default.KOREAN:
                    return _fontDropdown4.default.korean;
                default:
                    return '';
            }
        }
    }, {
        key: 'getFontName',
        value: function getFontName(font) {
            switch (font) {
                case _fonts2.default.CHINESE:
                    return '中文';
                case _fonts2.default.KOREAN:
                    return '한국어';
                case _fonts2.default.JAPANESE:
                    return '日本語';
                default:
                    return font;
            }
        }
    }, {
        key: 'handleChangeFontSansSerif',
        value: function handleChangeFontSansSerif() {
            if (this.dropDown.isOpen()) {
                this.props.changeFont(_fonts2.default.SANS_SERIF);
            }
        }
    }, {
        key: 'handleChangeFontSerif',
        value: function handleChangeFontSerif() {
            if (this.dropDown.isOpen()) {
                this.props.changeFont(_fonts2.default.SERIF);
            }
        }
    }, {
        key: 'handleChangeFontHandwriting',
        value: function handleChangeFontHandwriting() {
            if (this.dropDown.isOpen()) {
                this.props.changeFont(_fonts2.default.HANDWRITING);
            }
        }
    }, {
        key: 'handleChangeFontMarker',
        value: function handleChangeFontMarker() {
            if (this.dropDown.isOpen()) {
                this.props.changeFont(_fonts2.default.MARKER);
            }
        }
    }, {
        key: 'handleChangeFontCurly',
        value: function handleChangeFontCurly() {
            if (this.dropDown.isOpen()) {
                this.props.changeFont(_fonts2.default.CURLY);
            }
        }
    }, {
        key: 'handleChangeFontPixel',
        value: function handleChangeFontPixel() {
            if (this.dropDown.isOpen()) {
                this.props.changeFont(_fonts2.default.PIXEL);
            }
        }
    }, {
        key: 'handleChangeFontChinese',
        value: function handleChangeFontChinese() {
            if (this.dropDown.isOpen()) {
                this.props.changeFont(_fonts2.default.CHINESE);
            }
        }
    }, {
        key: 'handleChangeFontJapanese',
        value: function handleChangeFontJapanese() {
            if (this.dropDown.isOpen()) {
                this.props.changeFont(_fonts2.default.JAPANESE);
            }
        }
    }, {
        key: 'handleChangeFontKorean',
        value: function handleChangeFontKorean() {
            if (this.dropDown.isOpen()) {
                this.props.changeFont(_fonts2.default.KOREAN);
            }
        }
    }, {
        key: 'handleChoose',
        value: function handleChoose() {
            if (this.dropDown.isOpen()) {
                this.dropDown.handleClosePopover();
                this.props.onUpdateImage();
            }
        }
    }, {
        key: 'handleOpenDropdown',
        value: function handleOpenDropdown() {
            this.savedFont = this.props.font;
            this.savedSelection = (0, _selection.getSelectedLeafItems)();
        }
    }, {
        key: 'handleClickOutsideDropdown',
        value: function handleClickOutsideDropdown(e) {
            e.stopPropagation();
            this.dropDown.handleClosePopover();

            // Cancel font change
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = this.savedSelection[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var item = _step.value;

                    if (item instanceof _paper2.default.PointText) {
                        item.font = this.savedFont;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.props.changeFont(this.savedFont);
            this.savedFont = null;
            this.savedSelection = null;
        }
    }, {
        key: 'setDropdown',
        value: function setDropdown(element) {
            this.dropDown = element;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_fontDropdown2.default, {
                componentRef: this.setDropdown,
                font: this.props.font,
                getFontName: this.getFontName,
                getFontStyle: this.getFontStyle,
                onChoose: this.handleChoose,
                onClickOutsideDropdown: this.handleClickOutsideDropdown,
                onHoverChinese: this.handleChangeFontChinese,
                onHoverCurly: this.handleChangeFontCurly,
                onHoverHandwriting: this.handleChangeFontHandwriting,
                onHoverJapanese: this.handleChangeFontJapanese,
                onHoverKorean: this.handleChangeFontKorean,
                onHoverMarker: this.handleChangeFontMarker,
                onHoverPixel: this.handleChangeFontPixel,
                onHoverSansSerif: this.handleChangeFontSansSerif,
                onHoverSerif: this.handleChangeFontSerif,
                onOpenDropdown: this.handleOpenDropdown
            });
        }
    }]);

    return FontDropdown;
}(_react2.default.Component);

FontDropdown.propTypes = {
    changeFont: _propTypes2.default.func.isRequired,
    font: _propTypes2.default.string,
    onUpdateImage: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        font: state.scratchPaint.font
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        changeFont: function changeFont(font) {
            dispatch((0, _font.changeFont)(font));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(FontDropdown);

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classnames = __webpack_require__(19);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _button = __webpack_require__(38);

var _button2 = _interopRequireDefault(_button);

var _dropdown = __webpack_require__(83);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _inputGroup = __webpack_require__(33);

var _inputGroup2 = _interopRequireDefault(_inputGroup);

var _fonts = __webpack_require__(46);

var _fonts2 = _interopRequireDefault(_fonts);

var _fontDropdown = __webpack_require__(90);

var _fontDropdown2 = _interopRequireDefault(_fontDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ModeToolsComponent = function ModeToolsComponent(props) {
    return _react2.default.createElement(
        _dropdown2.default,
        {
            className: (0, _classnames2.default)(_fontDropdown2.default.modUnselect, _fontDropdown2.default.fontDropdown),
            enterExitTransitionDurationMs: 60,
            popoverContent: _react2.default.createElement(
                _inputGroup2.default,
                { className: _fontDropdown2.default.modContextMenu },
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fontDropdown2.default.modMenuItem),
                        onClick: props.onChoose,
                        onMouseOver: props.onHoverSansSerif
                    },
                    _react2.default.createElement(
                        'span',
                        { className: _fontDropdown2.default.sansSerif },
                        props.getFontName(_fonts2.default.SANS_SERIF)
                    )
                ),
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fontDropdown2.default.modMenuItem),
                        onClick: props.onChoose,
                        onMouseOver: props.onHoverSerif
                    },
                    _react2.default.createElement(
                        'span',
                        { className: _fontDropdown2.default.serif },
                        props.getFontName(_fonts2.default.SERIF)
                    )
                ),
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fontDropdown2.default.modMenuItem),
                        onClick: props.onChoose,
                        onMouseOver: props.onHoverHandwriting
                    },
                    _react2.default.createElement(
                        'span',
                        { className: _fontDropdown2.default.handwriting },
                        props.getFontName(_fonts2.default.HANDWRITING)
                    )
                ),
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fontDropdown2.default.modMenuItem),
                        onClick: props.onChoose,
                        onMouseOver: props.onHoverMarker
                    },
                    _react2.default.createElement(
                        'span',
                        { className: _fontDropdown2.default.marker },
                        props.getFontName(_fonts2.default.MARKER)
                    )
                ),
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fontDropdown2.default.modMenuItem),
                        onClick: props.onChoose,
                        onMouseOver: props.onHoverCurly
                    },
                    _react2.default.createElement(
                        'span',
                        { className: _fontDropdown2.default.curly },
                        props.getFontName(_fonts2.default.CURLY)
                    )
                ),
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fontDropdown2.default.modMenuItem),
                        onClick: props.onChoose,
                        onMouseOver: props.onHoverPixel
                    },
                    _react2.default.createElement(
                        'span',
                        { className: _fontDropdown2.default.pixel },
                        props.getFontName(_fonts2.default.PIXEL)
                    )
                ),
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fontDropdown2.default.modMenuItem),
                        onClick: props.onChoose,
                        onMouseOver: props.onHoverChinese
                    },
                    _react2.default.createElement(
                        'span',
                        { className: _fontDropdown2.default.chinese },
                        props.getFontName(_fonts2.default.CHINESE)
                    )
                ),
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fontDropdown2.default.modMenuItem),
                        onClick: props.onChoose,
                        onMouseOver: props.onHoverJapanese
                    },
                    _react2.default.createElement(
                        'span',
                        { className: _fontDropdown2.default.japanese },
                        props.getFontName(_fonts2.default.JAPANESE)
                    )
                ),
                _react2.default.createElement(
                    _button2.default,
                    {
                        className: (0, _classnames2.default)(_fontDropdown2.default.modMenuItem),
                        onClick: props.onChoose,
                        onMouseOver: props.onHoverKorean
                    },
                    _react2.default.createElement(
                        'span',
                        { className: _fontDropdown2.default.korean },
                        props.getFontName(_fonts2.default.KOREAN)
                    )
                )
            ),
            ref: props.componentRef,
            tipSize: .01,
            onOpen: props.onOpenDropdown,
            onOuterAction: props.onClickOutsideDropdown
        },
        _react2.default.createElement(
            'span',
            { className: (0, _classnames2.default)(props.getFontStyle(props.font), _fontDropdown2.default.displayedFontName) },
            props.getFontName(props.font)
        )
    );
};

ModeToolsComponent.propTypes = {
    componentRef: _propTypes2.default.func.isRequired,
    font: _propTypes2.default.string,
    getFontName: _propTypes2.default.func.isRequired,
    getFontStyle: _propTypes2.default.func.isRequired,
    onChoose: _propTypes2.default.func.isRequired,
    onClickOutsideDropdown: _propTypes2.default.func,
    onHoverChinese: _propTypes2.default.func,
    onHoverCurly: _propTypes2.default.func,
    onHoverHandwriting: _propTypes2.default.func,
    onHoverJapanese: _propTypes2.default.func,
    onHoverKorean: _propTypes2.default.func,
    onHoverMarker: _propTypes2.default.func,
    onHoverPixel: _propTypes2.default.func,
    onHoverSansSerif: _propTypes2.default.func,
    onHoverSerif: _propTypes2.default.func,
    onOpenDropdown: _propTypes2.default.func
};
exports.default = ModeToolsComponent;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n.font-dropdown_mod-menu-item_hwOca {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    margin: 0 -.25rem;\n    min-width: 6.25rem;\n    padding: calc(2 * .25rem);\n    padding-left: calc(3 * .25rem);\n    padding-right: calc(3 * .25rem);\n    white-space: nowrap;\n    width: 8.5rem;\n    cursor: pointer;\n    -webkit-transition: 0.1s ease;\n    -o-transition: 0.1s ease;\n    transition: 0.1s ease;\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n\n.font-dropdown_mod-menu-item_hwOca:hover {\n    background: #4C97FF;\n    color: white;\n}\n\n.font-dropdown_mod-context-menu_3llFm {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n        -ms-flex-direction: column;\n            flex-direction: column;\n}\n\n.font-dropdown_mod-unselect_130OF {\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n\n.font-dropdown_displayed-font-name_3cU-U {\n    font-size: .8rem;\n}\n\n.font-dropdown_font-dropdown_3vjc6 {\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n    color: #575e75;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    font-size: 1rem;\n    -webkit-box-pack: justify;\n    -webkit-justify-content: space-between;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n    width: 8.5rem;\n    height: 2rem;\n}\n\n.font-dropdown_serif_tMSQM {\n    font-family: 'Serif';\n}\n\n.font-dropdown_sans-serif_24kX9 {\n    font-family: 'Sans Serif';\n}\n\n.font-dropdown_serif_tMSQM {\n    font-family: 'Serif';\n}\n\n.font-dropdown_handwriting_Y7s5d {\n    font-family: 'Handwriting';\n}\n\n.font-dropdown_marker_3AmLD {\n    font-family: 'Marker';\n}\n\n.font-dropdown_curly_1UQYh {\n    font-family: 'Curly';\n}\n\n.font-dropdown_pixel_3aRC6 {\n    font-family: 'Pixel';\n}\n\n.font-dropdown_chinese_zV1Hj {\n    font-family: \"Microsoft YaHei\", \"微软雅黑\", STXihei, \"华文细黑\";\n}\n\n.font-dropdown_japanese_2SlYs {\n    font-family: \"ヒラギノ角ゴ Pro W3\", \"Hiragino Kaku Gothic Pro\", Osaka, \"メイリオ\", Meiryo, \"ＭＳ Ｐゴシック\", \"MS PGothic\";\n}\n\n.font-dropdown_korean_1Fx37 {\n    font-family: \"Malgun Gothic\";\n}\n", ""]);
// Exports
exports.locals = {
	"mod-menu-item": "font-dropdown_mod-menu-item_hwOca",
	"modMenuItem": "font-dropdown_mod-menu-item_hwOca",
	"mod-context-menu": "font-dropdown_mod-context-menu_3llFm",
	"modContextMenu": "font-dropdown_mod-context-menu_3llFm",
	"mod-unselect": "font-dropdown_mod-unselect_130OF",
	"modUnselect": "font-dropdown_mod-unselect_130OF",
	"displayed-font-name": "font-dropdown_displayed-font-name_3cU-U",
	"displayedFontName": "font-dropdown_displayed-font-name_3cU-U",
	"font-dropdown": "font-dropdown_font-dropdown_3vjc6",
	"fontDropdown": "font-dropdown_font-dropdown_3vjc6",
	"serif": "font-dropdown_serif_tMSQM",
	"sans-serif": "font-dropdown_sans-serif_24kX9",
	"sansSerif": "font-dropdown_sans-serif_24kX9",
	"handwriting": "font-dropdown_handwriting_Y7s5d",
	"marker": "font-dropdown_marker_3AmLD",
	"curly": "font-dropdown_curly_1UQYh",
	"pixel": "font-dropdown_pixel_3aRC6",
	"chinese": "font-dropdown_chinese_zV1Hj",
	"japanese": "font-dropdown_japanese_2SlYs",
	"korean": "font-dropdown_korean_1Fx37"
};
module.exports = exports;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(206);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n.mode-tools_mode-tools_UREem {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    min-height: 3rem;\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n\n.mode-tools_mode-tools-icon_3yoZ2 {\n    margin-right: calc(2 * .25rem);\n    width: 2rem;\n    height: 2rem;\n}\n\n[dir=\"ltr\"] .mode-tools_mod-dashed-border_3Bmy_ {\n    border-right: 1px dashed #D9D9D9;\n    padding-right: calc(3 * .25rem);\n}\n\n[dir=\"rtl\"] .mode-tools_mod-dashed-border_3Bmy_ {\n    border-left: 1px dashed #D9D9D9;\n    padding-left: calc(3 * .25rem);\n}\n\n.mode-tools_mod-labeled-icon-height_kRA3W {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    height: 2.85rem; /* for the second row so the dashed borders are equal in size */\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n", ""]);
// Exports
exports.locals = {
	"mode-tools": "mode-tools_mode-tools_UREem",
	"modeTools": "mode-tools_mode-tools_UREem",
	"mode-tools-icon": "mode-tools_mode-tools-icon_3yoZ2",
	"modeToolsIcon": "mode-tools_mode-tools-icon_3yoZ2",
	"mod-dashed-border": "mode-tools_mod-dashed-border_3Bmy_",
	"modDashedBorder": "mode-tools_mod-dashed-border_3Bmy_",
	"mod-labeled-icon-height": "mode-tools_mod-labeled-icon-height_kRA3W",
	"modLabeledIconHeight": "mode-tools_mod-labeled-icon-height_kRA3W"
};
module.exports = exports;


/***/ }),
/* 207 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 48.2 (47327) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Ecopy v2%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='copy-v2'%3E %3Cg id='copy' transform='translate(3.000000, 2.000000)'%3E %3Cpolyline id='Path-3' stroke-opacity='0.5' stroke='%23575E75' stroke-linecap='round' stroke-linejoin='round' stroke-dasharray='1,2' points='0.503173828 3 0.503173828 15.5 13 15.5'%3E%3C/polyline%3E %3Cpath d='M2,1.00684547 C2,0.450780073 2.45303631,0 2.99703014,0 L10,0 L10,2.34995317 C10,3.26124887 10.7336617,4 11.6500468,4 L14,4 L14,13.0046024 C14,13.5543453 13.544239,14 12.9975267,14 L3.00247329,14 C2.44882258,14 2,13.5500512 2,12.9931545 L2,1.00684547 Z' id='Rectangle-4' fill='%234C97FF'%3E%3C/path%3E %3Cpath d='M11,0 L14,3 L11.9989566,3 C11.4472481,3 11,2.55733967 11,2.00104344 L11,0 Z' id='Rectangle-5' fill='%234C97FF'%3E%3C/path%3E %3Cpath d='M9.8115942,9.1884058 L8.6884058,9.1884058 L8.6884058,10.3115942 C8.6884058,10.6859903 8.38647343,11 8,11 C7.61352657,11 7.3115942,10.6859903 7.3115942,10.3115942 L7.3115942,9.1884058 L6.1884058,9.1884058 C5.81400966,9.1884058 5.5,8.88647343 5.5,8.5 C5.5,8.11352657 5.81400966,7.8115942 6.1884058,7.8115942 L7.3115942,7.8115942 L7.3115942,6.6884058 C7.3115942,6.31280193 7.61352657,6 8,6 C8.38647343,6 8.6884058,6.31280193 8.6884058,6.6884058 L8.6884058,7.8115942 L9.8115942,7.8115942 C10.1859903,7.8115942 10.5,8.11352657 10.5,8.5 C10.5,8.88647343 10.1859903,9.1884058 9.8115942,9.1884058 Z' id='Fill-1' stroke='%23FFFFFF' stroke-width='0.25' fill='%23FFFFFF'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 208 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 48.2 (47327) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Epaste v2%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='paste-v2'%3E %3Cg id='paste' transform='translate(3.000000, 2.000000)'%3E %3Cpolyline id='Path-3' stroke-opacity='0.5' stroke='%23575E75' stroke-linecap='round' stroke-linejoin='round' stroke-dasharray='1,2' transform='translate(6.748413, 6.750000) scale(1, -1) translate(-6.748413, -6.750000) ' points='0.5 0.5 0.5 13 12.9968262 13'%3E%3C/polyline%3E %3Cpath d='M2,3.00684547 C2,2.45078007 2.45303631,2 2.99703014,2 L10,2 L10,4.34995317 C10,5.26124887 10.7336617,6 11.6500468,6 L14,6 L14,15.0046024 C14,15.5543453 13.544239,16 12.9975267,16 L3.00247329,16 C2.44882258,16 2,15.5500512 2,14.9931545 L2,3.00684547 Z' id='Rectangle-4' fill='%234C97FF'%3E%3C/path%3E %3Cpath d='M11,2 L14,5 L11.9989566,5 C11.4472481,5 11,4.55733967 11,4.00104344 L11,2 Z' id='Rectangle-5' fill='%234C97FF'%3E%3C/path%3E %3Cpath d='M8.34791833,12.8771885 C8.26180668,12.9633001 8.14699113,13.0063559 8.03217559,13.0063559 C7.9030081,13.0063559 7.78819256,12.9633001 7.70208091,12.8771885 L5.86503222,11.0401398 C5.73586474,10.8966203 5.69280891,10.7100451 5.76456862,10.5378218 C5.83632834,10.3655985 5.99419971,10.2651349 6.18077497,10.2651349 L6.92707599,10.2651349 L7.28587456,7.66743321 C7.31457845,7.46650601 7.41504205,7.27993075 7.57291342,7.16511521 C7.73078479,7.03594773 7.94606393,6.97853995 8.13263919,7.00724384 C8.47708582,7.06321642 8.74977273,7.33733852 8.79282856,7.66743321 L9.16597907,10.2651349 L9.86922427,10.2651349 C10.0557995,10.2651349 10.2136709,10.3799504 10.2854306,10.5521737 C10.3571903,10.7100451 10.3141345,10.9109723 10.184967,11.0401398 L8.34791833,12.8771885 Z' id='Fill-1' fill='%23FFFFFF'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 209 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 50.2 (55047) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Edelete%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='delete' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='Delete-Icon' transform='translate(2.000000, 1.500000)' fill='%234C97FF' fill-rule='nonzero'%3E %3Cpath d='M2,3.25 L14,3.25 C14.4437164,3.25 14.7904293,3.63311343 14.7462779,4.07462779 L13.6363275,15.1741315 C13.5468672,16.0687347 12.7940775,16.75 11.8950124,16.75 L4.10498756,16.75 C3.20592253,16.75 2.45313279,16.0687347 2.36367248,15.1741315 L1.25372211,4.07462779 C1.20957067,3.63311343 1.55628356,3.25 2,3.25 Z M8.75,12 L8.75,7 C8.75,6.58578644 8.41421356,6.25 8,6.25 C7.58578644,6.25 7.25,6.58578644 7.25,7 L7.25,12 C7.25,12.4142136 7.58578644,12.75 8,12.75 C8.41421356,12.75 8.75,12.4142136 8.75,12 Z M11.25,12 L11.25,7 C11.25,6.58578644 10.9142136,6.25 10.5,6.25 C10.0857864,6.25 9.75,6.58578644 9.75,7 L9.75,12 C9.75,12.4142136 10.0857864,12.75 10.5,12.75 C10.9142136,12.75 11.25,12.4142136 11.25,12 Z M6.25,12 L6.25,7 C6.25,6.58578644 5.91421356,6.25 5.5,6.25 C5.08578644,6.25 4.75,6.58578644 4.75,7 L4.75,12 C4.75,12.4142136 5.08578644,12.75 5.5,12.75 C5.91421356,12.75 6.25,12.4142136 6.25,12 Z M1.5,4 L14.5,4 L1.5,4 Z M1.5,3 L14.5,3 C15.0522847,3 15.5,3.44771525 15.5,4 C15.5,4.55228475 15.0522847,5 14.5,5 L1.5,5 C0.94771525,5 0.5,4.55228475 0.5,4 C0.5,3.44771525 0.94771525,3 1.5,3 Z M9.25,3.25 L9.25,2 C9.25,1.86192881 9.13807119,1.75 9,1.75 L7,1.75 C6.86192881,1.75 6.75,1.86192881 6.75,2 L6.75,3.25 L9.25,3.25 Z M7,0.25 L9,0.25 C9.96649831,0.25 10.75,1.03350169 10.75,2 L10.75,4.75 L5.25,4.75 L5.25,2 C5.25,1.03350169 6.03350169,0.25 7,0.25 Z' id='Combined-Shape'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 210 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Ecurved-point%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='curved-point'%3E %3Cpath d='M2,15 C2,10.5818452 5.58151214,7 10.000744,7 C14.4184879,7 18,10.5818452 18,15' id='Stroke-3' stroke='%234C97FF' stroke-width='0.75' fill-opacity='0.25' fill='%234C97FF' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Cpath d='M3,7 L17,7' id='Stroke-7' stroke='%234C97FF' stroke-width='0.75' stroke-linecap='round' stroke-linejoin='round'%3E%3C/path%3E %3Ccircle id='Oval-4' fill-opacity='0.25' fill='%234C97FF' cx='10' cy='7' r='3'%3E%3C/circle%3E %3Ccircle id='Oval-4' fill='%234C97FF' cx='10' cy='7' r='2'%3E%3C/circle%3E %3Ccircle id='Oval-5' fill='%234C97FF' cx='3' cy='7' r='1'%3E%3C/circle%3E %3Ccircle id='Oval-5-Copy' fill='%234C97FF' cx='17' cy='7' r='1'%3E%3C/circle%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 211 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eflip-horizontal%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='flip-horizontal'%3E %3Cg transform='translate(2.000000, 3.000000)'%3E %3Ccircle id='Oval' fill='%23575E75' opacity='0.5' cx='8' cy='0.75' r='1'%3E%3C/circle%3E %3Ccircle id='Oval' fill='%23575E75' opacity='0.5' cx='8' cy='13.25' r='1'%3E%3C/circle%3E %3Ccircle id='Oval-Copy' fill='%23575E75' opacity='0.5' cx='8' cy='3.875' r='1'%3E%3C/circle%3E %3Ccircle id='Oval-Copy-2' fill='%23575E75' opacity='0.5' cx='8' cy='7' r='1'%3E%3C/circle%3E %3Ccircle id='Oval-Copy-3' fill='%23575E75' opacity='0.5' cx='8' cy='10.125' r='1'%3E%3C/circle%3E %3Cpath d='M16,3.08425423 L16,10.9157458 C16,11.4342626 15.2574491,11.6956996 14.8235798,11.3282353 L10.2019293,7.41103711 C9.93269025,7.18445835 9.93269025,6.81408922 10.2019293,6.58751046 L14.8235798,2.67176469 C15.2574491,2.30430042 16,2.56573745 16,3.08425423' id='Fill-11' fill='%234C97FF' opacity='0.5'%3E%3C/path%3E %3Cpath d='M0,10.9157458 L0,3.08425423 C0,2.56573745 0.742550911,2.30430042 1.17470525,2.67176469 L5.79807074,6.58896289 C6.06730975,6.81554165 6.06730975,7.18591078 5.79807074,7.41248954 L1.17470525,11.3282353 C0.742550911,11.6956996 0,11.4342626 0,10.9157458' id='Fill-14' fill='%234C97FF'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 212 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eflip-vertical%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='flip-vertical'%3E %3Cg id='flip-horizontal' transform='translate(10.000000, 10.000000) rotate(90.000000) translate(-10.000000, -10.000000) translate(2.000000, 3.000000)'%3E %3Ccircle id='Oval' fill='%23575E75' opacity='0.5' cx='8' cy='0.75' r='1'%3E%3C/circle%3E %3Ccircle id='Oval' fill='%23575E75' opacity='0.5' cx='8' cy='13.25' r='1'%3E%3C/circle%3E %3Ccircle id='Oval-Copy' fill='%23575E75' opacity='0.5' cx='8' cy='3.875' r='1'%3E%3C/circle%3E %3Ccircle id='Oval-Copy-2' fill='%23575E75' opacity='0.5' cx='8' cy='7' r='1'%3E%3C/circle%3E %3Ccircle id='Oval-Copy-3' fill='%23575E75' opacity='0.5' cx='8' cy='10.125' r='1'%3E%3C/circle%3E %3Cpath d='M16,3.08425423 L16,10.9157458 C16,11.4342626 15.2574491,11.6956996 14.8235798,11.3282353 L10.2019293,7.41103711 C9.93269025,7.18445835 9.93269025,6.81408922 10.2019293,6.58751046 L14.8235798,2.67176469 C15.2574491,2.30430042 16,2.56573745 16,3.08425423' id='Fill-11' fill='%234C97FF' opacity='0.5'%3E%3C/path%3E %3Cpath d='M0,10.9157458 L0,3.08425423 C0,2.56573745 0.742550911,2.30430042 1.17470525,2.67176469 L5.79807074,6.58896289 C6.06730975,6.81554165 6.06730975,7.18591078 5.79807074,7.41248954 L1.17470525,11.3282353 C0.742550911,11.6956996 0,11.4342626 0,10.9157458' id='Fill-14' fill='%234C97FF'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 213 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Estraight-point%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='straight-point' fill='%234C97FF'%3E %3Cpolyline id='Path-2' stroke='%234C97FF' stroke-width='0.75' fill-opacity='0.25' stroke-linecap='round' stroke-linejoin='round' points='2 15 10 7 18 15'%3E%3C/polyline%3E %3Ccircle id='Oval-4' fill-opacity='0.25' cx='10' cy='7' r='3'%3E%3C/circle%3E %3Ccircle id='Oval-4' cx='10' cy='7' r='2'%3E%3C/circle%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 214 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 50.2 (55047) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eoval-outlined%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='oval-outlined' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='Group' transform='translate(4.000000, 4.000000)' fill='%23575E75'%3E %3Cpolygon id='Fill-1' points='0 9.33333333 1.33333333 9.33333333 1.33333333 2.66666667 0 2.66666667'%3E%3C/polygon%3E %3Cpolygon id='Fill-2' points='1.33333333 2.66666667 2.66666667 2.66666667 2.66666667 1.33333333 1.33333333 1.33333333'%3E%3C/polygon%3E %3Cpolygon id='Fill-3' points='1.33333333 10.6666667 2.66666667 10.6666667 2.66666667 9.33333333 1.33333333 9.33333333'%3E%3C/polygon%3E %3Cpolygon id='Fill-4' points='2.66666667 1.33333333 9.33333333 1.33333333 9.33333333 0 2.66666667 0'%3E%3C/polygon%3E %3Cpolygon id='Fill-5' points='9.33333333 2.66666667 10.6666667 2.66666667 10.6666667 1.33333333 9.33333333 1.33333333'%3E%3C/polygon%3E %3Cpolygon id='Fill-6' points='10.6666667 9.33333333 12 9.33333333 12 2.66666667 10.6666667 2.66666667'%3E%3C/polygon%3E %3Cpolygon id='Fill-7' points='9.33333333 10.6666667 10.6666667 10.6666667 10.6666667 9.33333333 9.33333333 9.33333333'%3E%3C/polygon%3E %3Cpolygon id='Fill-8' points='2.66666667 12 9.33333333 12 9.33333333 10.6666667 2.66666667 10.6666667'%3E%3C/polygon%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 215 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 50.2 (55047) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Erectange-outlined%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='rectange-outlined' stroke='none' stroke-width='1.33333333' fill='none' fill-rule='evenodd'%3E %3Crect id='rectangle-icon' stroke='%23575E75' x='4.5' y='4.5' width='11' height='11'%3E%3C/rect%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _stylePath = __webpack_require__(9);

var _colorStyleProptype = __webpack_require__(28);

var _colorStyleProptype2 = _interopRequireDefault(_colorStyleProptype);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _fillStyle = __webpack_require__(18);

var _strokeStyle = __webpack_require__(31);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _cursor = __webpack_require__(25);

var _selection = __webpack_require__(3);

var _ovalTool = __webpack_require__(217);

var _ovalTool2 = _interopRequireDefault(_ovalTool);

var _ovalMode = __webpack_require__(218);

var _ovalMode2 = _interopRequireDefault(_ovalMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OvalMode = function (_React$Component) {
    _inherits(OvalMode, _React$Component);

    function OvalMode(props) {
        _classCallCheck(this, OvalMode);

        var _this = _possibleConstructorReturn(this, (OvalMode.__proto__ || Object.getPrototypeOf(OvalMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool', 'validateColorState']);
        return _this;
    }

    _createClass(OvalMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isOvalModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool && nextProps.colorState !== this.props.colorState) {
                this.tool.setColorState(nextProps.colorState);
            }
            if (this.tool && nextProps.selectedItems !== this.props.selectedItems) {
                this.tool.onSelectionChanged(nextProps.selectedItems);
            }

            if (nextProps.isOvalModeActive && !this.props.isOvalModeActive) {
                this.activateTool();
            } else if (!nextProps.isOvalModeActive && this.props.isOvalModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isOvalModeActive !== this.props.isOvalModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            (0, _selection.clearSelection)(this.props.clearSelectedItems);
            this.validateColorState();

            this.tool = new _ovalTool2.default(this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage);
            this.tool.setColorState(this.props.colorState);
            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'validateColorState',
        value: function validateColorState() {
            // Make sure that at least one of fill/stroke is set, and that MIXED is not one of the colors.
            // If fill and stroke color are both missing, set fill to default and stroke to transparent.
            // If exactly one of fill or stroke color is set, set the other one to transparent.
            var strokeWidth = this.props.colorState.strokeWidth;

            var fillColor1 = this.props.colorState.fillColor.primary;
            var fillColor2 = this.props.colorState.fillColor.secondary;
            var fillGradient = this.props.colorState.fillColor.gradientType;
            var strokeColor1 = this.props.colorState.strokeColor.primary;
            var strokeColor2 = this.props.colorState.strokeColor.secondary;
            var strokeGradient = this.props.colorState.strokeColor.gradientType;

            if (fillColor2 === _stylePath.MIXED) {
                this.props.clearFillGradient();
                fillColor2 = null;
                fillGradient = _gradientTypes2.default.SOLID;
            }
            if (strokeColor2 === _stylePath.MIXED) {
                this.props.clearStrokeGradient();
                strokeColor2 = null;
                strokeGradient = _gradientTypes2.default.SOLID;
            }

            var fillColorMissing = fillColor1 === _stylePath.MIXED || fillGradient === _gradientTypes2.default.SOLID && fillColor1 === null || fillGradient !== _gradientTypes2.default.SOLID && fillColor1 === null && fillColor2 === null;
            var strokeColorMissing = strokeColor1 === _stylePath.MIXED || strokeWidth === null || strokeWidth === 0 || strokeGradient === _gradientTypes2.default.SOLID && strokeColor1 === null || strokeGradient !== _gradientTypes2.default.SOLID && strokeColor1 === null && strokeColor2 === null;

            if (fillColorMissing && strokeColorMissing) {
                this.props.onChangeFillColor(_fillStyle.DEFAULT_COLOR);
                this.props.clearFillGradient();
                this.props.onChangeStrokeColor(null);
                this.props.clearStrokeGradient();
            } else if (fillColorMissing && !strokeColorMissing) {
                this.props.onChangeFillColor(null);
                this.props.clearFillGradient();
            } else if (!fillColorMissing && strokeColorMissing) {
                this.props.onChangeStrokeColor(null);
                this.props.clearStrokeGradient();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_ovalMode2.default, {
                isSelected: this.props.isOvalModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return OvalMode;
}(_react2.default.Component);

OvalMode.propTypes = {
    clearFillGradient: _propTypes2.default.func.isRequired,
    clearStrokeGradient: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    colorState: _propTypes2.default.shape({
        fillColor: _colorStyleProptype2.default,
        strokeColor: _colorStyleProptype2.default,
        strokeWidth: _propTypes2.default.number
    }).isRequired,
    handleMouseDown: _propTypes2.default.func.isRequired,
    isOvalModeActive: _propTypes2.default.bool.isRequired,
    onChangeFillColor: _propTypes2.default.func.isRequired,
    onChangeStrokeColor: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    selectedItems: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_paper2.default.Item)),
    setCursor: _propTypes2.default.func.isRequired,
    setSelectedItems: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        colorState: state.scratchPaint.color,
        isOvalModeActive: state.scratchPaint.mode === _modes2.default.OVAL,
        selectedItems: state.scratchPaint.selectedItems
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        clearFillGradient: function clearFillGradient() {
            dispatch((0, _fillStyle.clearFillGradient)());
        },
        clearStrokeGradient: function clearStrokeGradient() {
            dispatch((0, _strokeStyle.clearStrokeGradient)());
        },
        setCursor: function setCursor(cursorString) {
            dispatch((0, _cursor.setCursor)(cursorString));
        },
        setSelectedItems: function setSelectedItems() {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), false /* bitmapMode */));
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.OVAL));
        },
        onChangeFillColor: function onChangeFillColor(fillColor) {
            dispatch((0, _fillStyle.changeFillColor)(fillColor));
        },
        onChangeStrokeColor: function onChangeStrokeColor(strokeColor) {
            dispatch((0, _strokeStyle.changeStrokeColor)(strokeColor));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(OvalMode);

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _stylePath = __webpack_require__(9);

var _selection = __webpack_require__(3);

var _math = __webpack_require__(20);

var _boundingBoxTool = __webpack_require__(29);

var _boundingBoxTool2 = _interopRequireDefault(_boundingBoxTool);

var _nudgeTool = __webpack_require__(30);

var _nudgeTool2 = _interopRequireDefault(_nudgeTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tool for drawing ovals.
 */
var OvalTool = function (_paper$Tool) {
    _inherits(OvalTool, _paper$Tool);

    _createClass(OvalTool, null, [{
        key: 'TOLERANCE',
        get: function get() {
            return 2;
        }
        /**
         * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
         * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
         * @param {function} setCursor Callback to set the visible mouse cursor
         * @param {!function} onUpdateImage A callback to call when the image visibly changes
         */

    }]);

    function OvalTool(setSelectedItems, clearSelectedItems, setCursor, onUpdateImage) {
        _classCallCheck(this, OvalTool);

        var _this = _possibleConstructorReturn(this, (OvalTool.__proto__ || Object.getPrototypeOf(OvalTool)).call(this));

        _this.setSelectedItems = setSelectedItems;
        _this.clearSelectedItems = clearSelectedItems;
        _this.onUpdateImage = onUpdateImage;
        _this.boundingBoxTool = new _boundingBoxTool2.default(_modes2.default.OVAL, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);
        var nudgeTool = new _nudgeTool2.default(_modes2.default.OVAL, _this.boundingBoxTool, onUpdateImage);

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseDrag = _this.handleMouseDrag;
        _this.onMouseMove = _this.handleMouseMove;
        _this.onMouseUp = _this.handleMouseUp;
        _this.onKeyUp = nudgeTool.onKeyUp;
        _this.onKeyDown = nudgeTool.onKeyDown;

        _this.oval = null;
        _this.colorState = null;
        _this.isBoundingBoxMode = null;
        _this.active = false;
        return _this;
    }

    _createClass(OvalTool, [{
        key: 'getHitOptions',
        value: function getHitOptions() {
            return {
                segments: true,
                stroke: true,
                curves: true,
                fill: true,
                guide: false,
                match: function match(hitResult) {
                    return hitResult.item.data && (hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle) || hitResult.item.selected;
                }, // Allow hits on bounding box and selected only
                tolerance: OvalTool.TOLERANCE / _paper2.default.view.zoom
            };
        }
        /**
         * Should be called if the selection changes to update the bounds of the bounding box.
         * @param {Array<paper.Item>} selectedItems Array of selected items.
         */

    }, {
        key: 'onSelectionChanged',
        value: function onSelectionChanged(selectedItems) {
            this.boundingBoxTool.onSelectionChanged(selectedItems);
        }
    }, {
        key: 'setColorState',
        value: function setColorState(colorState) {
            this.colorState = colorState;
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;

            if (this.boundingBoxTool.onMouseDown(event, false /* clone */, false /* multiselect */, false /* doubleClicked */, this.getHitOptions())) {
                this.isBoundingBoxMode = true;
            } else {
                this.isBoundingBoxMode = false;
                (0, _selection.clearSelection)(this.clearSelectedItems);
                this.oval = new _paper2.default.Shape.Ellipse({
                    point: event.downPoint,
                    size: 0
                });
                (0, _stylePath.styleShape)(this.oval, this.colorState);
            }
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.isBoundingBoxMode) {
                this.boundingBoxTool.onMouseDrag(event);
                return;
            }

            var downPoint = new _paper2.default.Point(event.downPoint.x, event.downPoint.y);
            var point = new _paper2.default.Point(event.point.x, event.point.y);
            var squareDimensions = (0, _math.getSquareDimensions)(event.downPoint, event.point);
            if (event.modifiers.shift) {
                this.oval.size = squareDimensions.size.abs();
            } else {
                this.oval.size = downPoint.subtract(point);
            }

            if (event.modifiers.alt) {
                this.oval.position = downPoint;
            } else if (event.modifiers.shift) {
                this.oval.position = squareDimensions.position;
            } else {
                this.oval.position = downPoint.subtract(this.oval.size.multiply(0.5));
            }

            (0, _stylePath.styleShape)(this.oval, this.colorState);
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            this.boundingBoxTool.onMouseMove(event, this.getHitOptions());
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.isBoundingBoxMode) {
                this.boundingBoxTool.onMouseUp(event);
                this.isBoundingBoxMode = null;
                return;
            }

            if (this.oval) {
                if (Math.abs(this.oval.size.width * this.oval.size.height) < OvalTool.TOLERANCE / _paper2.default.view.zoom) {
                    // Tiny oval created unintentionally?
                    this.oval.remove();
                    this.oval = null;
                } else {
                    var ovalPath = this.oval.toPath(true /* insert */);
                    this.oval.remove();
                    this.oval = null;

                    ovalPath.selected = true;
                    this.setSelectedItems();
                    this.onUpdateImage();
                }
            }
            this.active = false;
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.boundingBoxTool.deactivateTool();
        }
    }]);

    return OvalTool;
}(_paper2.default.Tool);

exports.default = OvalTool;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _oval = __webpack_require__(219);

var _oval2 = _interopRequireDefault(_oval);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OvalModeComponent = function OvalModeComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.oval,
        imgSrc: _oval2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

OvalModeComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = OvalModeComponent;

/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eoval%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='oval' stroke-width='1.5' stroke='%23575E75'%3E %3Ccircle id='oval-icon' cx='10' cy='10' r='5'%3E%3C/circle%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _stylePath = __webpack_require__(9);

var _colorStyleProptype = __webpack_require__(28);

var _colorStyleProptype2 = _interopRequireDefault(_colorStyleProptype);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _fillStyle = __webpack_require__(18);

var _strokeStyle = __webpack_require__(31);

var _modes3 = __webpack_require__(10);

var _selectedItems = __webpack_require__(7);

var _cursor = __webpack_require__(25);

var _selection = __webpack_require__(3);

var _rectTool = __webpack_require__(221);

var _rectTool2 = _interopRequireDefault(_rectTool);

var _rectMode = __webpack_require__(222);

var _rectMode2 = _interopRequireDefault(_rectMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RectMode = function (_React$Component) {
    _inherits(RectMode, _React$Component);

    function RectMode(props) {
        _classCallCheck(this, RectMode);

        var _this = _possibleConstructorReturn(this, (RectMode.__proto__ || Object.getPrototypeOf(RectMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool', 'validateColorState']);
        return _this;
    }

    _createClass(RectMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isRectModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool && nextProps.colorState !== this.props.colorState) {
                this.tool.setColorState(nextProps.colorState);
            }
            if (this.tool && nextProps.selectedItems !== this.props.selectedItems) {
                this.tool.onSelectionChanged(nextProps.selectedItems);
            }

            if (nextProps.isRectModeActive && !this.props.isRectModeActive) {
                this.activateTool();
            } else if (!nextProps.isRectModeActive && this.props.isRectModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isRectModeActive !== this.props.isRectModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            (0, _selection.clearSelection)(this.props.clearSelectedItems);
            this.validateColorState();

            this.tool = new _rectTool2.default(this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage);
            this.tool.setColorState(this.props.colorState);
            this.tool.activate();
        }
    }, {
        key: 'validateColorState',
        value: function validateColorState() {
            // TODO move to shared class
            // Make sure that at least one of fill/stroke is set, and that MIXED is not one of the colors.
            // If fill and stroke color are both missing, set fill to default and stroke to transparent.
            // If exactly one of fill or stroke color is set, set the other one to transparent.
            var strokeWidth = this.props.colorState.strokeWidth;

            var fillColor1 = this.props.colorState.fillColor.primary;
            var fillColor2 = this.props.colorState.fillColor.secondary;
            var fillGradient = this.props.colorState.fillColor.gradientType;
            var strokeColor1 = this.props.colorState.strokeColor.primary;
            var strokeColor2 = this.props.colorState.strokeColor.secondary;
            var strokeGradient = this.props.colorState.strokeColor.gradientType;

            if (fillColor2 === _stylePath.MIXED) {
                this.props.clearFillGradient();
                fillColor2 = null;
                fillGradient = _gradientTypes2.default.SOLID;
            }
            if (strokeColor2 === _stylePath.MIXED) {
                this.props.clearStrokeGradient();
                strokeColor2 = null;
                strokeGradient = _gradientTypes2.default.SOLID;
            }

            var fillColorMissing = fillColor1 === _stylePath.MIXED || fillGradient === _gradientTypes2.default.SOLID && fillColor1 === null || fillGradient !== _gradientTypes2.default.SOLID && fillColor1 === null && fillColor2 === null;
            var strokeColorMissing = strokeColor1 === _stylePath.MIXED || strokeWidth === null || strokeWidth === 0 || strokeGradient === _gradientTypes2.default.SOLID && strokeColor1 === null || strokeGradient !== _gradientTypes2.default.SOLID && strokeColor1 === null && strokeColor2 === null;

            if (fillColorMissing && strokeColorMissing) {
                this.props.onChangeFillColor(_fillStyle.DEFAULT_COLOR);
                this.props.clearFillGradient();
                this.props.onChangeStrokeColor(null);
                this.props.clearStrokeGradient();
            } else if (fillColorMissing && !strokeColorMissing) {
                this.props.onChangeFillColor(null);
                this.props.clearFillGradient();
            } else if (!fillColorMissing && strokeColorMissing) {
                this.props.onChangeStrokeColor(null);
                this.props.clearStrokeGradient();
            }
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_rectMode2.default, {
                isSelected: this.props.isRectModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return RectMode;
}(_react2.default.Component);

RectMode.propTypes = {
    clearFillGradient: _propTypes2.default.func.isRequired,
    clearStrokeGradient: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    colorState: _propTypes2.default.shape({
        fillColor: _colorStyleProptype2.default,
        strokeColor: _colorStyleProptype2.default,
        strokeWidth: _propTypes2.default.number
    }).isRequired,
    handleMouseDown: _propTypes2.default.func.isRequired,
    isRectModeActive: _propTypes2.default.bool.isRequired,
    onChangeFillColor: _propTypes2.default.func.isRequired,
    onChangeStrokeColor: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    selectedItems: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_paper2.default.Item)),
    setCursor: _propTypes2.default.func.isRequired,
    setSelectedItems: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        colorState: state.scratchPaint.color,
        isRectModeActive: state.scratchPaint.mode === _modes2.default.RECT,
        selectedItems: state.scratchPaint.selectedItems
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        clearFillGradient: function clearFillGradient() {
            dispatch((0, _fillStyle.clearFillGradient)());
        },
        clearStrokeGradient: function clearStrokeGradient() {
            dispatch((0, _strokeStyle.clearStrokeGradient)());
        },
        setSelectedItems: function setSelectedItems() {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), false /* bitmapMode */));
        },
        setCursor: function setCursor(cursorString) {
            dispatch((0, _cursor.setCursor)(cursorString));
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.RECT));
        },
        onChangeFillColor: function onChangeFillColor(fillColor) {
            dispatch((0, _fillStyle.changeFillColor)(fillColor));
        },
        onChangeStrokeColor: function onChangeStrokeColor(strokeColor) {
            dispatch((0, _strokeStyle.changeStrokeColor)(strokeColor));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(RectMode);

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _stylePath = __webpack_require__(9);

var _selection = __webpack_require__(3);

var _math = __webpack_require__(20);

var _boundingBoxTool = __webpack_require__(29);

var _boundingBoxTool2 = _interopRequireDefault(_boundingBoxTool);

var _nudgeTool = __webpack_require__(30);

var _nudgeTool2 = _interopRequireDefault(_nudgeTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tool for drawing rectangles.
 */
var RectTool = function (_paper$Tool) {
    _inherits(RectTool, _paper$Tool);

    _createClass(RectTool, null, [{
        key: 'TOLERANCE',
        get: function get() {
            return 2;
        }
        /**
         * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
         * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
         * @param {function} setCursor Callback to set the visible mouse cursor
         * @param {!function} onUpdateImage A callback to call when the image visibly changes
         */

    }]);

    function RectTool(setSelectedItems, clearSelectedItems, setCursor, onUpdateImage) {
        _classCallCheck(this, RectTool);

        var _this = _possibleConstructorReturn(this, (RectTool.__proto__ || Object.getPrototypeOf(RectTool)).call(this));

        _this.setSelectedItems = setSelectedItems;
        _this.clearSelectedItems = clearSelectedItems;
        _this.onUpdateImage = onUpdateImage;
        _this.boundingBoxTool = new _boundingBoxTool2.default(_modes2.default.RECT, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);
        var nudgeTool = new _nudgeTool2.default(_modes2.default.RECT, _this.boundingBoxTool, onUpdateImage);

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseMove = _this.handleMouseMove;
        _this.onMouseDrag = _this.handleMouseDrag;
        _this.onMouseUp = _this.handleMouseUp;
        _this.onKeyUp = nudgeTool.onKeyUp;
        _this.onKeyDown = nudgeTool.onKeyDown;

        _this.rect = null;
        _this.colorState = null;
        _this.isBoundingBoxMode = null;
        _this.active = false;
        return _this;
    }

    _createClass(RectTool, [{
        key: 'getHitOptions',
        value: function getHitOptions() {
            return {
                segments: true,
                stroke: true,
                curves: true,
                fill: true,
                guide: false,
                match: function match(hitResult) {
                    return hitResult.item.data && (hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle) || hitResult.item.selected;
                }, // Allow hits on bounding box and selected only
                tolerance: RectTool.TOLERANCE / _paper2.default.view.zoom
            };
        }
        /**
         * Should be called if the selection changes to update the bounds of the bounding box.
         * @param {Array<paper.Item>} selectedItems Array of selected items.
         */

    }, {
        key: 'onSelectionChanged',
        value: function onSelectionChanged(selectedItems) {
            this.boundingBoxTool.onSelectionChanged(selectedItems);
        }
    }, {
        key: 'setColorState',
        value: function setColorState(colorState) {
            this.colorState = colorState;
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;

            if (this.boundingBoxTool.onMouseDown(event, false /* clone */, false /* multiselect */, false /* doubleClicked */, this.getHitOptions())) {
                this.isBoundingBoxMode = true;
            } else {
                this.isBoundingBoxMode = false;
                (0, _selection.clearSelection)(this.clearSelectedItems);
            }
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.isBoundingBoxMode) {
                this.boundingBoxTool.onMouseDrag(event);
                return;
            }

            if (this.rect) {
                this.rect.remove();
            }

            var rect = new _paper2.default.Rectangle(event.downPoint, event.point);
            var squareDimensions = (0, _math.getSquareDimensions)(event.downPoint, event.point);
            if (event.modifiers.shift) {
                rect.size = squareDimensions.size.abs();
            }

            this.rect = new _paper2.default.Path.Rectangle(rect);
            if (event.modifiers.alt) {
                this.rect.position = event.downPoint;
            } else if (event.modifiers.shift) {
                this.rect.position = squareDimensions.position;
            } else {
                var dimensions = event.point.subtract(event.downPoint);
                this.rect.position = event.downPoint.add(dimensions.multiply(0.5));
            }

            (0, _stylePath.styleShape)(this.rect, this.colorState);
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.isBoundingBoxMode) {
                this.boundingBoxTool.onMouseUp(event);
                this.isBoundingBoxMode = null;
                return;
            }

            if (this.rect) {
                if (this.rect.area < RectTool.TOLERANCE / _paper2.default.view.zoom) {
                    // Tiny rectangle created unintentionally?
                    this.rect.remove();
                    this.rect = null;
                } else {
                    this.rect.selected = true;
                    this.setSelectedItems();
                    this.onUpdateImage();
                    this.rect = null;
                }
            }
            this.active = false;
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            this.boundingBoxTool.onMouseMove(event, this.getHitOptions());
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.boundingBoxTool.deactivateTool();
        }
    }]);

    return RectTool;
}(_paper2.default.Tool);

exports.default = RectTool;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _rectangle = __webpack_require__(223);

var _rectangle2 = _interopRequireDefault(_rectangle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RectModeComponent = function RectModeComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.rect,
        imgSrc: _rectangle2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

RectModeComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = RectModeComponent;

/***/ }),
/* 223 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Erectangle%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' stroke-linecap='round' stroke-linejoin='round'%3E %3Cg id='rectangle' stroke='%23575E75' stroke-width='1.5'%3E %3Crect id='rectangle-icon' x='5' y='5' width='10' height='10'%3E%3C/rect%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _modes3 = __webpack_require__(10);

var _hover = __webpack_require__(36);

var _selectedItems = __webpack_require__(7);

var _selection = __webpack_require__(3);

var _reshapeTool = __webpack_require__(225);

var _reshapeTool2 = _interopRequireDefault(_reshapeTool);

var _reshapeMode = __webpack_require__(228);

var _reshapeMode2 = _interopRequireDefault(_reshapeMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ReshapeMode = function (_React$Component) {
    _inherits(ReshapeMode, _React$Component);

    function ReshapeMode(props) {
        _classCallCheck(this, ReshapeMode);

        var _this = _possibleConstructorReturn(this, (ReshapeMode.__proto__ || Object.getPrototypeOf(ReshapeMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(ReshapeMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isReshapeModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool && nextProps.hoveredItemId !== this.props.hoveredItemId) {
                this.tool.setPrevHoveredItemId(nextProps.hoveredItemId);
            }

            if (nextProps.isReshapeModeActive && !this.props.isReshapeModeActive) {
                this.activateTool();
            } else if (!nextProps.isReshapeModeActive && this.props.isReshapeModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isReshapeModeActive !== this.props.isReshapeModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            this.tool = new _reshapeTool2.default(this.props.setHoveredItem, this.props.clearHoveredItem, this.props.setSelectedItems, this.props.clearSelectedItems, this.props.onUpdateImage, this.props.switchToTextTool);
            this.tool.setPrevHoveredItemId(this.props.hoveredItemId);
            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
            this.hitResult = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_reshapeMode2.default, {
                isSelected: this.props.isReshapeModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return ReshapeMode;
}(_react2.default.Component);

ReshapeMode.propTypes = {
    clearHoveredItem: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    handleMouseDown: _propTypes2.default.func.isRequired,
    hoveredItemId: _propTypes2.default.number,
    isReshapeModeActive: _propTypes2.default.bool.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    setHoveredItem: _propTypes2.default.func.isRequired,
    setSelectedItems: _propTypes2.default.func.isRequired,
    switchToTextTool: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        isReshapeModeActive: state.scratchPaint.mode === _modes2.default.RESHAPE,
        hoveredItemId: state.scratchPaint.hoveredItemId
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        setHoveredItem: function setHoveredItem(hoveredItemId) {
            dispatch((0, _hover.setHoveredItem)(hoveredItemId));
        },
        clearHoveredItem: function clearHoveredItem() {
            dispatch((0, _hover.clearHoveredItem)());
        },
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        setSelectedItems: function setSelectedItems() {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), false /* bitmapMode */));
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.RESHAPE));
        },
        switchToTextTool: function switchToTextTool() {
            dispatch((0, _modes3.changeMode)(_modes2.default.TEXT));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(ReshapeMode);

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _keymirror = __webpack_require__(34);

var _keymirror2 = _interopRequireDefault(_keymirror);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _item = __webpack_require__(26);

var _guides = __webpack_require__(27);

var _math = __webpack_require__(20);

var _selection = __webpack_require__(3);

var _moveTool = __webpack_require__(67);

var _moveTool2 = _interopRequireDefault(_moveTool);

var _pointTool = __webpack_require__(226);

var _pointTool2 = _interopRequireDefault(_pointTool);

var _handleTool = __webpack_require__(227);

var _handleTool2 = _interopRequireDefault(_handleTool);

var _selectionBoxTool = __webpack_require__(50);

var _selectionBoxTool2 = _interopRequireDefault(_selectionBoxTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** Modes of the reshape tool, which can do many things depending on how it's used. */
var ReshapeModes = (0, _keymirror2.default)({
    FILL: null,
    POINT: null,
    HANDLE: null,
    SELECTION_BOX: null
});

/**
 * paper.Tool to handle reshape mode, which allows manipulation of control points and
 * handles of path items. Can be used to select items within groups and points within items.
 * Reshape is made up of 4 tools:
 * - Selection box tool, which is activated by clicking an empty area. Draws a box and selects
 *   points and curves inside it
 * - Move tool, which translates items
 * - Point tool, which translates, adds and removes points
 * - Handle tool, which translates handles, changing the shape of curves
 */

var ReshapeTool = function (_paper$Tool) {
    _inherits(ReshapeTool, _paper$Tool);

    _createClass(ReshapeTool, null, [{
        key: 'TOLERANCE',

        /** Distance within which mouse is considered to be hitting an item */
        get: function get() {
            return ReshapeTool.HANDLE_RADIUS + ReshapeTool.HANDLE_PADDING;
        }
        /**
         * Units of padding around the visible handle area that will still register clicks as "touching the handle"
         */

    }, {
        key: 'HANDLE_PADDING',
        get: function get() {
            return 1;
        }
        /**
         * Handles' radius, including the stroke
         */

    }, {
        key: 'HANDLE_RADIUS',
        get: function get() {
            return 5.25;
        }
        /** Clicks registered within this amount of time are registered as double clicks */

    }, {
        key: 'DOUBLE_CLICK_MILLIS',
        get: function get() {
            return 250;
        }
        /**
         * @param {function} setHoveredItem Callback to set the hovered item
         * @param {function} clearHoveredItem Callback to clear the hovered item
         * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
         * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
         * @param {!function} onUpdateImage A callback to call when the image visibly changes
         * @param {!function} switchToTextTool A callback to call to switch to the text tool
         */

    }]);

    function ReshapeTool(setHoveredItem, clearHoveredItem, setSelectedItems, clearSelectedItems, onUpdateImage, switchToTextTool) {
        _classCallCheck(this, ReshapeTool);

        var _this = _possibleConstructorReturn(this, (ReshapeTool.__proto__ || Object.getPrototypeOf(ReshapeTool)).call(this));

        _this.setHoveredItem = setHoveredItem;
        _this.clearHoveredItem = clearHoveredItem;
        _this.onUpdateImage = onUpdateImage;
        _this.prevHoveredItemId = null;
        _this.lastEvent = null;
        _this.active = false;
        _this.mode = ReshapeModes.SELECTION_BOX;
        _this._modeMap = {};
        _this._modeMap[ReshapeModes.FILL] = new _moveTool2.default(_modes2.default.RESHAPE, setSelectedItems, clearSelectedItems, onUpdateImage, switchToTextTool);
        _this._modeMap[ReshapeModes.POINT] = new _pointTool2.default(setSelectedItems, clearSelectedItems, onUpdateImage);
        _this._modeMap[ReshapeModes.HANDLE] = new _handleTool2.default(setSelectedItems, clearSelectedItems, onUpdateImage);
        _this._modeMap[ReshapeModes.SELECTION_BOX] = new _selectionBoxTool2.default(_modes2.default.RESHAPE, setSelectedItems, clearSelectedItems);

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseMove = _this.handleMouseMove;
        _this.onMouseDrag = _this.handleMouseDrag;
        _this.onMouseUp = _this.handleMouseUp;
        _this.onKeyUp = _this.handleKeyUp;
        _this.onKeyDown = _this.handleKeyDown;

        // A handle's size is given in diameter, and each handle has a 2.5-pixel stroke that isn't part of its size:
        // https://github.com/LLK/paper.js/blob/a187e4c81cc63f3d48c5097b9a9fbddde9f057da/src/item/Item.js#L4480
        // Size the handles such that clicking on either the stroke or the handle itself will be registered as a drag
        _paper2.default.settings.handleSize = ReshapeTool.HANDLE_RADIUS * 2 - 2.5;
        return _this;
    }
    /**
     * Returns the hit options for segments to use when conducting hit tests. Segments are only visible
     * when the shape is selected. Segments take precedence, since they are always over curves and need
     * to be grabbable. (Segments are the little circles)
     * @return {object} See paper.Item.hitTest for definition of options
     */


    _createClass(ReshapeTool, [{
        key: 'getSelectedSegmentHitOptions',
        value: function getSelectedSegmentHitOptions() {
            var hitOptions = {
                segments: true,
                tolerance: ReshapeTool.TOLERANCE / _paper2.default.view.zoom,
                match: function match(hitResult) {
                    if (hitResult.type !== 'segment') return false;
                    if (hitResult.item.data && hitResult.item.data.noHover) return false;
                    if (!hitResult.item.selected) return false;
                    return true;
                }
            };
            return hitOptions;
        }
        /**
         * Returns the hit options for handles to use when conducting hit tests. Handles need to be done
         * separately because we want to ignore hidden handles, but we don't want hidden handles to negate
         * legitimate hits on other things (like if the handle is over part of the fill). (Handles are the diamonds)
         * @return {object} See paper.Item.hitTest for definition of options
         */

    }, {
        key: 'getHandleHitOptions',
        value: function getHandleHitOptions() {
            var hitOptions = {
                handles: true,
                tolerance: ReshapeTool.TOLERANCE / _paper2.default.view.zoom,
                match: function match(hitResult) {
                    if (hitResult.item.data && hitResult.item.data.noHover) return false;
                    // Only hit test against handles that are visible, that is,
                    // their segment is selected
                    if (!hitResult.segment || !hitResult.segment.selected) return false;
                    // If the entire shape is selected, handles are hidden
                    if (hitResult.item.fullySelected) return false;
                    return true;
                }
            };
            return hitOptions;
        }
        /**
         * Returns the hit options for curves of selected objects, which take precedence over
         * unselected things and fills.
         * @return {object} See paper.Item.hitTest for definition of options
         */

    }, {
        key: 'getSelectedStrokeHitOptions',
        value: function getSelectedStrokeHitOptions() {
            var hitOptions = {
                segments: false,
                stroke: false,
                curves: true,
                handles: false,
                fill: false,
                guide: false,
                tolerance: ReshapeTool.TOLERANCE / _paper2.default.view.zoom,
                match: function match(hitResult) {
                    if (hitResult.type !== 'curve') return false;
                    if (!hitResult.item.selected) return false;
                    if (hitResult.item.data && hitResult.item.data.noHover) return false;
                    return true;
                }
            };
            return hitOptions;
        }
        /**
         * Returns the hit options for fills and unselected strokes/curves to use when conducting hit tests.
         * @param {boolean} preselectedOnly True if we should only return results that are already
         *     selected.
         * @return {object} See paper.Item.hitTest for definition of options
         */

    }, {
        key: 'getUnselectedAndFillHitOptions',
        value: function getUnselectedAndFillHitOptions() {
            var hitOptions = {
                fill: true,
                stroke: true,
                curves: true,
                tolerance: ReshapeTool.TOLERANCE / _paper2.default.view.zoom,
                match: function match(hitResult) {
                    if (hitResult.item.data && hitResult.item.data.noHover) return false;
                    return true;
                }
            };
            return hitOptions;
        }
        /**
         * To be called when the hovered item changes. When the select tool hovers over a
         * new item, it compares against this to see if a hover item change event needs to
         * be fired.
         * @param {paper.Item} prevHoveredItemId ID of the highlight item that indicates the mouse is
         *     over a given item currently
         */

    }, {
        key: 'setPrevHoveredItemId',
        value: function setPrevHoveredItemId(prevHoveredItemId) {
            this.prevHoveredItemId = prevHoveredItemId;
        }
        /**
         * Given the point at which the mouse is, return the prioritized hit result, or null if nothing was hit.
         * @param {paper.Point} point Point to hit test on canvas
         * @return {?paper.HitResult} hitResult
         */

    }, {
        key: 'getHitResult',
        value: function getHitResult(point) {
            // Prefer hits on segments to other types of hits, since segments always overlap curves.
            var hitResults = _paper2.default.project.hitTestAll(point, this.getSelectedSegmentHitOptions());
            if (!hitResults.length) {
                hitResults = _paper2.default.project.hitTestAll(point, this.getHandleHitOptions());
            }
            if (!hitResults.length) {
                hitResults = _paper2.default.project.hitTestAll(point, this.getSelectedStrokeHitOptions());
            }
            if (!hitResults.length) {
                hitResults = _paper2.default.project.hitTestAll(point, this.getUnselectedAndFillHitOptions());
            }
            if (!hitResults.length) {
                return null;
            }

            // Get highest z-index result
            var hitResult = void 0;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = hitResults[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var result = _step.value;

                    if (!hitResult || (0, _math.sortItemsByZIndex)(hitResult.item, result.item) < 0) {
                        hitResult = result;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return hitResult;
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;
            this.clearHoveredItem();

            // Check if double clicked
            var doubleClicked = false;
            if (this.lastEvent) {
                if (event.event.timeStamp - this.lastEvent.event.timeStamp < ReshapeTool.DOUBLE_CLICK_MILLIS) {
                    doubleClicked = true;
                } else {
                    doubleClicked = false;
                }
            }
            this.lastEvent = event;

            var hitResult = this.getHitResult(event.point);
            if (!hitResult) {
                this._modeMap[ReshapeModes.SELECTION_BOX].onMouseDown(event.modifiers.shift);
                return;
            }

            var hitProperties = {
                hitResult: hitResult,
                clone: event.modifiers.alt,
                multiselect: event.modifiers.shift,
                doubleClicked: doubleClicked,
                subselect: true
            };

            // If item is not yet selected, don't behave differently depending on if they clicked a segment
            // (since those were invisible), just select the whole thing as if they clicked the fill.
            if (!hitResult.item.selected || hitResult.type === 'fill' || hitResult.type === 'stroke' || hitResult.type !== 'segment' && doubleClicked) {
                this.mode = ReshapeModes.FILL;
                this._modeMap[this.mode].onMouseDown(hitProperties);
            } else if (hitResult.type === 'segment') {
                this.mode = ReshapeModes.POINT;
                this._modeMap[this.mode].onMouseDown(hitProperties);
            } else if (hitResult.type === 'curve') {
                this.mode = ReshapeModes.POINT;
                this._modeMap[this.mode].addPoint(hitProperties);
                this.onUpdateImage();
                this._modeMap[this.mode].onMouseDown(hitProperties);
            } else if (hitResult.type === 'handle-in' || hitResult.type === 'handle-out') {
                this.mode = ReshapeModes.HANDLE;
                this._modeMap[this.mode].onMouseDown(hitProperties);
            } else {
                _log2.default.warn('Unhandled hit result type: ' + hitResult.type);
                this.mode = ReshapeModes.FILL;
                this._modeMap[this.mode].onMouseDown(hitProperties);
            }
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            var hitResult = this.getHitResult(event.point);
            var hoveredItem = void 0;

            if (hitResult) {
                var item = hitResult.item;
                if (item.selected) {
                    hoveredItem = null;
                } else if ((0, _item.isBoundsItem)(item)) {
                    hoveredItem = (0, _guides.hoverBounds)(item);
                } else {
                    hoveredItem = (0, _guides.hoverItem)(item);
                }
            }

            if (!hoveredItem && this.prevHoveredItemId || // There is no longer a hovered item
            hoveredItem && !this.prevHoveredItemId || // There is now a hovered item
            hoveredItem && this.prevHoveredItemId && hoveredItem.id !== this.prevHoveredItemId) {
                // hovered item changed
                this.setHoveredItem(hoveredItem ? hoveredItem.id : null);
            }
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button
            this._modeMap[this.mode].onMouseDrag(event);
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button
            if (this.mode === ReshapeModes.SELECTION_BOX) {
                this._modeMap[this.mode].onMouseUpVector(event);
            } else {
                this._modeMap[this.mode].onMouseUp(event);
            }
            this.mode = ReshapeModes.SELECTION_BOX;
            this.active = false;
        }
    }, {
        key: 'handleKeyDown',
        value: function handleKeyDown(event) {
            if (event.event.target instanceof HTMLInputElement) {
                // Ignore nudge if a text input field is focused
                return;
            }

            var nudgeAmount = 1 / _paper2.default.view.zoom;
            var selected = (0, _selection.getSelectedLeafItems)();
            if (selected.length === 0) return;

            var translation = void 0;
            if (event.key === 'up') {
                translation = new _paper2.default.Point(0, -nudgeAmount);
            } else if (event.key === 'down') {
                translation = new _paper2.default.Point(0, nudgeAmount);
            } else if (event.key === 'left') {
                translation = new _paper2.default.Point(-nudgeAmount, 0);
            } else if (event.key === 'right') {
                translation = new _paper2.default.Point(nudgeAmount, 0);
            }

            if (translation) {
                var segments = (0, _selection.getSelectedSegments)();
                // If no segments are selected, translate selected paths
                if (segments.length === 0) {
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                        for (var _iterator2 = selected[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var item = _step2.value;

                            item.translate(translation);
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                } else {
                    // Translate segments
                    var _iteratorNormalCompletion3 = true;
                    var _didIteratorError3 = false;
                    var _iteratorError3 = undefined;

                    try {
                        for (var _iterator3 = segments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                            var seg = _step3.value;

                            seg.point = seg.point.add(translation);
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                _iterator3.return();
                            }
                        } finally {
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }
                }
            }
        }
    }, {
        key: 'handleKeyUp',
        value: function handleKeyUp(event) {
            var selected = (0, _selection.getSelectedLeafItems)();
            if (selected.length === 0) return;

            if (event.key === 'up' || event.key === 'down' || event.key === 'left' || event.key === 'right') {
                this.onUpdateImage();
            }
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            _paper2.default.settings.handleSize = 0;
            this.clearHoveredItem();
            this.setHoveredItem = null;
            this.clearHoveredItem = null;
            this.onUpdateImage = null;
            this.lastEvent = null;
        }
    }]);

    return ReshapeTool;
}(_paper2.default.Tool);

exports.default = ReshapeTool;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(20);

var _view = __webpack_require__(22);

var _selection = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Subtool of ReshapeTool for moving control points. */
var PointTool = function () {
    /**
     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
     * @param {!function} onUpdateImage A callback to call when the image visibly changes
     */
    function PointTool(setSelectedItems, clearSelectedItems, onUpdateImage) {
        _classCallCheck(this, PointTool);

        /**
         * Deselection often does not happen until mouse up. If the mouse is dragged before
         * mouse up, deselection is cancelled. This variable keeps track of which paper.Item to deselect.
         */
        this.deselectOnMouseUp = null;
        /**
         * Delete control point does not happen until mouse up. If the mouse is dragged before
         * mouse up, delete is cancelled. This variable keeps track of the hitResult that triggers delete.
         */
        this.deleteOnMouseUp = null;
        /**
         * There are 2 cases for deselection: Deselect this, or deselect everything but this.
         * When invert deselect is true, deselect everything but the item in deselectOnMouseUp.
         */
        this.invertDeselect = false;
        this.selectedItems = null;
        this.setSelectedItems = setSelectedItems;
        this.clearSelectedItems = clearSelectedItems;
        this.lastPoint = null;
        this.onUpdateImage = onUpdateImage;
    }

    /**
     * @param {!object} hitProperties Describes the mouse event
     * @param {!paper.HitResult} hitProperties.hitResult Data about the location of the mouse click
     * @param {?boolean} hitProperties.multiselect Whether to multiselect on mouse down (e.g. shift key held)
     * @param {?boolean} hitProperties.doubleClicked Whether this is the second click in a short time
     */


    _createClass(PointTool, [{
        key: 'onMouseDown',
        value: function onMouseDown(hitProperties) {
            // Remove point
            if (hitProperties.doubleClicked) {
                this.deleteOnMouseUp = hitProperties.hitResult;
            }
            if (hitProperties.hitResult.segment.selected) {
                // selected points with no handles get handles if selected again
                if (hitProperties.multiselect) {
                    this.deselectOnMouseUp = hitProperties.hitResult.segment;
                } else {
                    this.deselectOnMouseUp = hitProperties.hitResult.segment;
                    this.invertDeselect = true;
                    hitProperties.hitResult.segment.selected = true;
                }
            } else {
                if (!hitProperties.multiselect) {
                    (0, _selection.clearSelection)(this.clearSelectedItems);
                }
                hitProperties.hitResult.segment.selected = true;
            }

            this.selectedItems = (0, _selection.getSelectedLeafItems)();
        }
        /**
         * @param {!object} hitProperties Describes the mouse event
         * @param {!paper.HitResult} hitProperties.hitResult Data about the location of the mouse click
         * @param {?boolean} hitProperties.multiselect Whether to multiselect on mouse down (e.g. shift key held)
         */

    }, {
        key: 'addPoint',
        value: function addPoint(hitProperties) {
            var newSegment = hitProperties.hitResult.item.divideAt(hitProperties.hitResult.location);

            // If we're adding a point in the middle of a straight line, it won't be smooth by default, so smooth it
            if (!newSegment.hasHandles()) newSegment.smooth();

            hitProperties.hitResult.segment = newSegment;
            if (!hitProperties.multiselect) {
                (0, _selection.clearSelection)(this.clearSelectedItems);
            }
            newSegment.selected = true;
        }
    }, {
        key: 'removePoint',
        value: function removePoint(hitResult) {
            var index = hitResult.segment.index;
            hitResult.item.removeSegment(index);

            // Adjust handles of curve before and curve after to account for new curve length
            var beforeSegment = hitResult.item.segments[index - 1];
            var afterSegment = hitResult.item.segments[index];
            var curveLength = beforeSegment ? beforeSegment.curve ? beforeSegment.curve.length : null : null;
            if (beforeSegment && beforeSegment.handleOut) {
                if (afterSegment) {
                    beforeSegment.handleOut = beforeSegment.handleOut.multiply(curveLength * _math.HANDLE_RATIO / beforeSegment.handleOut.length);
                } else {
                    beforeSegment.handleOut = null;
                }
            }
            if (afterSegment && afterSegment.handleIn) {
                if (beforeSegment) {
                    afterSegment.handleIn = afterSegment.handleIn.multiply(curveLength * _math.HANDLE_RATIO / afterSegment.handleIn.length);
                } else {
                    afterSegment.handleIn = null;
                }
            }
        }
    }, {
        key: 'onMouseDrag',
        value: function onMouseDrag(event) {
            // A click will deselect, but a drag will not
            this.deselectOnMouseUp = null;
            this.invertDeselect = false;
            this.deleteOnMouseUp = null;

            var point = event.point;
            var bounds = (0, _view.getActionBounds)();
            point.x = Math.max(bounds.left, Math.min(point.x, bounds.right));
            point.y = Math.max(bounds.top, Math.min(point.y, bounds.bottom));

            if (!this.lastPoint) this.lastPoint = event.lastPoint;
            var dragVector = point.subtract(event.downPoint);
            var delta = point.subtract(this.lastPoint);
            this.lastPoint = point;

            var selectedSegments = (0, _selection.getSelectedSegments)();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = selectedSegments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var seg = _step.value;

                    // add the point of the segment before the drag started
                    // for later use in the snap calculation
                    if (!seg.origPoint) {
                        seg.origPoint = seg.point.clone();
                    }

                    if (event.modifiers.shift) {
                        seg.point = seg.origPoint.add((0, _math.snapDeltaToAngle)(dragVector, Math.PI / 4));
                    } else {
                        seg.point = seg.point.add(delta);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp() {
            this.lastPoint = null;

            // resetting the items and segments origin points for the next usage
            var moved = false;
            var selectedSegments = (0, _selection.getSelectedSegments)();
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = selectedSegments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var seg = _step2.value;

                    if (seg.origPoint && !seg.equals(seg.origPoint)) {
                        moved = true;
                    }
                    seg.origPoint = null;
                }

                // If no drag occurred between mouse down and mouse up, then we can go through with deselect
                // and delete
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            if (this.deselectOnMouseUp) {
                if (this.invertDeselect) {
                    (0, _selection.clearSelection)(this.clearSelectedItems);
                    this.deselectOnMouseUp.selected = true;
                } else {
                    this.deselectOnMouseUp.selected = false;
                }
                this.deselectOnMouseUp = null;
                this.invertDeselect = false;
            }
            if (this.deleteOnMouseUp) {
                this.removePoint(this.deleteOnMouseUp);
            }
            this.selectedItems = null;
            this.setSelectedItems();
            if (moved || this.deleteOnMouseUp) {
                this.deleteOnMouseUp = null;
                this.onUpdateImage();
            }
        }
    }]);

    return PointTool;
}();

exports.default = PointTool;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _selection = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Sub tool of the Reshape tool for moving handles, which adjust bezier curves. */
var HandleTool = function () {
    /**
     * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
     * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
     * @param {!function} onUpdateImage A callback to call when the image visibly changes
     */
    function HandleTool(setSelectedItems, clearSelectedItems, onUpdateImage) {
        _classCallCheck(this, HandleTool);

        this.hitType = null;
        this.setSelectedItems = setSelectedItems;
        this.clearSelectedItems = clearSelectedItems;
        this.onUpdateImage = onUpdateImage;
        this.selectedItems = [];
    }
    /**
     * @param {!object} hitProperties Describes the mouse event
     * @param {?boolean} hitProperties.multiselect Whether to multiselect on mouse down (e.g. shift key held)
     *     select the whole group.
     */


    _createClass(HandleTool, [{
        key: 'onMouseDown',
        value: function onMouseDown(hitProperties) {
            if (!hitProperties.multiselect) {
                (0, _selection.clearSelection)(this.clearSelectedItems);
            }

            hitProperties.hitResult.segment.handleIn.selected = true;
            hitProperties.hitResult.segment.handleOut.selected = true;
            this.hitType = hitProperties.hitResult.type;
        }
    }, {
        key: 'onMouseDrag',
        value: function onMouseDrag(event) {
            this.selectedItems = (0, _selection.getSelectedLeafItems)();

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = this.selectedItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var item = _step.value;
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                        for (var _iterator2 = item.segments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var seg = _step2.value;

                            // add the point of the segment before the drag started
                            // for later use in the snap calculation
                            if (!seg.origPoint) {
                                seg.origPoint = seg.point.clone();
                            }

                            if (seg.handleOut.selected && this.hitType === 'handle-out') {
                                // if option is pressed or handles have been split,
                                // they're no longer parallel and move independently
                                if (event.modifiers.option || !seg.handleOut.isColinear(seg.handleIn)) {
                                    seg.handleOut = seg.handleOut.add(event.delta);
                                } else {
                                    seg.handleOut = seg.handleOut.add(event.delta);
                                    seg.handleIn = seg.handleOut.multiply(-seg.handleIn.length / seg.handleOut.length);
                                }
                            } else if (seg.handleIn.selected && this.hitType === 'handle-in') {
                                // if option is pressed or handles have been split,
                                // they're no longer parallel and move independently
                                if (event.modifiers.option || !seg.handleOut.isColinear(seg.handleIn)) {
                                    seg.handleIn = seg.handleIn.add(event.delta);
                                } else {
                                    seg.handleIn = seg.handleIn.add(event.delta);
                                    seg.handleOut = seg.handleIn.multiply(-seg.handleOut.length / seg.handleIn.length);
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp() {
            // resetting the items and segments origin points for the next usage
            var moved = false;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = this.selectedItems[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var item = _step3.value;

                    if (!item.segments) {
                        return;
                    }
                    var _iteratorNormalCompletion4 = true;
                    var _didIteratorError4 = false;
                    var _iteratorError4 = undefined;

                    try {
                        for (var _iterator4 = item.segments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                            var seg = _step4.value;

                            if (seg.origPoint && !seg.equals(seg.origPoint)) {
                                moved = true;
                            }
                            seg.origPoint = null;
                        }
                    } catch (err) {
                        _didIteratorError4 = true;
                        _iteratorError4 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                _iterator4.return();
                            }
                        } finally {
                            if (_didIteratorError4) {
                                throw _iteratorError4;
                            }
                        }
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            if (moved) {
                this.setSelectedItems();
                this.onUpdateImage();
            }
            this.selectedItems = [];
        }
    }]);

    return HandleTool;
}();

exports.default = HandleTool;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _reshape = __webpack_require__(229);

var _reshape2 = _interopRequireDefault(_reshape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ReshapeModeComponent = function ReshapeModeComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.reshape,
        imgSrc: _reshape2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

ReshapeModeComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = ReshapeModeComponent;

/***/ }),
/* 229 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Ereshape%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='reshape'%3E %3Cg id='reshape-icon' transform='translate(3.000000, 2.000000)'%3E %3Cpath d='M6.3718,4e-05 C6.3718,1.20298846 6.03840639,2.32811001 5.45898306,3.28804076 C5.31876362,3.52034235 4.30079812,3.15107034 3.82818604,3.61859131 C3.35557395,4.08611228 3.47873759,5.34529147 3.26181884,5.47482181 C2.30759304,6.04462589 1.19191205,6.37204 -0.0002,6.37204' id='Stroke-1' stroke='%23575E75' stroke-width='0.75'%3E%3C/path%3E %3Cpath d='M4,6.94999094 C2.85887984,6.71835578 2,5.70947896 2,4.5 C2,3.11928813 3.11928813,2 4.5,2 C5.88071187,2 7,3.11928813 7,4.5 C7,4.56854233 6.99724162,4.63644042 6.99182982,4.70358929 L6.68137747,4.42017327 C5.65792772,3.48493325 4,4.20484091 4,5.595932 L4,6.94999094 Z' id='Combined-Shape' fill='%23575E75'%3E%3C/path%3E %3Cpath d='M4,7.96455557 C2.30385293,7.72194074 1,6.26323595 1,4.5 C1,2.56700338 2.56700338,1 4.5,1 C6.43299662,1 8,2.56700338 8,4.5 C8,4.84508345 7.95005914,5.1785026 7.85701065,5.4934242 L6.68137747,4.42017327 C5.65792772,3.48493325 4,4.20484091 4,5.595932 L4,7.96455557 Z' id='Oval-2' fill-opacity='0.15' fill='%23575E75'%3E%3C/path%3E %3Cpath d='M7.87915329,13.1684522 L8.98467414,15.6316703 C9.20235954,16.1186581 9.76980913,16.3337238 10.2516521,16.1137141 C10.7334951,15.8924683 10.9462887,15.3189598 10.7286032,14.833208 L9.63583183,12.3973461 L12.3974628,12.3973461 C12.945512,12.3973461 13.207518,11.7313818 12.8048941,11.3644462 L6.00716065,5.15870674 C5.6225647,4.80725864 5,5.07769498 5,5.595932 L5,14.8026807 C5,15.3507015 5.68145595,15.608033 6.04802397,15.1994001 L7.87915329,13.1684522 Z' id='select-icon' fill='%23575E75'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _modes3 = __webpack_require__(10);

var _hover = __webpack_require__(36);

var _selectedItems = __webpack_require__(7);

var _cursor = __webpack_require__(25);

var _selection = __webpack_require__(3);

var _selectTool = __webpack_require__(231);

var _selectTool2 = _interopRequireDefault(_selectTool);

var _selectMode = __webpack_require__(232);

var _selectMode2 = _interopRequireDefault(_selectMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SelectMode = function (_React$Component) {
    _inherits(SelectMode, _React$Component);

    function SelectMode(props) {
        _classCallCheck(this, SelectMode);

        var _this = _possibleConstructorReturn(this, (SelectMode.__proto__ || Object.getPrototypeOf(SelectMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(SelectMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isSelectModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool && nextProps.hoveredItemId !== this.props.hoveredItemId) {
                this.tool.setPrevHoveredItemId(nextProps.hoveredItemId);
            }
            if (this.tool && nextProps.selectedItems !== this.props.selectedItems) {
                this.tool.onSelectionChanged(nextProps.selectedItems);
            }

            if (nextProps.isSelectModeActive && !this.props.isSelectModeActive) {
                this.activateTool();
            } else if (!nextProps.isSelectModeActive && this.props.isSelectModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isSelectModeActive !== this.props.isSelectModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool() {
            this.tool = new _selectTool2.default(this.props.setHoveredItem, this.props.clearHoveredItem, this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage, this.props.switchToTextTool);
            this.tool.activate();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_selectMode2.default, {
                isSelected: this.props.isSelectModeActive,
                onMouseDown: this.props.handleMouseDown
            });
        }
    }]);

    return SelectMode;
}(_react2.default.Component);

SelectMode.propTypes = {
    clearHoveredItem: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    handleMouseDown: _propTypes2.default.func.isRequired,
    hoveredItemId: _propTypes2.default.number,
    isSelectModeActive: _propTypes2.default.bool.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    selectedItems: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_paper2.default.Item)),
    setCursor: _propTypes2.default.func.isRequired,
    setHoveredItem: _propTypes2.default.func.isRequired,
    setSelectedItems: _propTypes2.default.func.isRequired,
    switchToTextTool: _propTypes2.default.func.isRequired
};

var mapStateToProps = function mapStateToProps(state) {
    return {
        isSelectModeActive: state.scratchPaint.mode === _modes2.default.SELECT,
        hoveredItemId: state.scratchPaint.hoveredItemId,
        selectedItems: state.scratchPaint.selectedItems
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        setHoveredItem: function setHoveredItem(hoveredItemId) {
            dispatch((0, _hover.setHoveredItem)(hoveredItemId));
        },
        clearHoveredItem: function clearHoveredItem() {
            dispatch((0, _hover.clearHoveredItem)());
        },
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        setSelectedItems: function setSelectedItems() {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), false /* bitmapMode */));
        },
        setCursor: function setCursor(cursorString) {
            dispatch((0, _cursor.setCursor)(cursorString));
        },
        handleMouseDown: function handleMouseDown() {
            dispatch((0, _modes3.changeMode)(_modes2.default.SELECT));
        },
        switchToTextTool: function switchToTextTool() {
            dispatch((0, _modes3.changeMode)(_modes2.default.TEXT));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(SelectMode);

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _hover = __webpack_require__(80);

var _selection = __webpack_require__(3);

var _boundingBoxTool = __webpack_require__(29);

var _boundingBoxTool2 = _interopRequireDefault(_boundingBoxTool);

var _nudgeTool = __webpack_require__(30);

var _nudgeTool2 = _interopRequireDefault(_nudgeTool);

var _selectionBoxTool = __webpack_require__(50);

var _selectionBoxTool2 = _interopRequireDefault(_selectionBoxTool);

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * paper.Tool that handles select mode. This is made up of 2 subtools.
 * - The selection box tool is active when the user clicks an empty space and drags.
 *   It selects all items in the rectangle.
 * - The bounding box tool is active if the user clicks on a non-empty space. It handles
 *   reshaping the item that was clicked.
 */
var SelectTool = function (_paper$Tool) {
    _inherits(SelectTool, _paper$Tool);

    _createClass(SelectTool, null, [{
        key: 'TOLERANCE',

        /** The distance within which mouse events count as a hit against an item */
        get: function get() {
            return 2;
        }
        /** Clicks registered within this amount of time are registered as double clicks */

    }, {
        key: 'DOUBLE_CLICK_MILLIS',
        get: function get() {
            return 250;
        }
        /**
         * @param {function} setHoveredItem Callback to set the hovered item
         * @param {function} clearHoveredItem Callback to clear the hovered item
         * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
         * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
         * @param {function} setCursor Callback to set the visible mouse cursor
         * @param {!function} onUpdateImage A callback to call when the image visibly changes
         * @param {!function} switchToTextTool A callback to call to switch to the text tool
         */

    }]);

    function SelectTool(setHoveredItem, clearHoveredItem, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage, switchToTextTool) {
        _classCallCheck(this, SelectTool);

        var _this = _possibleConstructorReturn(this, (SelectTool.__proto__ || Object.getPrototypeOf(SelectTool)).call(this));

        _this.setHoveredItem = setHoveredItem;
        _this.clearHoveredItem = clearHoveredItem;
        _this.onUpdateImage = onUpdateImage;
        _this.boundingBoxTool = new _boundingBoxTool2.default(_modes2.default.SELECT, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage, switchToTextTool);
        var nudgeTool = new _nudgeTool2.default(_modes2.default.SELECT, _this.boundingBoxTool, onUpdateImage);
        _this.selectionBoxTool = new _selectionBoxTool2.default(_modes2.default.SELECT, setSelectedItems, clearSelectedItems);
        _this.selectionBoxMode = false;
        _this.prevHoveredItemId = null;
        _this.active = false;

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseMove = _this.handleMouseMove;
        _this.onMouseDrag = _this.handleMouseDrag;
        _this.onMouseUp = _this.handleMouseUp;
        _this.onKeyUp = nudgeTool.onKeyUp;
        _this.onKeyDown = nudgeTool.onKeyDown;

        (0, _selection.selectRootItem)();
        setSelectedItems();
        _this.boundingBoxTool.setSelectionBounds();
        return _this;
    }
    /**
     * To be called when the hovered item changes. When the select tool hovers over a
     * new item, it compares against this to see if a hover item change event needs to
     * be fired.
     * @param {paper.Item} prevHoveredItemId ID of the highlight item that indicates the mouse is
     *     over a given item currently
     */


    _createClass(SelectTool, [{
        key: 'setPrevHoveredItemId',
        value: function setPrevHoveredItemId(prevHoveredItemId) {
            this.prevHoveredItemId = prevHoveredItemId;
        }
        /**
         * Should be called if the selection changes to update the bounds of the bounding box.
         * @param {Array<paper.Item>} selectedItems Array of selected items.
         */

    }, {
        key: 'onSelectionChanged',
        value: function onSelectionChanged(selectedItems) {
            this.boundingBoxTool.onSelectionChanged(selectedItems);
        }
        /**
         * Returns the hit options to use when conducting hit tests.
         * @param {boolean} preselectedOnly True if we should only return results that are already
         *     selected.
         * @return {object} See paper.Item.hitTest for definition of options
         */

    }, {
        key: 'getHitOptions',
        value: function getHitOptions(preselectedOnly) {
            // Tolerance needs to be scaled when the view is zoomed in in order to represent the same
            // distance for the user to move the mouse.
            var hitOptions = {
                segments: true,
                stroke: true,
                curves: true,
                fill: true,
                guide: false,
                tolerance: SelectTool.TOLERANCE / _paper2.default.view.zoom,
                match: function match(hitResult) {
                    // Don't match helper items, unless they are handles.
                    if (!hitResult.item.data || !hitResult.item.data.isHelperItem) return true;
                    return hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle;
                }
            };
            if (preselectedOnly) {
                hitOptions.selected = true;
            }
            return hitOptions;
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;
            this.clearHoveredItem();

            // Check if double clicked
            var doubleClicked = false;
            if (this.lastEvent) {
                if (event.event.timeStamp - this.lastEvent.event.timeStamp < SelectTool.DOUBLE_CLICK_MILLIS) {
                    doubleClicked = true;
                } else {
                    doubleClicked = false;
                }
            }
            this.lastEvent = event;

            // If bounding box tool does not find an item that was hit, use selection box tool.
            if (!this.boundingBoxTool.onMouseDown(event, event.modifiers.alt, event.modifiers.shift, doubleClicked, this.getHitOptions(false /* preseelectedOnly */))) {
                this.selectionBoxMode = true;
                this.selectionBoxTool.onMouseDown(event.modifiers.shift);
            }
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            var hoveredItem = (0, _hover.getHoveredItem)(event, this.getHitOptions());
            if (!hoveredItem && this.prevHoveredItemId || // There is no longer a hovered item
            hoveredItem && !this.prevHoveredItemId || // There is now a hovered item
            hoveredItem && this.prevHoveredItemId && hoveredItem.id !== this.prevHoveredItemId) {
                // hovered item changed
                this.setHoveredItem(hoveredItem ? hoveredItem.id : null);
            }

            if (!this.selectionBoxMode) {
                this.boundingBoxTool.onMouseMove(event, this.getHitOptions(false));
            }
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.selectionBoxMode) {
                this.selectionBoxTool.onMouseDrag(event);
            } else {
                this.boundingBoxTool.onMouseDrag(event);
            }
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.selectionBoxMode) {
                this.selectionBoxTool.onMouseUpVector(event);
            } else {
                this.boundingBoxTool.onMouseUp(event, this.getHitOptions(false));
            }
            this.selectionBoxMode = false;
            this.active = false;
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.clearHoveredItem();
            this.boundingBoxTool.deactivateTool();
            this.setHoveredItem = null;
            this.clearHoveredItem = null;
            this.onUpdateImage = null;
            this.boundingBoxTool = null;
            this.selectionBoxTool = null;
        }
    }]);

    return SelectTool;
}(_paper2.default.Tool);

exports.default = SelectTool;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _select = __webpack_require__(233);

var _select2 = _interopRequireDefault(_select);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SelectModeComponent = function SelectModeComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.select,
        imgSrc: _select2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

SelectModeComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = SelectModeComponent;

/***/ }),
/* 233 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Eselect%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='select' fill='%23575E75'%3E %3Cpath d='M9.08480709,12.7519131 L10.2692937,15.3910753 C10.5025281,15.912848 11.1105098,16.1432755 11.6267701,15.9075508 C12.1430304,15.6705018 12.3710236,15.0560284 12.1377892,14.53558 L10.9669627,11.925728 L13.925853,11.925728 C14.5130486,11.925728 14.7937693,11.2121948 14.3623865,10.8190495 L7.0791007,4.17004294 C6.6670336,3.7934914 6,4.08324462 6,4.63849857 L6,14.5028722 C6,15.0900373 6.73013138,15.3657496 7.12288282,14.9279287 L9.08480709,12.7519131 Z' id='select-icon'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _reactRedux = __webpack_require__(6);

var _reactIntl = __webpack_require__(23);

var _colorIndex = __webpack_require__(42);

var _strokeStyle = __webpack_require__(31);

var _strokeWidth = __webpack_require__(32);

var _modals = __webpack_require__(52);

var _selection = __webpack_require__(3);

var _selectedItems = __webpack_require__(7);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _format = __webpack_require__(11);

var _colorIndicator = __webpack_require__(76);

var _colorIndicator2 = _interopRequireDefault(_colorIndicator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var messages = (0, _reactIntl.defineMessages)({
    label: {
        'id': 'paint.paintEditor.stroke',
        'defaultMessage': 'Outline'
    }
});

var StrokeColorIndicator = (0, _colorIndicator2.default)(messages.label, true);

var mapStateToProps = function mapStateToProps(state) {
    return {
        colorIndex: state.scratchPaint.fillMode.colorIndex,
        disabled: state.scratchPaint.mode === _modes2.default.BRUSH || state.scratchPaint.mode === _modes2.default.TEXT || state.scratchPaint.mode === _modes2.default.FILL,
        color: state.scratchPaint.color.strokeColor.primary,
        color2: state.scratchPaint.color.strokeColor.secondary,
        fillBitmapShapes: state.scratchPaint.fillBitmapShapes,
        colorModalVisible: state.scratchPaint.modals.strokeColor,
        format: state.scratchPaint.format,
        gradientType: state.scratchPaint.color.strokeColor.gradientType,
        isEyeDropping: state.scratchPaint.color.eyeDropper.active,
        mode: state.scratchPaint.mode,
        shouldShowGradientTools: state.scratchPaint.mode in _modes.GradientToolsModes,
        textEditTarget: state.scratchPaint.textEditTarget
    };
};

var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        onChangeColorIndex: function onChangeColorIndex(index) {
            dispatch((0, _colorIndex.changeColorIndex)(index));
        },
        onChangeColor: function onChangeColor(strokeColor, index) {
            if (index === 0) {
                dispatch((0, _strokeStyle.changeStrokeColor)(strokeColor));
            } else if (index === 1) {
                dispatch((0, _strokeStyle.changeStrokeColor2)(strokeColor));
            }
        },
        onChangeStrokeWidth: function onChangeStrokeWidth(strokeWidth) {
            dispatch((0, _strokeWidth.changeStrokeWidth)(strokeWidth));
        },
        onOpenColor: function onOpenColor() {
            dispatch((0, _modals.openStrokeColor)());
        },
        onCloseColor: function onCloseColor() {
            dispatch((0, _modals.closeStrokeColor)());
        },
        onChangeGradientType: function onChangeGradientType(gradientType) {
            dispatch((0, _strokeStyle.changeStrokeGradientType)(gradientType));
        },
        setSelectedItems: function setSelectedItems(format) {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), (0, _format.isBitmap)(format)));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(StrokeColorIndicator);

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactRedux = __webpack_require__(6);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _parseColor = __webpack_require__(43);

var _parseColor2 = _interopRequireDefault(_parseColor);

var _strokeStyle = __webpack_require__(31);

var _strokeWidth = __webpack_require__(32);

var _strokeWidthIndicator = __webpack_require__(236);

var _strokeWidthIndicator2 = _interopRequireDefault(_strokeWidthIndicator);

var _selection = __webpack_require__(3);

var _stylePath = __webpack_require__(9);

var _gradientTypes = __webpack_require__(15);

var _gradientTypes2 = _interopRequireDefault(_gradientTypes);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var StrokeWidthIndicator = function (_React$Component) {
    _inherits(StrokeWidthIndicator, _React$Component);

    function StrokeWidthIndicator(props) {
        _classCallCheck(this, StrokeWidthIndicator);

        var _this = _possibleConstructorReturn(this, (StrokeWidthIndicator.__proto__ || Object.getPrototypeOf(StrokeWidthIndicator)).call(this, props));

        (0, _lodash2.default)(_this, ['handleChangeStrokeWidth']);
        return _this;
    }

    _createClass(StrokeWidthIndicator, [{
        key: 'handleChangeStrokeWidth',
        value: function handleChangeStrokeWidth(newWidth) {
            var changed = (0, _stylePath.applyStrokeWidthToSelection)(newWidth, this.props.textEditTarget);
            if ((!this.props.strokeWidth || this.props.strokeWidth === 0) && newWidth > 0) {
                var currentColorState = (0, _stylePath.getColorsFromSelection)((0, _selection.getSelectedLeafItems)(), (0, _format.isBitmap)(this.props.format));

                // Color counts as null if either both colors are null or the primary color is null and it's solid
                // TODO: consolidate this check in one place
                var wasNull = currentColorState.strokeColor === null && (currentColorState.strokeColor2 === null || currentColorState.strokeGradientType === _gradientTypes2.default.SOLID);

                if (wasNull) {
                    changed = (0, _stylePath.applyColorToSelection)('#000', 0, // colorIndex,
                    true, // isSolidGradient
                    true, // applyToStroke
                    this.props.textEditTarget) || changed;
                    // If there's no previous stroke color, default to solid black
                    this.props.onChangeStrokeGradientType(_gradientTypes2.default.SOLID);
                    this.props.onChangeStrokeColor('#000');
                } else if (currentColorState.strokeColor !== _stylePath.MIXED) {
                    // Set color state from the selected item's stroke color
                    this.props.onChangeStrokeGradientType(currentColorState.strokeGradientType);
                    this.props.onChangeStrokeColor((0, _parseColor2.default)(currentColorState.strokeColor).hex);
                    this.props.onChangeStrokeColor2((0, _parseColor2.default)(currentColorState.strokeColor2).hex);
                }
            }
            this.props.onChangeStrokeWidth(newWidth);
            if (changed) this.props.onUpdateImage();
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(_strokeWidthIndicator2.default, {
                disabled: this.props.disabled,
                strokeWidth: this.props.strokeWidth,
                onChangeStrokeWidth: this.handleChangeStrokeWidth
            });
        }
    }]);

    return StrokeWidthIndicator;
}(_react2.default.Component);

var mapStateToProps = function mapStateToProps(state) {
    return {
        disabled: state.scratchPaint.mode === _modes2.default.BRUSH || state.scratchPaint.mode === _modes2.default.TEXT || state.scratchPaint.mode === _modes2.default.FILL,
        format: state.scratchPaint.format,
        strokeWidth: state.scratchPaint.color.strokeWidth,
        textEditTarget: state.scratchPaint.textEditTarget
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        onChangeStrokeColor: function onChangeStrokeColor(strokeColor) {
            dispatch((0, _strokeStyle.changeStrokeColor)(strokeColor));
        },
        onChangeStrokeColor2: function onChangeStrokeColor2(strokeColor) {
            dispatch((0, _strokeStyle.changeStrokeColor2)(strokeColor));
        },
        onChangeStrokeGradientType: function onChangeStrokeGradientType(strokeColor) {
            dispatch((0, _strokeStyle.changeStrokeGradientType)(strokeColor));
        },
        onChangeStrokeWidth: function onChangeStrokeWidth(strokeWidth) {
            dispatch((0, _strokeWidth.changeStrokeWidth)(strokeWidth));
        }
    };
};

StrokeWidthIndicator.propTypes = {
    disabled: _propTypes2.default.bool.isRequired,
    format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
    onChangeStrokeColor: _propTypes2.default.func.isRequired,
    onChangeStrokeColor2: _propTypes2.default.func.isRequired,
    onChangeStrokeGradientType: _propTypes2.default.func.isRequired,
    onChangeStrokeWidth: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    strokeWidth: _propTypes2.default.number,
    textEditTarget: _propTypes2.default.number
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(StrokeWidthIndicator);

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _input = __webpack_require__(55);

var _input2 = _interopRequireDefault(_input);

var _inputGroup = __webpack_require__(33);

var _inputGroup2 = _interopRequireDefault(_inputGroup);

var _liveInputHoc = __webpack_require__(91);

var _liveInputHoc2 = _interopRequireDefault(_liveInputHoc);

var _strokeWidth = __webpack_require__(32);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LiveInput = (0, _liveInputHoc2.default)(_input2.default);
var StrokeWidthIndicatorComponent = function StrokeWidthIndicatorComponent(props) {
    return _react2.default.createElement(
        _inputGroup2.default,
        { disabled: props.disabled },
        _react2.default.createElement(LiveInput, {
            range: true,
            small: true,
            disabled: props.disabled,
            max: _strokeWidth.MAX_STROKE_WIDTH,
            min: '0',
            type: 'number',
            value: props.strokeWidth ? props.strokeWidth : 0,
            onSubmit: props.onChangeStrokeWidth
        })
    );
};

StrokeWidthIndicatorComponent.propTypes = {
    disabled: _propTypes2.default.bool.isRequired,
    onChangeStrokeWidth: _propTypes2.default.func.isRequired,
    strokeWidth: _propTypes2.default.number
};

exports.default = StrokeWidthIndicatorComponent;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _fonts = __webpack_require__(46);

var _fonts2 = _interopRequireDefault(_fonts);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _colorStyleProptype = __webpack_require__(28);

var _colorStyleProptype2 = _interopRequireDefault(_colorStyleProptype);

var _stylePath = __webpack_require__(9);

var _font = __webpack_require__(57);

var _fillStyle = __webpack_require__(18);

var _strokeStyle = __webpack_require__(31);

var _modes3 = __webpack_require__(10);

var _textEditTarget = __webpack_require__(44);

var _selectedItems = __webpack_require__(7);

var _cursor = __webpack_require__(25);

var _selection = __webpack_require__(3);

var _textTool = __webpack_require__(238);

var _textTool2 = _interopRequireDefault(_textTool);

var _textMode = __webpack_require__(239);

var _textMode2 = _interopRequireDefault(_textMode);

var _bitTextMode = __webpack_require__(241);

var _bitTextMode2 = _interopRequireDefault(_bitTextMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TextMode = function (_React$Component) {
    _inherits(TextMode, _React$Component);

    function TextMode(props) {
        _classCallCheck(this, TextMode);

        var _this = _possibleConstructorReturn(this, (TextMode.__proto__ || Object.getPrototypeOf(TextMode)).call(this, props));

        (0, _lodash2.default)(_this, ['activateTool', 'deactivateTool']);
        return _this;
    }

    _createClass(TextMode, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.isTextModeActive) {
                this.activateTool(this.props);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.tool) {
                if (nextProps.colorState !== this.props.colorState) {
                    this.tool.setColorState(nextProps.colorState);
                }
                if (nextProps.selectedItems !== this.props.selectedItems) {
                    this.tool.onSelectionChanged(nextProps.selectedItems);
                }
                if (!nextProps.textEditTarget && this.props.textEditTarget) {
                    this.tool.onTextEditCancelled();
                }
                if (!nextProps.viewBounds.equals(this.props.viewBounds)) {
                    this.tool.onViewBoundsChanged(nextProps.viewBounds);
                }
                if (nextProps.font !== this.props.font) {
                    this.tool.setFont(nextProps.font);
                }
                if (nextProps.rtl !== this.props.rtl) {
                    this.tool.setRtl(nextProps.rtl);
                }
            }

            if (nextProps.isTextModeActive && !this.props.isTextModeActive) {
                this.activateTool(nextProps);
            } else if (!nextProps.isTextModeActive && this.props.isTextModeActive) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps) {
            return nextProps.isTextModeActive !== this.props.isTextModeActive;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.tool) {
                this.deactivateTool();
            }
        }
    }, {
        key: 'activateTool',
        value: function activateTool(nextProps) {
            var selected = (0, _selection.getSelectedLeafItems)();
            var textBoxToStartEditing = null;
            if (selected.length === 1 && selected[0] instanceof _paper2.default.PointText) {
                textBoxToStartEditing = selected[0];
            }
            (0, _selection.clearSelection)(this.props.clearSelectedItems);
            this.props.clearGradient();

            // If fill and stroke color are both mixed/transparent/absent, set fill to default and stroke to transparent.
            // If exactly one of fill or stroke color is set, set the other one to transparent.
            // This way the tool won't draw an invisible state, or be unclear about what will be drawn.
            var strokeWidth = nextProps.colorState.strokeWidth;

            var fillColor = nextProps.colorState.fillColor.primary;
            var strokeColor = nextProps.colorState.strokeColor.primary;
            var fillColorPresent = fillColor !== _stylePath.MIXED && fillColor !== null;
            var strokeColorPresent = nextProps.isBitmap ? false : strokeColor !== _stylePath.MIXED && strokeColor !== null && strokeWidth !== null && strokeWidth !== 0;
            if (!fillColorPresent && !strokeColorPresent) {
                this.props.onChangeFillColor(_fillStyle.DEFAULT_COLOR);
                this.props.onChangeStrokeColor(null);
            } else if (!fillColorPresent && strokeColorPresent) {
                this.props.onChangeFillColor(null);
            } else if (fillColorPresent && !strokeColorPresent) {
                this.props.onChangeStrokeColor(null);
            }
            if (!nextProps.font || Object.keys(_fonts2.default).map(function (key) {
                return _fonts2.default[key];
            }).indexOf(nextProps.font) < 0) {
                this.props.changeFont(_fonts2.default.SANS_SERIF);
            }

            this.tool = new _textTool2.default(this.props.textArea, this.props.setSelectedItems, this.props.clearSelectedItems, this.props.setCursor, this.props.onUpdateImage, this.props.setTextEditTarget, this.props.changeFont, nextProps.isBitmap);
            this.tool.setRtl(this.props.rtl);
            this.tool.setColorState(nextProps.colorState);
            this.tool.setFont(nextProps.font);
            this.tool.activate();
            if (textBoxToStartEditing) {
                this.tool.beginTextEdit(textBoxToStartEditing);
                this.props.textArea.select();
            }
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            this.tool.deactivateTool();
            this.tool.remove();
            this.tool = null;
        }
    }, {
        key: 'render',
        value: function render() {
            return this.props.isBitmap ? _react2.default.createElement(_bitTextMode2.default, {
                isSelected: this.props.isTextModeActive,
                onMouseDown: this.props.handleChangeModeBitText
            }) : _react2.default.createElement(_textMode2.default, {
                isSelected: this.props.isTextModeActive,
                onMouseDown: this.props.handleChangeModeText
            });
        }
    }]);

    return TextMode;
}(_react2.default.Component);

TextMode.propTypes = {
    changeFont: _propTypes2.default.func.isRequired,
    clearGradient: _propTypes2.default.func.isRequired,
    clearSelectedItems: _propTypes2.default.func.isRequired,
    colorState: _propTypes2.default.shape({
        fillColor: _colorStyleProptype2.default,
        strokeColor: _colorStyleProptype2.default,
        strokeWidth: _propTypes2.default.number
    }).isRequired,
    font: _propTypes2.default.string,
    handleChangeModeBitText: _propTypes2.default.func.isRequired,
    handleChangeModeText: _propTypes2.default.func.isRequired,
    isBitmap: _propTypes2.default.bool,
    isTextModeActive: _propTypes2.default.bool.isRequired,
    onChangeFillColor: _propTypes2.default.func.isRequired,
    onChangeStrokeColor: _propTypes2.default.func.isRequired,
    onUpdateImage: _propTypes2.default.func.isRequired,
    rtl: _propTypes2.default.bool,
    selectedItems: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_paper2.default.Item)),
    setCursor: _propTypes2.default.func.isRequired,
    setSelectedItems: _propTypes2.default.func.isRequired,
    setTextEditTarget: _propTypes2.default.func.isRequired,
    textArea: _propTypes2.default.instanceOf(Element),
    textEditTarget: _propTypes2.default.number,
    viewBounds: _propTypes2.default.instanceOf(_paper2.default.Matrix).isRequired
};

var mapStateToProps = function mapStateToProps(state, ownProps) {
    return {
        colorState: state.scratchPaint.color,
        font: state.scratchPaint.font,
        isTextModeActive: ownProps.isBitmap ? state.scratchPaint.mode === _modes2.default.BIT_TEXT : state.scratchPaint.mode === _modes2.default.TEXT,
        rtl: state.scratchPaint.layout.rtl,
        selectedItems: state.scratchPaint.selectedItems,
        textEditTarget: state.scratchPaint.textEditTarget,
        viewBounds: state.scratchPaint.viewBounds
    };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch, ownProps) {
    return {
        changeFont: function changeFont(font) {
            dispatch((0, _font.changeFont)(font));
        },
        clearSelectedItems: function clearSelectedItems() {
            dispatch((0, _selectedItems.clearSelectedItems)());
        },
        clearGradient: function clearGradient() {
            dispatch((0, _fillStyle.clearFillGradient)());
        },
        handleChangeModeBitText: function handleChangeModeBitText() {
            dispatch((0, _modes3.changeMode)(_modes2.default.BIT_TEXT));
        },
        handleChangeModeText: function handleChangeModeText() {
            dispatch((0, _modes3.changeMode)(_modes2.default.TEXT));
        },
        setCursor: function setCursor(cursorString) {
            dispatch((0, _cursor.setCursor)(cursorString));
        },
        setSelectedItems: function setSelectedItems() {
            dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), ownProps.isBitmap));
        },
        setTextEditTarget: function setTextEditTarget(targetId) {
            dispatch((0, _textEditTarget.setTextEditTarget)(targetId));
        },
        onChangeFillColor: function onChangeFillColor(fillColor) {
            dispatch((0, _fillStyle.changeFillColor)(fillColor));
        },
        onChangeStrokeColor: function onChangeStrokeColor(strokeColor) {
            dispatch((0, _strokeStyle.changeStrokeColor)(strokeColor));
        }
    };
};

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(TextMode);

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _selection = __webpack_require__(3);

var _boundingBoxTool = __webpack_require__(29);

var _boundingBoxTool2 = _interopRequireDefault(_boundingBoxTool);

var _nudgeTool = __webpack_require__(30);

var _nudgeTool2 = _interopRequireDefault(_nudgeTool);

var _guides = __webpack_require__(27);

var _layer = __webpack_require__(12);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tool for adding text. Text elements have limited editability; they can't be reshaped,
 * drawn on or erased. This way they can preserve their ability to have the text edited.
 */
var TextTool = function (_paper$Tool) {
    _inherits(TextTool, _paper$Tool);

    _createClass(TextTool, null, [{
        key: 'TOLERANCE',
        get: function get() {
            return 2;
        }
    }, {
        key: 'TEXT_EDIT_MODE',
        get: function get() {
            return 'TEXT_EDIT_MODE';
        }
    }, {
        key: 'SELECT_MODE',
        get: function get() {
            return 'SELECT_MODE';
        }
        /** Clicks registered within this amount of time are registered as double clicks */

    }, {
        key: 'DOUBLE_CLICK_MILLIS',
        get: function get() {
            return 250;
        }
        /** Typing with no pauses longer than this amount of type will count as 1 action */

    }, {
        key: 'TYPING_TIMEOUT_MILLIS',
        get: function get() {
            return 1000;
        }
    }, {
        key: 'TEXT_PADDING',
        get: function get() {
            return 8;
        }
        /**
         * @param {HTMLTextAreaElement} textAreaElement dom element for the editable text field
         * @param {function} setSelectedItems Callback to set the set of selected items in the Redux state
         * @param {function} clearSelectedItems Callback to clear the set of selected items in the Redux state
         * @param {function} setCursor Callback to set the visible mouse cursor
         * @param {!function} onUpdateImage A callback to call when the image visibly changes
         * @param {!function} setTextEditTarget Call to set text editing target whenever text editing is active
         * @param {!function} changeFont Call to change the font in the dropdown
         * @param {?boolean} isBitmap True if text should be rasterized once it's deselected
         */

    }]);

    function TextTool(textAreaElement, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage, setTextEditTarget, changeFont, isBitmap) {
        _classCallCheck(this, TextTool);

        var _this = _possibleConstructorReturn(this, (TextTool.__proto__ || Object.getPrototypeOf(TextTool)).call(this));

        _this.element = textAreaElement;
        _this.setSelectedItems = setSelectedItems;
        _this.clearSelectedItems = clearSelectedItems;
        _this.onUpdateImage = onUpdateImage;
        _this.setTextEditTarget = setTextEditTarget;
        _this.changeFont = changeFont;
        var paintMode = isBitmap ? _modes2.default.BIT_TEXT : _modes2.default.TEXT;
        _this.boundingBoxTool = new _boundingBoxTool2.default(paintMode, setSelectedItems, clearSelectedItems, setCursor, onUpdateImage);
        _this.nudgeTool = new _nudgeTool2.default(paintMode, _this.boundingBoxTool, onUpdateImage);
        _this.isBitmap = isBitmap;

        // We have to set these functions instead of just declaring them because
        // paper.js tools hook up the listeners in the setter functions.
        _this.onMouseDown = _this.handleMouseDown;
        _this.onMouseDrag = _this.handleMouseDrag;
        _this.onMouseUp = _this.handleMouseUp;
        _this.onMouseMove = _this.handleMouseMove;
        _this.onKeyUp = _this.handleKeyUp;
        _this.onKeyDown = _this.handleKeyDown;

        _this.textBox = null;
        _this.guide = null;
        _this.colorState = null;
        _this.mode = null;
        _this.active = false;
        _this.lastTypeEvent = null;
        _this.lastEvent = null;

        // If text selected and then activate this tool, switch to text edit mode for that text
        // If double click on text while in select mode, does mode change to text mode? Text fully selected by default
        return _this;
    }

    _createClass(TextTool, [{
        key: 'getBoundingBoxHitOptions',
        value: function getBoundingBoxHitOptions() {
            return {
                segments: true,
                stroke: true,
                curves: true,
                fill: true,
                guide: false,
                match: function match(hitResult) {
                    return hitResult.item.data && (hitResult.item.data.isScaleHandle || hitResult.item.data.isRotHandle) || hitResult.item.selected;
                }, // Allow hits on bounding box and selected only
                tolerance: TextTool.TOLERANCE / _paper2.default.view.zoom
            };
        }
    }, {
        key: 'getTextEditHitOptions',
        value: function getTextEditHitOptions() {
            return {
                class: _paper2.default.PointText,
                segments: true,
                stroke: true,
                curves: true,
                fill: true,
                guide: false,
                match: function match(hitResult) {
                    return hitResult.item && !(hitResult.item.data && hitResult.item.data.isHelperItem) && !hitResult.item.selected;
                }, // Unselected only
                tolerance: TextTool.TOLERANCE / _paper2.default.view.zoom
            };
        }
        /**
         * Called when the selection changes to update the bounds of the bounding box.
         * @param {Array<paper.Item>} selectedItems Array of selected items.
         */

    }, {
        key: 'onSelectionChanged',
        value: function onSelectionChanged(selectedItems) {
            this.boundingBoxTool.onSelectionChanged(selectedItems);
            if ((!this.textBox || !this.textBox.parent) && selectedItems && selectedItems.length === 1 && selectedItems[0] instanceof _paper2.default.PointText) {
                // Infer that an undo occurred and get back the active text
                this.textBox = selectedItems[0];
                this.mode = TextTool.SELECT_MODE;
            }
        }
    }, {
        key: 'setFont',
        value: function setFont(font) {
            this.font = font;
            if (this.textBox) {
                this.textBox.font = font;
            }
            var selected = (0, _selection.getSelectedLeafItems)();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = selected[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var item = _step.value;

                    if (item instanceof _paper2.default.PointText) {
                        item.font = font;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.element.style.fontFamily = font;
            this.setSelectedItems();
        }
        // Allow other tools to cancel text edit mode

    }, {
        key: 'onTextEditCancelled',
        value: function onTextEditCancelled() {
            if (this.mode !== TextTool.TEXT_EDIT_MODE) {
                return;
            }
            this.endTextEdit();
            this.beginSelect();
        }
        /**
         * Called when the view matrix changes
         * @param {paper.Matrix} viewMtx applied to paper.view
         */

    }, {
        key: 'onViewBoundsChanged',
        value: function onViewBoundsChanged(viewMtx) {
            if (this.mode !== TextTool.TEXT_EDIT_MODE) {
                return;
            }
            this.calculateMatrix(viewMtx);
        }
    }, {
        key: 'calculateMatrix',
        value: function calculateMatrix(viewMtx) {
            var textBoxMtx = this.textBox.matrix;
            var calculated = new _paper2.default.Matrix();

            // In RTL, the element is moved relative to its parent's right edge instead of its left
            // edge. We need to correct for this in order for the element to overlap the object in paper.
            var tx = 0;
            if (this.rtl && this.element.parentElement) {
                tx = -this.element.parentElement.clientWidth;
            }
            // The transform origin in paper is x at justification side, y at the baseline of the text.
            // The offset from (0, 0) to the upper left corner is recorded by internalBounds
            // (so this.textBox.internalBounds.y is negative).
            // Move the transform origin down to the text baseline to match paper
            this.element.style.transformOrigin = -this.textBox.internalBounds.x + 'px ' + -this.textBox.internalBounds.y + 'px';
            // Start by translating the element up so that its (0, 0) is now at the text baseline, like in paper
            calculated.translate(tx, this.textBox.internalBounds.y);
            calculated.append(viewMtx);
            calculated.append(textBoxMtx);
            this.element.style.transform = 'matrix(' + calculated.a + ', ' + calculated.b + ', ' + calculated.c + ', ' + calculated.d + ',\n             ' + calculated.tx + ', ' + calculated.ty + ')';
        }
    }, {
        key: 'setColorState',
        value: function setColorState(colorState) {
            this.colorState = colorState;
        }
        /** @param {boolean} isRtl True if paint editor is in right-to-left layout (e.g. Hebrew language) */

    }, {
        key: 'setRtl',
        value: function setRtl(isRtl) {
            this.rtl = isRtl;
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            var hitResults = _paper2.default.project.hitTestAll(event.point, this.getTextEditHitOptions());
            if (hitResults.length) {
                document.body.style.cursor = 'text';
            } else {
                document.body.style.cursor = 'auto';
            }
            this.boundingBoxTool.onMouseMove(event, this.getBoundingBoxHitOptions());
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            if (event.event.button > 0) return; // only first mouse button
            this.active = true;

            // Check if double clicked
            var doubleClicked = this.lastEvent && event.event.timeStamp - this.lastEvent.event.timeStamp < TextTool.DOUBLE_CLICK_MILLIS;
            this.lastEvent = event;
            if (doubleClicked && this.mode === TextTool.SELECT_MODE && this.textBox.hitTest(event.point)) {
                // Double click in select mode moves you to text edit mode
                this.endSelect();
                this.beginTextEdit(this.textBox);
                this.element.select();
                return;
            }

            // In select mode staying in select mode
            if (this.boundingBoxTool.onMouseDown(event, false /* clone */, false /* multiselect */, false /* doubleClicked */
            , this.getBoundingBoxHitOptions())) {
                return;
            }

            // We clicked away from the item, so end the current mode
            var lastMode = this.mode;
            if (this.mode === TextTool.SELECT_MODE) {
                this.endSelect();
                if (this.isBitmap) {
                    this.commitText();
                }
            } else if (this.mode === TextTool.TEXT_EDIT_MODE) {
                this.endTextEdit();
            }

            var hitResults = _paper2.default.project.hitTestAll(event.point, this.getTextEditHitOptions());
            if (hitResults.length) {
                // Clicking a different text item to begin text edit mode on that item
                this.beginTextEdit(hitResults[0].item);
            } else if (lastMode === TextTool.TEXT_EDIT_MODE) {
                // In text mode clicking away to begin select mode
                this.beginSelect();
            } else {
                // In no mode or select mode clicking away to begin text edit mode
                this.textBox = new _paper2.default.PointText({
                    point: event.point,
                    content: '',
                    font: this.font,
                    fontSize: 40,
                    // TODO: style using gradient
                    // https://github.com/LLK/scratch-paint/issues/1164
                    fillColor: this.colorState.fillColor.primary,
                    // Default leading for both the HTML text area and paper.PointText
                    // is 120%, but for some reason they are slightly off from each other.
                    // This value was obtained experimentally.
                    leading: 46.15
                });
                this.beginTextEdit(this.textBox);
            }
        }
    }, {
        key: 'handleMouseDrag',
        value: function handleMouseDrag(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.mode === TextTool.SELECT_MODE) {
                this.boundingBoxTool.onMouseDrag(event);
                return;
            }
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            if (event.event.button > 0 || !this.active) return; // only first mouse button

            if (this.mode === TextTool.SELECT_MODE) {
                this.boundingBoxTool.onMouseUp(event);
                this.isBoundingBoxMode = null;
                return;
            }

            this.active = false;
        }
    }, {
        key: 'handleKeyUp',
        value: function handleKeyUp(event) {
            if (event.event.target instanceof HTMLInputElement) {
                // Ignore nudge if a text input field is focused
                return;
            }

            if (this.mode === TextTool.SELECT_MODE) {
                this.nudgeTool.onKeyUp(event);
            }
        }
    }, {
        key: 'handleKeyDown',
        value: function handleKeyDown(event) {
            if (event.event.target instanceof HTMLInputElement) {
                // Ignore nudge if a text input field is focused
                return;
            }
            if (this.mode === TextTool.TEXT_EDIT_MODE && event.key === 'escape') {
                this.endTextEdit();
            }
            if (this.mode === TextTool.SELECT_MODE) {
                this.nudgeTool.onKeyDown(event);
            }
        }
    }, {
        key: 'handleTextInput',
        value: function handleTextInput(event) {
            // Save undo state if you paused typing for long enough.
            if (this.lastTypeEvent && event.timeStamp - this.lastTypeEvent.timeStamp > TextTool.TYPING_TIMEOUT_MILLIS) {
                // Select the textbox so that it will be selected if the user performs undo.
                this.textBox.selected = true;
                this.onUpdateImage();
                this.textBox.selected = false;
            }
            this.lastTypeEvent = event;
            if (this.mode === TextTool.TEXT_EDIT_MODE) {
                this.textBox.content = this.element.value;
            }
            this.resizeGuide();
        }
    }, {
        key: 'resizeGuide',
        value: function resizeGuide() {
            if (this.guide) this.guide.remove();
            this.guide = (0, _guides.hoverBounds)(this.textBox, TextTool.TEXT_PADDING);
            this.guide.dashArray = [4, 4];
            // Prevent line from wrapping
            this.element.style.width = this.textBox.internalBounds.width + 1 + 'px';
            this.element.style.height = this.textBox.internalBounds.height + 'px';
            // The transform origin needs to be updated in RTL because this.textBox.internalBounds.x
            // changes as you type
            if (this.rtl) {
                this.element.style.transformOrigin = -this.textBox.internalBounds.x + 'px ' + -this.textBox.internalBounds.y + 'px';
            }
        }
    }, {
        key: 'beginSelect',
        value: function beginSelect() {
            if (this.textBox) {
                this.mode = TextTool.SELECT_MODE;
                this.textBox.selected = true;
                this.setSelectedItems();
            }
        }
    }, {
        key: 'endSelect',
        value: function endSelect() {
            (0, _selection.clearSelection)(this.clearSelectedItems);
            this.mode = null;
        }
        /**
         * @param {paper.PointText} textBox Text object to begin text edit on
         */

    }, {
        key: 'beginTextEdit',
        value: function beginTextEdit(textBox) {
            this.textBox = textBox;
            this.mode = TextTool.TEXT_EDIT_MODE;
            this.setTextEditTarget(this.textBox.id);
            if (this.font !== this.textBox.font) {
                this.changeFont(this.textBox.font);
            }
            this.element.style.fontSize = this.textBox.fontSize + 'px';
            this.element.style.lineHeight = this.textBox.leading / this.textBox.fontSize;

            this.element.style.display = 'initial';
            this.element.value = textBox.content ? textBox.content : '';
            this.calculateMatrix(_paper2.default.view.matrix);

            if (this.rtl) {
                // make both the textbox and the textarea element grow to the left
                this.textBox.justification = 'right';
            } else {
                this.textBox.justification = 'left';
            }

            this.element.focus({ preventScroll: true });
            this.eventListener = this.handleTextInput.bind(this);
            this.element.addEventListener('input', this.eventListener);
            this.resizeGuide();
        }
    }, {
        key: 'endTextEdit',
        value: function endTextEdit() {
            if (this.mode !== TextTool.TEXT_EDIT_MODE) {
                return;
            }
            this.mode = null;

            // Remove invisible textboxes
            if (this.textBox && this.textBox.content.trim() === '') {
                this.textBox.remove();
                this.textBox = null;
            }

            // Remove guide
            if (this.guide) {
                this.guide.remove();
                this.guide = null;
                this.setTextEditTarget();
            }
            this.element.style.display = 'none';
            if (this.eventListener) {
                this.element.removeEventListener('input', this.eventListener);
                this.eventListener = null;
            }
            if (this.textBox && this.lastTypeEvent) {
                // Finished editing a textbox, save undo state
                // Select the textbox so that it will be selected if the user performs undo.
                this.textBox.selected = true;
                this.onUpdateImage();
                this.textBox.selected = false;
                this.lastTypeEvent = null;
            }
        }
    }, {
        key: 'commitText',
        value: function commitText() {
            if (!this.textBox || !this.textBox.parent) return;

            // @todo get crisp text https://github.com/LLK/scratch-paint/issues/508
            var textRaster = this.textBox.rasterize(72, false /* insert */, this.textBox.drawnBounds);
            this.textBox.remove();
            this.textBox = null;
            (0, _layer.getRaster)().drawImage(textRaster.canvas, new _paper2.default.Point(Math.floor(textRaster.bounds.x), Math.floor(textRaster.bounds.y)));
            this.onUpdateImage();
        }
    }, {
        key: 'deactivateTool',
        value: function deactivateTool() {
            if (this.textBox && this.textBox.content.trim() === '') {
                this.textBox.remove();
                this.textBox = null;
            }
            this.endTextEdit();
            if (this.isBitmap) {
                this.commitText();
            }
            this.boundingBoxTool.deactivateTool();
        }
    }]);

    return TextTool;
}(_paper2.default.Tool);

exports.default = TextTool;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _text = __webpack_require__(240);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TextModeComponent = function TextModeComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.text,
        imgSrc: _text2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

TextModeComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = TextModeComponent;

/***/ }),
/* 240 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Etext%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='text' fill='%23575E75'%3E %3Cpath d='M16,4.35294118 L16,6.85176471 C16,7.04941176 15.8447059,7.20470588 15.6470588,7.20470588 L14.8988235,7.20470588 C14.7576471,7.20470588 14.6164706,7.12 14.5741176,6.99294118 L14.2070588,6.11764706 L11.0588235,6.11764706 L11.0588235,14.2917647 L11.92,14.6164706 C12.0611765,14.6729412 12.16,14.8 12.16,14.9552941 L12.16,15.6470588 C12.16,15.8447059 11.9905882,16 11.8070588,16 L8.20705882,16 C8.02352941,16 7.85411765,15.8447059 7.85411765,15.6470588 L7.85411765,14.9552941 C7.85411765,14.8 7.95294118,14.6729412 8.08,14.6164706 L8.94117647,14.2917647 L8.94117647,6.11764706 L5.80705882,6.11764706 L5.44,6.99294118 C5.38352941,7.12 5.25647059,7.20470588 5.11529412,7.20470588 L4.35294118,7.20470588 C4.16941176,7.20470588 4,7.04941176 4,6.85176471 L4,4.35294118 C4,4.15529412 4.16941176,4 4.35294118,4 L15.6470588,4 C15.8447059,4 16,4.15529412 16,4.35294118' id='text-icon'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _toolSelectBase = __webpack_require__(16);

var _toolSelectBase2 = _interopRequireDefault(_toolSelectBase);

var _messages = __webpack_require__(17);

var _messages2 = _interopRequireDefault(_messages);

var _text = __webpack_require__(242);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BitTextComponent = function BitTextComponent(props) {
    return _react2.default.createElement(_toolSelectBase2.default, {
        imgDescriptor: _messages2.default.text,
        imgSrc: _text2.default,
        isSelected: props.isSelected,
        onMouseDown: props.onMouseDown
    });
};

BitTextComponent.propTypes = {
    isSelected: _propTypes2.default.bool.isRequired,
    onMouseDown: _propTypes2.default.func.isRequired
};

exports.default = BitTextComponent;

/***/ }),
/* 242 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Etext%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='text' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cpolygon id='Page-1' fill='%23575E75' points='4 4 4 8 6 8 6 6 9 6 9 14 7 14 7 16 13 16 13 14 11 14 11 6 14 6 14 8 16 8 16 4'%3E%3C/polygon%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(13);
            var content = __webpack_require__(244);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(14);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* DO NOT EDIT\n@todo This file is copied from GUI and should be pulled out into a shared library.\nSee https://github.com/LLK/scratch-paint/issues/13 */\n\n/* ACTUALLY, THIS IS EDITED ;)\nTHIS WAS CHANGED ON 10/25/2017 BY @mewtaylor TO ADD A VARIABLE FOR THE SMALLEST\nGRID UNITS.\n\nALSO EDITED ON 11/13/2017 TO ADD IN CONTANTS FOR LAYOUT FROM `layout-contents.js`*/\n\n/* layout contants from `layout-constants.js`, minus 1px */\n\n.paint-editor_editor-container_3ajxi {\n    width: 100%;\n    height: 100%;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: column;\n        -ms-flex-direction: column;\n            flex-direction: column;\n    padding: calc(3 * .25rem);\n}\n\n.paint-editor_row_1psvV {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n        -ms-flex-direction: row;\n            flex-direction: row;\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n\n.paint-editor_editor-container-top_23HHq {\n    border-bottom: 1px dashed #D9D9D9;\n    padding-bottom: calc(2 * .25rem);\n}\n\n.paint-editor_top-align-row_2Ky-F {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n        -ms-flex-direction: row;\n            flex-direction: row;\n    height: 100%;\n    padding-top: calc(5 * .25rem);\n    min-width: 524px;\n}\n\n.paint-editor_row_1psvV + .paint-editor_row_1psvV {\n    margin-top: calc(2 * .25rem);\n}\n\n[dir=\"ltr\"] .paint-editor_mod-dashed-border_1xeKo {\n    border-right: 1px dashed #D9D9D9;\n    padding-right: calc(2 * .25rem);\n}\n\n[dir=\"rtl\"] .paint-editor_mod-dashed-border_1xeKo {\n    border-left: 1px dashed #D9D9D9;\n    padding-left: calc(2 * .25rem);\n}\n\n.paint-editor_mod-labeled-icon-height_3hBCl {\n    height: 2.85rem; /* for the second row so the dashed borders are equal in size */\n}\n\n.paint-editor_button-group-button_1gq5A {\n    display: inline-block;\n    border: 1px solid #D9D9D9;\n    border-radius: 0;\n    padding: .35rem;\n}\n\n[dir=\"ltr\"] .paint-editor_button-group-button_1gq5A {\n    border-left: none;\n}\n\n[dir=\"rtl\"] .paint-editor_button-group-button_1gq5A {\n    border-right: none;\n}\n\n[dir=\"ltr\"] .paint-editor_button-group-button_1gq5A:last-of-type {\n    border-top-right-radius: 0.25rem;\n    border-bottom-right-radius: 0.25rem;\n}\n\n[dir=\"ltr\"] .paint-editor_button-group-button_1gq5A:first-of-type {\n    border-left: 1px solid #D9D9D9;\n    border-top-left-radius: 0.25rem;\n    border-bottom-left-radius: 0.25rem;\n}\n\n[dir=\"rtl\"] .paint-editor_button-group-button_1gq5A:last-of-type {\n    border-top-left-radius: 0.25rem;\n    border-bottom-left-radius: 0.25rem;\n}\n\n[dir=\"rtl\"] .paint-editor_button-group-button_1gq5A:first-of-type {\n    border-right: 1px solid #D9D9D9;\n    border-top-right-radius: 0.25rem;\n    border-bottom-right-radius: 0.25rem;\n}\n\n[dir=\"ltr\"] .paint-editor_button-group-button_1gq5A.paint-editor_mod-start-border_jVIRO {\n    border-left: 1px solid #D9D9D9;\n}\n\n[dir=\"rtl\"] .paint-editor_button-group-button_1gq5A.paint-editor_mod-start-border_jVIRO {\n    border-right: 1px solid #D9D9D9;\n}\n\n[dir=\"ltr\"].paint-editor_button-group-button_1gq5A.paint-editor_mod-no-end-border_XiRoc {\n    border-right: none;\n}\n\n[dir=\"rtl\"].paint-editor_button-group-button_1gq5A.paint-editor_mod-no-end-border_XiRoc {\n    border-left: none;\n}\n\n.paint-editor_button-group-button-icon_3BPxO {\n    width: 1.25rem;\n    height: 1.25rem;\n    vertical-align: middle;\n}\n\n.paint-editor_mod-mode-tools_1IXSj {\n    margin-left: calc(2 * .25rem);\n}\n\n[dir=\"ltr\"] .paint-editor_mod-margin-after_1OgHf {\n    margin-right: calc(2 * .25rem);\n}\n\n[dir=\"rtl\"] .paint-editor_mod-margin-after_1OgHf {\n    margin-left: calc(2 * .25rem);\n}\n\n.paint-editor_controls-container_3HDxz {\n    width: 100%;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n    -webkit-flex-flow: column;\n        -ms-flex-flow: column;\n            flex-flow: column;\n    -webkit-box-flex: 1;\n    -webkit-flex-grow: 1;\n        -ms-flex-positive: 1;\n            flex-grow: 1;\n    margin-left: calc(2 * .25rem);\n    margin-right: calc(2 * .25rem);\n}\n\n.paint-editor_canvas-container_2rN98 {\n    width: 100%;\n    -webkit-box-flex: 1;\n    -webkit-flex-grow: 1;\n        -ms-flex-positive: 1;\n            flex-grow: 1;\n    min-width: 402px; /* Leave room for the border */\n    -webkit-box-sizing: content-box;\n            box-sizing: content-box;\n    border: 1px solid #e8edf1;\n    border-radius: .25rem;\n    position: relative;\n    overflow: visible;\n}\n\n.paint-editor_mode-selector_1edhd {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    max-width: 7.5rem;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n    -webkit-flex-direction: row;\n        -ms-flex-direction: row;\n            flex-direction: row;\n    -webkit-flex-wrap: wrap;\n        -ms-flex-wrap: wrap;\n            flex-wrap: wrap;\n    -webkit-box-align: start;\n    -webkit-align-items: flex-start;\n        -ms-flex-align: start;\n            align-items: flex-start;\n    -webkit-align-content: flex-start;\n        -ms-flex-line-pack: start;\n            align-content: flex-start;\n    -webkit-box-pack: justify;\n    -webkit-justify-content: space-between;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n}\n\n.paint-editor_zoom-controls_3Qe-- {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: reverse;\n    -webkit-flex-direction: row-reverse;\n        -ms-flex-direction: row-reverse;\n            flex-direction: row-reverse;\n}\n\n.paint-editor_color-picker-wrapper_1IC0W {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n}\n\n.paint-editor_canvas-controls_e2K-q {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    height: 36px;\n    margin-top: .25rem;\n    -webkit-box-pack: justify;\n    -webkit-justify-content: space-between;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n}\n\n.paint-editor_bitmap-button_GsX3L {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n    border-radius: 5px;\n    background-color: #4C97FF;\n    padding: calc(2 * .25rem);\n    line-height: 1.5rem;\n    font-size: calc(3 * .25rem);\n    font-weight: bold;\n    color: white;\n    -webkit-box-pack: center;\n    -webkit-justify-content: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n}\n\n[dir=\"ltr\"] .paint-editor_bitmap-button-icon_wPoPh {\n    margin-right: calc(2 * .25rem);\n}\n\n[dir=\"rtl\"] .paint-editor_bitmap-button-icon_wPoPh {\n    margin-left: calc(2 * .25rem);\n}\n\n@media only screen and (max-width: 1256px) {\n    .paint-editor_editor-container_3ajxi {\n        padding: calc(3 * .25rem) .25rem;\n    }\n\n    .paint-editor_mode-selector_1edhd {\n        -webkit-box-orient: vertical;\n        -webkit-box-direction: normal;\n        -webkit-flex-direction: column;\n            -ms-flex-direction: column;\n                flex-direction: column;\n        -webkit-box-pack: start;\n        -webkit-justify-content: flex-start;\n            -ms-flex-pack: start;\n                justify-content: flex-start;\n    }\n\n    .paint-editor_controls-container_3HDxz {\n        margin-right: .25rem;\n        margin-left: .25rem;\n    }\n}\n\n.paint-editor_text-area_3VRLj {\n    background: transparent;\n    border: none;\n    display: none;\n    margin: 0px;\n    opacity: .8;\n    outline: none;\n    overflow: hidden;\n    padding: 0px;\n    position: absolute;\n    resize: none;\n    -webkit-text-fill-color: transparent;\n    text-fill-color: transparent;\n}\n\n.paint-editor_button-text_2sm18 {\n    width: 100%; /* Fixes button text wrapping in Edge */\n}\n", ""]);
// Exports
exports.locals = {
	"editor-container": "paint-editor_editor-container_3ajxi",
	"editorContainer": "paint-editor_editor-container_3ajxi",
	"row": "paint-editor_row_1psvV",
	"editor-container-top": "paint-editor_editor-container-top_23HHq",
	"editorContainerTop": "paint-editor_editor-container-top_23HHq",
	"top-align-row": "paint-editor_top-align-row_2Ky-F",
	"topAlignRow": "paint-editor_top-align-row_2Ky-F",
	"mod-dashed-border": "paint-editor_mod-dashed-border_1xeKo",
	"modDashedBorder": "paint-editor_mod-dashed-border_1xeKo",
	"mod-labeled-icon-height": "paint-editor_mod-labeled-icon-height_3hBCl",
	"modLabeledIconHeight": "paint-editor_mod-labeled-icon-height_3hBCl",
	"button-group-button": "paint-editor_button-group-button_1gq5A",
	"buttonGroupButton": "paint-editor_button-group-button_1gq5A",
	"mod-start-border": "paint-editor_mod-start-border_jVIRO",
	"modStartBorder": "paint-editor_mod-start-border_jVIRO",
	"mod-no-end-border": "paint-editor_mod-no-end-border_XiRoc",
	"modNoEndBorder": "paint-editor_mod-no-end-border_XiRoc",
	"button-group-button-icon": "paint-editor_button-group-button-icon_3BPxO",
	"buttonGroupButtonIcon": "paint-editor_button-group-button-icon_3BPxO",
	"mod-mode-tools": "paint-editor_mod-mode-tools_1IXSj",
	"modModeTools": "paint-editor_mod-mode-tools_1IXSj",
	"mod-margin-after": "paint-editor_mod-margin-after_1OgHf",
	"modMarginAfter": "paint-editor_mod-margin-after_1OgHf",
	"controls-container": "paint-editor_controls-container_3HDxz",
	"controlsContainer": "paint-editor_controls-container_3HDxz",
	"canvas-container": "paint-editor_canvas-container_2rN98",
	"canvasContainer": "paint-editor_canvas-container_2rN98",
	"mode-selector": "paint-editor_mode-selector_1edhd",
	"modeSelector": "paint-editor_mode-selector_1edhd",
	"zoom-controls": "paint-editor_zoom-controls_3Qe--",
	"zoomControls": "paint-editor_zoom-controls_3Qe--",
	"color-picker-wrapper": "paint-editor_color-picker-wrapper_1IC0W",
	"colorPickerWrapper": "paint-editor_color-picker-wrapper_1IC0W",
	"canvas-controls": "paint-editor_canvas-controls_e2K-q",
	"canvasControls": "paint-editor_canvas-controls_e2K-q",
	"bitmap-button": "paint-editor_bitmap-button_GsX3L",
	"bitmapButton": "paint-editor_bitmap-button_GsX3L",
	"bitmap-button-icon": "paint-editor_bitmap-button-icon_wPoPh",
	"bitmapButtonIcon": "paint-editor_bitmap-button-icon_wPoPh",
	"text-area": "paint-editor_text-area_3VRLj",
	"textArea": "paint-editor_text-area_3VRLj",
	"button-text": "paint-editor_button-text_2sm18",
	"buttonText": "paint-editor_button-text_2sm18"
};
module.exports = exports;


/***/ }),
/* 245 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg width='20px' height='20px' viewBox='0 0 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 47.1 (45422) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3Ebitmap%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='bitmap' fill='%23FFFFFF'%3E %3Cpath d='M4,3 L16,3 L16,4 L4,4 L4,3 Z M2,5 L3,5 L3,13 L2,13 L2,5 Z M17,5 L18,5 L18,13 L17,13 L17,5 Z M2,13 L18,13 L18,15 L2,15 L2,13 Z M4,12 L16,12 L16,13 L4,13 L4,12 Z M5,11 L8,11 L8,12 L5,12 L5,11 Z M6,10 L7,10 L7,11 L6,11 L6,10 Z M9,11 L16,11 L16,12 L9,12 L9,11 Z M10,10 L15,10 L15,11 L10,11 L10,10 Z M11,9 L14,9 L14,10 L11,10 L11,9 Z M12,8 L13,8 L13,9 L12,9 L12,8 Z M16,12 L17,12 L17,13 L16,13 L16,12 Z M3,15 L17,15 L17,16 L3,16 L3,15 Z M3,4 L4,4 L4,5 L3,5 L3,4 Z M16,4 L17,4 L17,5 L16,5 L16,4 Z M4,16 L16,16 L16,17 L4,17 L4,16 Z' id='Combined-Shape'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 246 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0'?%3E %3Csvg xmlns='http://www.w3.org/2000/svg' id='Layer_1' data-name='Layer 1' viewBox='6 6 24 24'%3E %3Cdefs%3E %3Cstyle%3E .cls-4%7Bfill:none;stroke:%23575e75;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px;%7D %3C/style%3E %3C/defs%3E %3Ctitle%3Ezoom-in%3C/title%3E %3Cg class='cls-3'%3E %3Ccircle class='cls-4' cx='18' cy='18' r='7'/%3E %3Cline class='cls-4' x1='23' y1='23' x2='26' y2='26'/%3E %3Cline class='cls-4' x1='16' y1='18' x2='20' y2='18'/%3E %3Cline class='cls-4' x1='18' y1='16' x2='18' y2='20'/%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 247 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0'?%3E %3Csvg xmlns='http://www.w3.org/2000/svg' id='Layer_1' data-name='Layer 1' viewBox='6 6 24 24'%3E %3Cdefs%3E %3Cstyle%3E .cls-4%7Bfill:none;stroke:%23575e75;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px;%7D %3C/style%3E %3C/defs%3E %3Ctitle%3Ezoom-out%3C/title%3E %3Cg class='cls-3'%3E %3Ccircle class='cls-4' cx='18' cy='18' r='7'/%3E %3Cline class='cls-4' x1='23' y1='23' x2='26' y2='26'/%3E %3Cline class='cls-4' x1='16' y1='18' x2='20' y2='18'/%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 248 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml,%3C?xml version='1.0'?%3E %3Csvg xmlns='http://www.w3.org/2000/svg' id='Layer_1' data-name='Layer 1' viewBox='6 6 24 24'%3E %3Cdefs%3E %3Cstyle%3E .cls-4%7Bfill:%23575e75;%7D %3C/style%3E %3C/defs%3E %3Ctitle%3Ezoom-reset%3C/title%3E %3Cg class='cls-3'%3E %3Crect class='cls-4' x='13' y='14' width='10' height='2' rx='1' ry='1'/%3E %3Crect class='cls-4' x='13' y='20' width='10' height='2' rx='1' ry='1'/%3E %3C/g%3E %3C/svg%3E"

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _lodash3 = __webpack_require__(45);

var _lodash4 = _interopRequireDefault(_lodash3);

var _reactRedux = __webpack_require__(6);

var _copyPasteHoc = __webpack_require__(85);

var _copyPasteHoc2 = _interopRequireDefault(_copyPasteHoc);

var _bitmap = __webpack_require__(21);

var _selection = __webpack_require__(3);

var _group = __webpack_require__(24);

var _selectedItems = __webpack_require__(7);

var _modes = __webpack_require__(10);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

var _modes2 = __webpack_require__(4);

var _modes3 = _interopRequireDefault(_modes2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KeyboardShortcutsHOC = function KeyboardShortcutsHOC(WrappedComponent) {
    var KeyboardShortcutsWrapper = function (_React$Component) {
        _inherits(KeyboardShortcutsWrapper, _React$Component);

        function KeyboardShortcutsWrapper(props) {
            _classCallCheck(this, KeyboardShortcutsWrapper);

            var _this = _possibleConstructorReturn(this, (KeyboardShortcutsWrapper.__proto__ || Object.getPrototypeOf(KeyboardShortcutsWrapper)).call(this, props));

            (0, _lodash2.default)(_this, ['handleKeyPress', 'changeToASelectMode', 'selectAll']);
            return _this;
        }

        _createClass(KeyboardShortcutsWrapper, [{
            key: 'handleKeyPress',
            value: function handleKeyPress(event) {
                if (event.target instanceof HTMLInputElement) {
                    // Ignore keyboard shortcuts if a text input field is focused
                    return;
                }
                // Don't activate keyboard shortcuts during text editing
                if (this.props.textEditing) return;

                if (event.key === 'Escape') {
                    event.preventDefault();
                    (0, _selection.clearSelection)(this.props.clearSelectedItems);
                } else if (event.key === 'Delete' || event.key === 'Backspace') {
                    event.preventDefault();
                    if ((0, _selection.deleteSelection)(this.props.mode, this.props.onUpdateImage)) {
                        this.props.setSelectedItems(this.props.format);
                    }
                } else if (event.metaKey || event.ctrlKey) {
                    if (event.shiftKey && event.key.toLowerCase() === 'z') {
                        this.props.onRedo();
                    } else if (event.key === 'z') {
                        this.props.onUndo();
                    } else if (event.shiftKey && event.key.toLowerCase() === 'g') {
                        if ((0, _group.shouldShowUngroup)()) {
                            (0, _group.ungroupSelection)(_selectedItems.clearSelectedItems, _selectedItems.setSelectedItems, this.props.onUpdateImage);
                        }
                        event.preventDefault();
                    } else if (event.key === 'g') {
                        if ((0, _group.shouldShowGroup)()) {
                            (0, _group.groupSelection)(_selectedItems.clearSelectedItems, _selectedItems.setSelectedItems, this.props.onUpdateImage);
                        }
                        event.preventDefault();
                    } else if (event.key === 'c') {
                        this.props.onCopyToClipboard();
                    } else if (event.key === 'v') {
                        this.changeToASelectMode();
                        this.props.onPasteFromClipboard();
                    } else if (event.key === 'x') {
                        var selectedItems = (0, _selection.getSelectedRootItems)();
                        if (selectedItems.length > 0) {
                            this.props.onCopyToClipboard();
                            if ((0, _selection.deleteSelection)(this.props.mode, this.props.onUpdateImage)) {
                                this.props.setSelectedItems(this.props.format);
                            }
                        }
                        event.preventDefault();
                    } else if (event.key === 'a') {
                        this.changeToASelectMode();
                        event.preventDefault();
                        this.selectAll();
                    }
                }
            }
        }, {
            key: 'changeToASelectMode',
            value: function changeToASelectMode() {
                if ((0, _format.isBitmap)(this.props.format)) {
                    if (this.props.mode !== _modes3.default.BIT_SELECT) {
                        this.props.changeMode(_modes3.default.BIT_SELECT);
                    }
                } else if (this.props.mode !== _modes3.default.SELECT && this.props.mode !== _modes3.default.RESHAPE) {
                    this.props.changeMode(_modes3.default.SELECT);
                }
            }
        }, {
            key: 'selectAll',
            value: function selectAll() {
                if ((0, _format.isBitmap)(this.props.format)) {
                    (0, _bitmap.selectAllBitmap)(this.props.clearSelectedItems);
                    this.props.setSelectedItems(this.props.format);
                } else if (this.props.mode === _modes3.default.RESHAPE) {
                    if ((0, _selection.selectAllSegments)()) this.props.setSelectedItems(this.props.format);
                } else if ((0, _selection.selectAllItems)()) {
                    this.props.setSelectedItems(this.props.format);
                }
            }
        }, {
            key: 'render',
            value: function render() {
                var componentProps = (0, _lodash4.default)(this.props, ['changeMode', 'clearSelectedItems', 'format', 'mode', 'onCopyToClipboard', 'onPasteFromClipboard', 'setSelectedItems', 'textEditing']);
                return _react2.default.createElement(WrappedComponent, _extends({
                    onKeyPress: this.handleKeyPress
                }, componentProps));
            }
        }]);

        return KeyboardShortcutsWrapper;
    }(_react2.default.Component);

    KeyboardShortcutsWrapper.propTypes = {
        changeMode: _propTypes2.default.func.isRequired,
        clearSelectedItems: _propTypes2.default.func.isRequired,
        format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
        mode: _propTypes2.default.oneOf(Object.keys(_modes3.default)).isRequired,
        onCopyToClipboard: _propTypes2.default.func.isRequired,
        onPasteFromClipboard: _propTypes2.default.func.isRequired,
        onRedo: _propTypes2.default.func.isRequired,
        onUndo: _propTypes2.default.func.isRequired,
        onUpdateImage: _propTypes2.default.func.isRequired,
        setSelectedItems: _propTypes2.default.func.isRequired,
        textEditing: _propTypes2.default.bool.isRequired
    };

    var mapStateToProps = function mapStateToProps(state) {
        return {
            mode: state.scratchPaint.mode,
            format: state.scratchPaint.format,
            textEditing: state.scratchPaint.textEditTarget !== null
        };
    };
    var mapDispatchToProps = function mapDispatchToProps(dispatch) {
        return {
            changeMode: function changeMode(mode) {
                dispatch((0, _modes.changeMode)(mode));
            },
            clearSelectedItems: function clearSelectedItems() {
                dispatch((0, _selectedItems.clearSelectedItems)());
            },
            setSelectedItems: function setSelectedItems(format) {
                dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), (0, _format.isBitmap)(format)));
            }
        };
    };

    return (0, _copyPasteHoc2.default)((0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(KeyboardShortcutsWrapper));
};

exports.default = KeyboardShortcutsHOC;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(6);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SelectionHOC = function SelectionHOC(WrappedComponent) {
    var SelectionComponent = function (_React$Component) {
        _inherits(SelectionComponent, _React$Component);

        function SelectionComponent(props) {
            _classCallCheck(this, SelectionComponent);

            var _this = _possibleConstructorReturn(this, (SelectionComponent.__proto__ || Object.getPrototypeOf(SelectionComponent)).call(this, props));

            (0, _lodash2.default)(_this, ['removeItemById']);
            return _this;
        }

        _createClass(SelectionComponent, [{
            key: 'componentDidUpdate',
            value: function componentDidUpdate(prevProps) {
                // Hovered item has changed
                if (this.props.hoveredItemId && this.props.hoveredItemId !== prevProps.hoveredItemId || !this.props.hoveredItemId && prevProps.hoveredItemId) {
                    // Remove the old hover item if any
                    this.removeItemById(prevProps.hoveredItemId);
                }
            }
        }, {
            key: 'removeItemById',
            value: function removeItemById(itemId) {
                if (itemId) {
                    var match = _paper2.default.project.getItem({
                        match: function match(item) {
                            return item.id === itemId;
                        }
                    });
                    if (match) {
                        match.remove();
                    }
                }
            }
        }, {
            key: 'render',
            value: function render() {
                var _props = this.props,
                    hoveredItemId = _props.hoveredItemId,
                    props = _objectWithoutProperties(_props, ['hoveredItemId']);

                return _react2.default.createElement(WrappedComponent, props);
            }
        }]);

        return SelectionComponent;
    }(_react2.default.Component);

    SelectionComponent.propTypes = {
        hoveredItemId: _propTypes2.default.number
    };

    var mapStateToProps = function mapStateToProps(state) {
        return {
            hoveredItemId: state.scratchPaint.hoveredItemId
        };
    };
    return (0, _reactRedux.connect)(mapStateToProps)(SelectionComponent);
};

exports.default = SelectionHOC;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _lodash3 = __webpack_require__(45);

var _lodash4 = _interopRequireDefault(_lodash3);

var _reactRedux = __webpack_require__(6);

var _selection = __webpack_require__(3);

var _selectedItems = __webpack_require__(7);

var _undo = __webpack_require__(47);

var _undo2 = __webpack_require__(35);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UndoHOC = function UndoHOC(WrappedComponent) {
    var UndoWrapper = function (_React$Component) {
        _inherits(UndoWrapper, _React$Component);

        function UndoWrapper(props) {
            _classCallCheck(this, UndoWrapper);

            var _this = _possibleConstructorReturn(this, (UndoWrapper.__proto__ || Object.getPrototypeOf(UndoWrapper)).call(this, props));

            (0, _lodash2.default)(_this, ['handleUndo', 'handleRedo', 'handleSetSelectedItems', 'shouldShowUndo', 'shouldShowRedo']);
            return _this;
        }

        _createClass(UndoWrapper, [{
            key: 'handleUndo',
            value: function handleUndo() {
                (0, _undo.performUndo)(this.props.undoState, this.props.onUndo, this.handleSetSelectedItems, this.props.onUpdateImage);
            }
        }, {
            key: 'handleRedo',
            value: function handleRedo() {
                (0, _undo.performRedo)(this.props.undoState, this.props.onRedo, this.handleSetSelectedItems, this.props.onUpdateImage);
            }
        }, {
            key: 'handleSetSelectedItems',
            value: function handleSetSelectedItems() {
                this.props.setSelectedItems(this.props.format);
            }
        }, {
            key: 'shouldShowUndo',
            value: function shouldShowUndo() {
                return (0, _undo.shouldShowUndo)(this.props.undoState);
            }
        }, {
            key: 'shouldShowRedo',
            value: function shouldShowRedo() {
                return (0, _undo.shouldShowRedo)(this.props.undoState);
            }
        }, {
            key: 'render',
            value: function render() {
                var componentProps = (0, _lodash4.default)(this.props, ['format', 'onUndo', 'onRedo', 'setSelectedItems', 'undoState']);
                return _react2.default.createElement(WrappedComponent, _extends({
                    shouldShowRedo: this.shouldShowRedo,
                    shouldShowUndo: this.shouldShowUndo,
                    onRedo: this.handleRedo,
                    onUndo: this.handleUndo
                }, componentProps));
            }
        }]);

        return UndoWrapper;
    }(_react2.default.Component);

    UndoWrapper.propTypes = {
        format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
        onRedo: _propTypes2.default.func.isRequired,
        onUndo: _propTypes2.default.func.isRequired,
        onUpdateImage: _propTypes2.default.func.isRequired,
        setSelectedItems: _propTypes2.default.func.isRequired,
        undoState: _propTypes2.default.shape({
            stack: _propTypes2.default.arrayOf(_propTypes2.default.object).isRequired,
            pointer: _propTypes2.default.number.isRequired
        })
    };

    var mapStateToProps = function mapStateToProps(state) {
        return {
            format: state.scratchPaint.format,
            undoState: state.scratchPaint.undo
        };
    };
    var mapDispatchToProps = function mapDispatchToProps(dispatch) {
        return {
            setSelectedItems: function setSelectedItems(format) {
                dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), (0, _format.isBitmap)(format)));
            },
            onUndo: function onUndo(format) {
                dispatch((0, _undo2.undo)(format));
            },
            onRedo: function onRedo(format) {
                dispatch((0, _undo2.redo)(format));
            }
        };
    };

    return (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(UndoWrapper);
};

exports.default = UndoHOC;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paper = __webpack_require__(2);

var _paper2 = _interopRequireDefault(_paper);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _log = __webpack_require__(8);

var _log2 = _interopRequireDefault(_log);

var _lodash = __webpack_require__(5);

var _lodash2 = _interopRequireDefault(_lodash);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _lodash3 = __webpack_require__(45);

var _lodash4 = _interopRequireDefault(_lodash3);

var _reactRedux = __webpack_require__(6);

var _undo = __webpack_require__(35);

var _selectedItems = __webpack_require__(7);

var _viewBounds = __webpack_require__(37);

var _selection = __webpack_require__(3);

var _layer = __webpack_require__(12);

var _bitmap = __webpack_require__(21);

var _undo2 = __webpack_require__(47);

var _math = __webpack_require__(20);

var _view = __webpack_require__(22);

var _modes = __webpack_require__(4);

var _modes2 = _interopRequireDefault(_modes);

var _format = __webpack_require__(11);

var _format2 = _interopRequireDefault(_format);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UpdateImageHOC = function UpdateImageHOC(WrappedComponent) {
    var UpdateImageWrapper = function (_React$Component) {
        _inherits(UpdateImageWrapper, _React$Component);

        function UpdateImageWrapper(props) {
            _classCallCheck(this, UpdateImageWrapper);

            var _this = _possibleConstructorReturn(this, (UpdateImageWrapper.__proto__ || Object.getPrototypeOf(UpdateImageWrapper)).call(this, props));

            (0, _lodash2.default)(_this, ['handleUpdateImage', 'handleUpdateBitmap', 'handleUpdateVector']);
            return _this;
        }
        /**
         * @param {?boolean} skipSnapshot True if the call to update image should not trigger saving
         * an undo state. For instance after calling undo.
         * @param {?Formats} formatOverride Normally the mode is used to determine the format of the image,
         * but the format used can be overridden here. In particular when converting between formats,
         * the does not accurately represent the format.
         */


        _createClass(UpdateImageWrapper, [{
            key: 'handleUpdateImage',
            value: function handleUpdateImage(skipSnapshot, formatOverride) {
                // If in the middle of switching formats, rely on the current mode instead of format.
                var actualFormat = formatOverride ? formatOverride : _modes.BitmapModes[this.props.mode] ? _format2.default.BITMAP : _format2.default.VECTOR;
                if ((0, _format.isBitmap)(actualFormat)) {
                    this.handleUpdateBitmap(skipSnapshot);
                } else if ((0, _format.isVector)(actualFormat)) {
                    this.handleUpdateVector(skipSnapshot);
                }
                // Any time an image update is made, recalculate the bounds of the artwork
                (0, _view.setWorkspaceBounds)();
                this.props.updateViewBounds(_paper2.default.view.matrix);
            }
        }, {
            key: 'handleUpdateBitmap',
            value: function handleUpdateBitmap(skipSnapshot) {
                if (!(0, _layer.getRaster)().loaded) {
                    // In general, callers of updateImage should wait for getRaster().loaded = true before
                    // calling updateImage.
                    // However, this may happen if the user is rapidly undoing/redoing. In this case it's safe
                    // to skip the update.
                    _log2.default.warn('Bitmap layer should be loaded before calling updateImage.');
                    return;
                }
                // Anything that is selected is on the vector layer waiting to be committed to the bitmap layer.
                // Plaster the selection onto the raster layer before exporting, if there is a selection.
                var plasteredRaster = (0, _layer.getRaster)().getSubRaster((0, _layer.getRaster)().bounds); // Clone the raster layer
                plasteredRaster.remove(); // Don't insert
                var selectedItems = (0, _selection.getSelectedLeafItems)();
                if (selectedItems.length === 1) {
                    var item = selectedItems[0];
                    if (item instanceof _paper2.default.Raster) {
                        if (!item.loaded || item.data && item.data.expanded && !item.data.expanded.loaded) {
                            // This may get logged when rapidly undoing/redoing or changing costumes,
                            // in which case the warning is not relevant.
                            _log2.default.warn('Bitmap layer should be loaded before calling updateImage.');
                            return;
                        }
                        (0, _bitmap.commitSelectionToBitmap)(item, plasteredRaster);
                    } else if (item instanceof _paper2.default.Shape && item.type === 'rectangle') {
                        (0, _bitmap.commitRectToBitmap)(item, plasteredRaster);
                    } else if (item instanceof _paper2.default.Shape && item.type === 'ellipse') {
                        (0, _bitmap.commitOvalToBitmap)(item, plasteredRaster);
                    } else if (item instanceof _paper2.default.PointText) {
                        var bounds = item.drawnBounds;
                        var textRaster = item.rasterize(72, false /* insert */, bounds);
                        plasteredRaster.drawImage(textRaster.canvas, new _paper2.default.Point(Math.floor(bounds.x), Math.floor(bounds.y)));
                    }
                }
                var rect = (0, _bitmap.getHitBounds)(plasteredRaster);

                // Use 1x1 instead of 0x0 for getting imageData since paper.js automagically
                // returns the full artboard in the case of getImageData(0x0).
                // Bitmaps need a non-zero width/height in order to be saved as PNG.
                if (rect.width === 0 || rect.height === 0) {
                    rect.width = rect.height = 1;
                }

                var imageData = plasteredRaster.getImageData(rect);

                this.props.onUpdateImage(false /* isVector */
                , imageData, _view.ART_BOARD_WIDTH / 2 - rect.x, _view.ART_BOARD_HEIGHT / 2 - rect.y);

                if (!skipSnapshot) {
                    (0, _undo2.performSnapshot)(this.props.undoSnapshot, _format2.default.BITMAP);
                }
            }
        }, {
            key: 'handleUpdateVector',
            value: function handleUpdateVector(skipSnapshot) {
                // Remove viewbox (this would make it export at MAX_WORKSPACE_BOUNDS)
                var workspaceMask = void 0;
                if (_paper2.default.project.activeLayer.clipped) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = _paper2.default.project.activeLayer.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var child = _step.value;

                            if (child.isClipMask()) {
                                workspaceMask = child;
                                break;
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    _paper2.default.project.activeLayer.clipped = false;
                    workspaceMask.remove();
                }
                var guideLayers = (0, _layer.hideGuideLayers)(true /* includeRaster */);

                // Export at 0.5x
                (0, _math.scaleWithStrokes)(_paper2.default.project.activeLayer, .5, new _paper2.default.Point());

                var bounds = _paper2.default.project.activeLayer.drawnBounds;

                // `bounds.x` and `bounds.y` are relative to the top left corner,
                // but if there is no content in the active layer, they default to 0,
                // making the "Scratch space" rotation center ((SVG_ART_BOARD_WIDTH / 2), (SVG_ART_BOARD_HEIGHT / 2)),
                // aka the upper left corner. Special-case this to be (0, 0), which is the center of the art board.
                var centerX = bounds.width === 0 ? 0 : _view.SVG_ART_BOARD_WIDTH / 2 - bounds.x;
                var centerY = bounds.height === 0 ? 0 : _view.SVG_ART_BOARD_HEIGHT / 2 - bounds.y;

                this.props.onUpdateImage(true /* isVector */
                , _paper2.default.project.exportSVG({
                    asString: true,
                    bounds: 'content',
                    matrix: new _paper2.default.Matrix().translate(-bounds.x, -bounds.y)
                }), centerX, centerY);
                (0, _math.scaleWithStrokes)(_paper2.default.project.activeLayer, 2, new _paper2.default.Point());
                _paper2.default.project.activeLayer.applyMatrix = true;

                (0, _layer.showGuideLayers)(guideLayers);

                // Add back viewbox
                if (workspaceMask) {
                    _paper2.default.project.activeLayer.addChild(workspaceMask);
                    workspaceMask.clipMask = true;
                }

                if (!skipSnapshot) {
                    (0, _undo2.performSnapshot)(this.props.undoSnapshot, _format2.default.VECTOR);
                }
            }
        }, {
            key: 'render',
            value: function render() {
                var componentProps = (0, _lodash4.default)(this.props, ['format', 'onUpdateImage', 'undoSnapshot']);
                return _react2.default.createElement(WrappedComponent, _extends({
                    onUpdateImage: this.handleUpdateImage
                }, componentProps));
            }
        }]);

        return UpdateImageWrapper;
    }(_react2.default.Component);

    UpdateImageWrapper.propTypes = {
        format: _propTypes2.default.oneOf(Object.keys(_format2.default)),
        mode: _propTypes2.default.oneOf(Object.keys(_modes2.default)).isRequired,
        onUpdateImage: _propTypes2.default.func.isRequired,
        undoSnapshot: _propTypes2.default.func.isRequired,
        updateViewBounds: _propTypes2.default.func.isRequired
    };

    var mapStateToProps = function mapStateToProps(state) {
        return {
            format: state.scratchPaint.format,
            mode: state.scratchPaint.mode,
            undoState: state.scratchPaint.undo
        };
    };
    var mapDispatchToProps = function mapDispatchToProps(dispatch) {
        return {
            setSelectedItems: function setSelectedItems(format) {
                dispatch((0, _selectedItems.setSelectedItems)((0, _selection.getSelectedLeafItems)(), (0, _format.isBitmap)(format)));
            },
            undoSnapshot: function undoSnapshot(snapshot) {
                dispatch((0, _undo.undoSnapshot)(snapshot));
            },
            updateViewBounds: function updateViewBounds(matrix) {
                dispatch((0, _viewBounds.updateViewBounds)(matrix));
            }
        };
    };

    return (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(UpdateImageWrapper);
};

exports.default = UpdateImageHOC;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _redux = __webpack_require__(58);

var _modes = __webpack_require__(10);

var _modes2 = _interopRequireDefault(_modes);

var _bitBrushSize = __webpack_require__(87);

var _bitBrushSize2 = _interopRequireDefault(_bitBrushSize);

var _bitEraserSize = __webpack_require__(88);

var _bitEraserSize2 = _interopRequireDefault(_bitEraserSize);

var _brushMode = __webpack_require__(86);

var _brushMode2 = _interopRequireDefault(_brushMode);

var _eraserMode = __webpack_require__(51);

var _eraserMode2 = _interopRequireDefault(_eraserMode);

var _color = __webpack_require__(254);

var _color2 = _interopRequireDefault(_color);

var _clipboard = __webpack_require__(49);

var _clipboard2 = _interopRequireDefault(_clipboard);

var _cursor = __webpack_require__(25);

var _cursor2 = _interopRequireDefault(_cursor);

var _fillBitmapShapes = __webpack_require__(89);

var _fillBitmapShapes2 = _interopRequireDefault(_fillBitmapShapes);

var _fillMode = __webpack_require__(255);

var _fillMode2 = _interopRequireDefault(_fillMode);

var _font = __webpack_require__(57);

var _font2 = _interopRequireDefault(_font);

var _format = __webpack_require__(40);

var _format2 = _interopRequireDefault(_format);

var _hover = __webpack_require__(36);

var _hover2 = _interopRequireDefault(_hover);

var _layout = __webpack_require__(56);

var _layout2 = _interopRequireDefault(_layout);

var _modals = __webpack_require__(52);

var _modals2 = _interopRequireDefault(_modals);

var _selectedItems = __webpack_require__(7);

var _selectedItems2 = _interopRequireDefault(_selectedItems);

var _textEditTarget = __webpack_require__(44);

var _textEditTarget2 = _interopRequireDefault(_textEditTarget);

var _viewBounds = __webpack_require__(37);

var _viewBounds2 = _interopRequireDefault(_viewBounds);

var _undo = __webpack_require__(35);

var _undo2 = _interopRequireDefault(_undo);

var _zoomLevels = __webpack_require__(60);

var _zoomLevels2 = _interopRequireDefault(_zoomLevels);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _redux.combineReducers)({
    mode: _modes2.default,
    bitBrushSize: _bitBrushSize2.default,
    bitEraserSize: _bitEraserSize2.default,
    brushMode: _brushMode2.default,
    color: _color2.default,
    clipboard: _clipboard2.default,
    cursor: _cursor2.default,
    eraserMode: _eraserMode2.default,
    fillBitmapShapes: _fillBitmapShapes2.default,
    fillMode: _fillMode2.default,
    font: _font2.default,
    format: _format2.default,
    hoveredItemId: _hover2.default,
    layout: _layout2.default,
    modals: _modals2.default,
    selectedItems: _selectedItems2.default,
    textEditTarget: _textEditTarget2.default,
    undo: _undo2.default,
    viewBounds: _viewBounds2.default,
    zoomLevels: _zoomLevels2.default
});

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _redux = __webpack_require__(58);

var _eyeDropper = __webpack_require__(39);

var _eyeDropper2 = _interopRequireDefault(_eyeDropper);

var _fillStyle = __webpack_require__(18);

var _fillStyle2 = _interopRequireDefault(_fillStyle);

var _strokeStyle = __webpack_require__(31);

var _strokeStyle2 = _interopRequireDefault(_strokeStyle);

var _strokeWidth = __webpack_require__(32);

var _strokeWidth2 = _interopRequireDefault(_strokeWidth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _redux.combineReducers)({
    eyeDropper: _eyeDropper2.default,
    fillColor: _fillStyle2.default,
    strokeColor: _strokeStyle2.default,
    strokeWidth: _strokeWidth2.default
});

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _redux = __webpack_require__(58);

var _fillModeGradientType = __webpack_require__(41);

var _fillModeGradientType2 = _interopRequireDefault(_fillModeGradientType);

var _colorIndex = __webpack_require__(42);

var _colorIndex2 = _interopRequireDefault(_colorIndex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _redux.combineReducers)({
    gradientType: _fillModeGradientType2.default,
    colorIndex: _colorIndex2.default
});

/***/ })
/******/ ]);
//# sourceMappingURL=scratch-paint.js.map